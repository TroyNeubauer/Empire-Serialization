
#File: C:\Empire Serialization\.metadata\.plugins\org.eclipse.cdt.make.core\specs.c



#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\ByteInterpreter.java

package com.troy.byteviewer;

import java.nio.ByteBuffer;

public interface ByteInterpreter {
	public char[] interpret(ByteBuffer buffer, int length);
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\ByteInterpreters.java

package com.troy.byteviewer;

import java.nio.ByteBuffer;

public class ByteInterpreters {
	public static final ByteInterpreter ASCII = new ByteInterpreter() {

		@Override
		public char[] interpret(ByteBuffer buffer, int length) {
			char[] result = new char[length];
			for (int i = 0; i < length; i++) {
				result[i] = (char) buffer.get(i);
			}
			return result;
		}
	};
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\FileViewer.java

package com.troy.byteviewer;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.io.File;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

import javax.swing.JPanel;
import javax.swing.JScrollBar;

import com.troy.empireserialization.util.MiscUtil;

public class FileViewer extends JPanel {
	private File file;
	private FileChannel channel;
	private JScrollBar bar;
	private FileViewerImpl impl;

	public FileViewer(File file, Settings settings) throws IOException {
		super(new GridBagLayout(), false);
		setFocusable(true);
		requestFocusInWindow();
		this.file = file;
		channel = FileChannel.open(Paths.get(file.toURI()), StandardOpenOption.READ);
		updateSettings(settings);
		update();
		bar.addAdjustmentListener(new AdjustmentListener() {
			@Override
			public void adjustmentValueChanged(AdjustmentEvent e) {
				update();
			}
		});
		this.addMouseWheelListener(new MouseWheelListener() {
			@Override
			public void mouseWheelMoved(MouseWheelEvent e) {
				bar.setValue(bar.getValue() + e.getWheelRotation());
				update();
			}
		});
	}

	public void updateSettings(Settings settings) {
		this.removeAll();
		impl = new FileViewerImpl(channel, file, new Settings(), false, file.length());
		bar = new JScrollBar(JScrollBar.VERTICAL, 0, 0, 0, 0);
		GridBagConstraints g = new GridBagConstraints();
		onResize();

		g.weightx = 1000.0;
		g.weighty = 10.0;
		g.fill = GridBagConstraints.BOTH;

		add(impl, g);

		g.gridx = 1;
		g.weightx = 1.0;
		g.fill = GridBagConstraints.VERTICAL;

		add(bar, g);
	}

	public int calculateMaxRows() {
		int height = impl.getHeight();
		height -= FileViewerImpl.Y_OFFSET;
		int rows = (int) Math.ceil((double) height / ((double) impl.fontHeight + (double) FileViewerImpl.Y_PADDING) + 0.5);
		rows = Math.max(rows, 0);
		return rows;
	}

	private void update() {
		impl.update(bar.getValue());
	}

	public void close() {
		try {
			channel.close();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public void onResize() {
		int rows = calculateMaxRows();
		bar.getModel().setExtent(rows);
		long totalRows = impl.length / impl.cols + 10;
		boolean mapDirectly = totalRows < Integer.MAX_VALUE;
		impl.mapDirectly = mapDirectly;
		int max = mapDirectly ? (int) totalRows : Integer.MAX_VALUE;
		bar.getModel().setMaximum(max);
		impl.updateSize(rows, impl.cols);
	}

	public void onKeyPressed(KeyEvent e) {
		int move = 0;
		if (e.getKeyCode() == KeyEvent.VK_LEFT)
			move = -1;
		else if (e.getKeyCode() == KeyEvent.VK_RIGHT)
			move = +1;
		else if (e.getKeyCode() == KeyEvent.VK_UP)
			move = -impl.cols;
		else if (e.getKeyCode() == KeyEvent.VK_DOWN)
			move = +impl.cols;
		if (move != 0) {
			if (impl.selectionStart == -1)
				return;
			impl.selectionEnd += move;
			impl.selectionEnd = MiscUtil.clamp(0, impl.length - 1, impl.selectionEnd);
			if (impl.selectionEnd / impl.cols - impl.scroll > impl.rows - 2) {
				bar.getModel().setValue(bar.getModel().getValue() + 1);
			}
			if (impl.selectionEnd / impl.cols - impl.scroll < 0) {
				bar.getModel().setValue(bar.getModel().getValue() - 1);
			}
		}
	}

	public boolean needsRepaint() {
		return impl.needsRepaint();
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\FileViewerImpl.java

package com.troy.byteviewer;

import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.io.File;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

import javax.swing.JPanel;

import com.troy.byteviewer.guess.AnnotatedSection;
import com.troy.byteviewer.guess.GuessCoordinator;
import com.troy.empireserialization.util.StringFormatter;

public class FileViewerImpl extends JPanel {
	protected FileChannel channel;
	protected int rows, cols;
	protected boolean mapDirectly;
	protected ByteBuffer buffer;
	protected char[] byteText, textInterp;
	protected int scroll = 0;
	protected Font font;
	protected long length;
	protected int maxDigits;
	protected int fontHeight = -1;
	// How many pixels offset in the top left takes up
	protected int xOffset = -1;
	// How wide is a single character
	protected int pixelsSingleChar;
	protected long selectionStart = -1, selectionEnd = -1;
	protected boolean dragged = false, draggedInText = false;
	private long lastChannelPosition = -1;
	private int bytes;
	private int renderCount = 0;
	private GuessCoordinator coordinator;

	public FileViewerImpl(FileChannel channel, File file, Settings settings, boolean mapDirectly, long length) {
		super(new FlowLayout());
		setFocusable(true);
		requestFocusInWindow();
		this.length = length;
		setBackground(Color.WHITE);
		this.channel = channel;
		this.mapDirectly = mapDirectly;
		updateSettings(settings);
		this.coordinator = new GuessCoordinator(length, file);

		this.addMouseMotionListener(new MouseMotionAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
				long x = getTileX(e.getX());
				long y = getTileY(e.getY()) + (long) scroll;
				long finalIndex = x + y * cols;
				renderCount = 0;
				if (dragged) {
					if (draggedInText) {
						x = getTileTextX(e.getX());
						finalIndex = x + y * cols;
					}
					if (finalIndex < length)
						selectionEnd = finalIndex;
				} else {
					if (x >= cols) {
						draggedInText = true;
						x = getTileTextX(e.getX());
						finalIndex = x + y * cols;
					} else {
						draggedInText = false;
					}
					if (finalIndex < length) {
						selectionStart = finalIndex;
						selectionEnd = finalIndex;
					} else {
						dragged = false;
					}
				}
				dragged = true;
			}
		});
		this.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				selectionStart = -1;
				selectionEnd = -1;
				renderCount = 0;
			}

			@Override
			public void mouseReleased(MouseEvent e) {
				dragged = false;
			}
		});
	}

	private void updateSettings(Settings settings) {
		this.font = settings.font;
		updateSize(settings.rows, settings.cols);
	}

	public void updateSize(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		int newCap = rows * cols;
		if (buffer == null || (buffer != null && buffer.capacity() != newCap)) {
			buffer = ByteBuffer.allocateDirect(newCap);
			byteText = new char[newCap * 3];
		}
		if (length == 0) {
			maxDigits = 1;
		} else {
			maxDigits = (int) Math.ceil(Math.log(length) / Math.log(cols));
		}
		renderCount = 0;
	}

	public void update(int scroll) {
		this.scroll = scroll;
		renderCount = 0;
	}

	protected static final int Y_OFFSET = 50, Y_PADDING = 0, X_OFFSET = 20;
	private static final String OFFSET = "Offset";
	private static final int OFFSET_X = 5, OFFSET_Y = 23, BOUNDS_OFFSET = 15;
	int count = 0;

	@Override
	protected void paintComponent(Graphics g) {
		try {
			super.paintComponent(g);
			renderCount++;
			g.setFont(font);
			g.setColor(Color.BLUE);
			g.drawString(OFFSET, OFFSET_X, OFFSET_Y);
			long index = (long) scroll * (long) cols;
			long visibleCount = cols * rows;
			if(length - scroll * cols < visibleCount) {
				visibleCount = length - scroll * cols;
			}

			FontMetrics m = g.getFontMetrics();
			if (fontHeight == -1) {
				fontHeight = m.getHeight();
				xOffset = Math.max(m.stringWidth(StringFormatter.toHexString(index, maxDigits)), m.stringWidth(OFFSET));
				pixelsSingleChar = m.charWidth('A');
			}
			for (int i = 0; i < rows; i++) {
				long value = i * cols + index;
				if (value > length)
					break;
				g.drawString(StringFormatter.toHexString(value, maxDigits), OFFSET_X, getPixelY(i));
			}
			for (int i = 0; i < cols; i++) {
				int finalX = getPixelX(i);
				g.drawString(Integer.toHexString(i), finalX, OFFSET_Y);
			}
			int bytes = 0;

			buffer.clear();
			lastChannelPosition = channel.position();
			bytes = channel.read(buffer);
			channel.position(index);
			for (int i = 0; i < bytes; i++) {
				byte b = buffer.get(i);
				byteText[i * 3 + 0] = StringFormatter.DIGITS[(b >>> 4) & 0x0F];
				byteText[i * 3 + 1] = StringFormatter.DIGITS[(b >>> 0) & 0x0F];
				byteText[i * 3 + 2] = ' ';
			}
			buffer.position(0);
			textInterp = Main.byteInterpreter.interpret(buffer, bytes);
			if (bytes == -1) {
				int finalX = getPixelX(cols / 2);
				int finalY = getPixelY(rows / 2);
				g.drawString("(Empty File)", finalX, finalY);
				return;
			}

			g.setColor(Color.BLACK);
			for (int row = 0; row < rows; row++) {
				int charsPerRow = cols * 3;
				int offset = row * cols;
				if (offset > bytes)
					break;
				int length = cols;
				if (offset + cols > bytes)
					length = bytes % cols;
				g.drawChars(byteText, row * charsPerRow, length * 3, getPixelX(0), getPixelY(row));
			}
			g.setColor(Color.GREEN);
			int newXOffset = getPixelX(cols + 1);
			for (int row = 0; row < rows; row++) {
				int offset = row * cols;
				if (offset > bytes)
					break;
				int length = cols;
				if (offset + cols > bytes)
					length = bytes % cols;

				g.drawChars(textInterp, offset, length, newXOffset, getPixelY(row));
			}
			for (int i = 0; i < bytes; i++) {
				if (i + index > length)
					break;
				int x = i % cols;
				int y = i / cols;
			}
			g.setColor(new Color(0, 0, 255, 128));
			if (selectionStart != -1) {
				boolean forward = selectionEnd > selectionStart;
				int increment = forward ? +1 : -1;
				for (long i = selectionStart; forward ? i <= selectionEnd : i >= selectionEnd; i += increment) {
					int x = (int) (i % cols);
					int y = (int) (i / cols - scroll);
					if (y < 0) {
						continue;
					}
					int finalX = x * getSpacingBetweenCols() + xOffset + X_OFFSET - pixelsSingleChar / 2;
					int finalY = y * getSpacingBetweenRows() + Y_OFFSET - fontHeight * 7 / 8;
					g.fillRect(finalX, finalY, getSpacingBetweenCols(), fontHeight);
				}
			}

			if (selectionStart != -1) {
				boolean forward = selectionEnd > selectionStart;
				int increment = forward ? +1 : -1;
				for (long i = selectionStart; forward ? i <= selectionEnd : i >= selectionEnd; i += increment) {
					int x = (int) (i % cols);
					int y = (int) (i / cols - scroll);
					int finalX = getPixelX(cols + 1) + x * pixelsSingleChar;
					int finalY = y * getSpacingBetweenRows() + Y_OFFSET - fontHeight * 7 / 8;
					g.fillRect(finalX, finalY, pixelsSingleChar, fontHeight);
				}
			}
			coordinator.ensureAnalyzed(index + visibleCount);
			System.out.println("================");
			for(AnnotatedSection sec : coordinator.getAnnotations(index, visibleCount)) {
				System.out.println(sec);
			}

		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	private int getTileX(int pixelX) {
		pixelX -= xOffset;
		pixelX -= X_OFFSET;
		return Math.max(pixelX / getSpacingBetweenCols(), 0);
	}

	private int getTileTextX(int pixelX) {
		pixelX -= getPixelX(cols + 1);
		return Math.min(Math.max(pixelX / pixelsSingleChar, -1), cols - 1);
	}

	private int getTileY(int pixelY) {
		pixelY -= Y_OFFSET;
		pixelY += getSpacingBetweenRows();
		return Math.max(0, pixelY / getSpacingBetweenRows());
	}

	private int getPixelX(int x) {
		return x * getSpacingBetweenCols() + xOffset + X_OFFSET;
	}

	private int getPixelY(int y) {
		return y * getSpacingBetweenRows() + Y_OFFSET;
	}

	private int getSpacingBetweenCols() {
		return pixelsSingleChar * 3;
	}

	private int getSpacingBetweenRows() {
		return fontHeight + Y_PADDING * 2;
	}

	public boolean needsRepaint() {
		return renderCount < 5;
	}
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\guess\AbstractGuess.java

package com.troy.byteviewer.guess;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

import com.troy.empireserialization.io.in.Input;

public abstract class AbstractGuess {

	private long maxOffset;
	private List<AnnotatedSection> guesses = new ArrayList<AnnotatedSection>();

	private static final Color[] ROTATION = { Color.MAGENTA, Color.ORANGE, Color.LIGHT_GRAY, Color.PINK, Color.RED };
	private static int colorIndex;
	
	protected long getOffset() {
		return maxOffset;
	}

	public void read(Input input, long minimunIndex) {
		long toRead = minimunIndex - maxOffset;
		if (toRead <= 0)
			return;
		maxOffset += readImpl(input, toRead, guesses);
	}
	
	public List<AnnotatedSection> getGuesses() {
		return guesses;
	}

	/**
	 * Reads for guesses and adds them to the list
	 * 
	 * @param input The input to read from
	 * @param minBytes The minimum number of bytes to read
	 * @param guesses The list of guesses to add to
	 * @return The number of actual bytes read (must be > {@code minBytes})
	 */
	public abstract long readImpl(Input input, long minBytes, List<AnnotatedSection> guesses);

	protected Color nextColor() {
		colorIndex %= ROTATION.length;
		return ROTATION[colorIndex++];
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\guess\AnnotatedSection.java

package com.troy.byteviewer.guess;

import java.awt.Color;

public class AnnotatedSection {
	private long offset, length;
	private String name, description;
	private Color color;

	public AnnotatedSection(long offset, long length, String name, String description, Color color) {
		this.offset = offset;
		this.length = length;
		this.name = name;
		this.description = description;
		this.color = color;
	}

	public long getOffset() {
		return offset;
	}

	public long getLength() {
		return length;
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return description;
	}

	public Color getColor() {
		return color;
	}

	@Override
	public String toString() {
		return "AnnotatedSection [offset=" + offset + ", length=" + length + ", name=" + name + ", description=" + description + "]";
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\guess\GuessCoordinator.java

package com.troy.byteviewer.guess;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.core.type.filter.AssignableTypeFilter;

import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.in.NativeFileInput;

public class GuessCoordinator {
	public static final List<Class<AbstractGuess>> guessClasses = new ArrayList<Class<AbstractGuess>>();

	static {
		ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
		provider.addIncludeFilter(new AssignableTypeFilter(AbstractGuess.class));

		Set<BeanDefinition> components = provider.findCandidateComponents("com/troy/byteviewer/guesses");
		boolean hasSubclass = false;
		for (BeanDefinition component : components) {
			try {
				Class<?> cls = Class.forName(component.getBeanClassName());
				if (AbstractGuess.class.isAssignableFrom(cls)) {
					Class<AbstractGuess> c = (Class<AbstractGuess>) cls;
					System.out.println(c);
					guessClasses.add(c);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}

	private ArrayList<AnnotatedSection>[] sections;
	private static final long BYTES_PER_SECTION = 1000;
	private ArrayList<AbstractGuess> guesses = new ArrayList<AbstractGuess>();
	private Input[] inputs;

	public GuessCoordinator(long length, File file) {
		sections = new ArrayList[(int) (length / BYTES_PER_SECTION + 1L)];
		for (Class<AbstractGuess> clazz : guessClasses) {
			try {
				guesses.add(clazz.newInstance());
			} catch (InstantiationException | IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}
		inputs = new Input[guessClasses.size()];
		for (int i = 0; i < inputs.length; i++)
			inputs[i] = new NativeFileInput(file);

	}

	public void ensureAnalyzed(long maxOffset) {
		int i = 0;
		for (AbstractGuess guess : guesses) {
			guess.read(inputs[i++], maxOffset);
			List<AnnotatedSection> s = guess.getGuesses();
			for (AnnotatedSection section : s) {
				int start = (int) (section.getOffset() / BYTES_PER_SECTION);
				int end = (int) ((section.getOffset() + section.getLength()) / BYTES_PER_SECTION);
				for (int j = start; j < end; j++) {
					sections[j].add(section);
				}
			}
			guess.getGuesses().clear();
		}
	}

	public List<AnnotatedSection> getAnnotations(long offset, long length) {
		int start = (int) (offset / BYTES_PER_SECTION);
		int end = (int) ((offset + length) / BYTES_PER_SECTION);
		List<AnnotatedSection> result = new ArrayList<AnnotatedSection>();
		for (int i = start; i < end; i++) {
			for (AnnotatedSection section : sections[i]) {
				if (section.getOffset() + section.getLength() >= offset && section.getOffset() < offset + length) {
					result.add(section);
				}
			}
		}
		return result;
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\guesses\EmpireStringGuess.java

package com.troy.byteviewer.guesses;

import java.util.List;

import com.troy.byteviewer.guess.AbstractGuess;
import com.troy.byteviewer.guess.AnnotatedSection;
import com.troy.empireserialization.EmpireConstants;
import com.troy.empireserialization.EmpireOpCodes;
import com.troy.empireserialization.charset.EmpireCharset;
import com.troy.empireserialization.charset.EmpireCharsets;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.util.MiscUtil;

public class EmpireStringGuess extends AbstractGuess {

	@Override
	public long readImpl(Input input, long minBytes, List<AnnotatedSection> guesses) {
		long count = 0;
		while (count < minBytes) {
			try {
				byte b = input.readByte();
				count++;
				if (b == EmpireOpCodes.HELLO_WORLD_STRING_CONST) {
					guesses.add(new AnnotatedSection(count + getOffset(), 1, "String: \"Hello, World!\"",
							"The opcode " + EmpireOpCodes.HELLO_WORLD_STRING_CONST + " can indicate the constant Hello, World!", nextColor()));
				} else if (b == EmpireOpCodes.EMPTY_STRING_CONST) {
					guesses.add(new AnnotatedSection(count + getOffset(), 1, "Empty String: \"\"",
							"The opcode " + EmpireOpCodes.EMPTY_STRING_CONST + " indicates an empty string", nextColor()));
				} else if ((b & EmpireOpCodes.MAJOR_CODE_MASK) == EmpireOpCodes.STRING_MAJOR_CODE) {
					long start = count - 1 + getOffset();
					int charset = b >> 4 & 0b11;
					int length = b & 0b1111;
					if (length == 0) {
						int temp = input.readByte();
						count++;
						length = temp & EmpireConstants.VLE_MASK;
						if ((temp & EmpireConstants.NEXT_BYTE_VLE) != 0) {
							temp = input.readByte();
							count++;
							length |= (temp & EmpireConstants.VLE_MASK) << 7;
							if ((temp & EmpireConstants.NEXT_BYTE_VLE) != 0) {
								temp = input.readByte();
								count++;
								length |= (temp & EmpireConstants.VLE_MASK) << 14;
								if ((temp & EmpireConstants.NEXT_BYTE_VLE) != 0) {
									temp = input.readByte();
									count++;
									length |= (temp & EmpireConstants.VLE_MASK) << 21;
									if ((temp & EmpireConstants.NEXT_BYTE_VLE) != 0) {
										temp = input.readByte();
										count++;
										length |= (temp & EmpireConstants.VLE_MASK) << 28;
									}
								}
							}
						}
					}
					EmpireCharset set = EmpireCharsets.get(charset);
					if (length * set.getBytesPerCharacter() > input.remaining())
						continue;
					System.out.println(input.remaining());
					char[] chars = new char[length];
					long decoded = set.decode(input, chars, 0, length);
					count += decoded;
					String name = "String: \"" + MiscUtil.createString(chars) + "\"";
					String description = "Charset: " + set.getClass().getSimpleName() + "\nCharacters: " + length + "\nEncoded in " + decoded
							+ " bytes";
					guesses.add(new AnnotatedSection(start, (count + getOffset()) - start, name, description, nextColor()));
				}
			} catch (Throwable e) {
				// Ignore.. If an exception is thrown we don't care because it wasn't a string
				// anyway
				e.printStackTrace();
				throw new RuntimeException(e);
			}
		}
		return count;
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\Main.java

package com.troy.byteviewer;

import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

public class Main {

	public static Window window;
	public static Settings settings = new Settings();
	public static ByteInterpreter byteInterpreter = ByteInterpreters.ASCII;

	public static void main(String[] args) {
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {
			e.printStackTrace();
		}
		window = new Window();
		while (true) {
			if (window.needsRepaint()) {
				window.onResize();
				window.repaint();
			}
			try {
				Thread.sleep(5);
			} catch (InterruptedException e) {
			}
		}

	}
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\MainPanel.java

package com.troy.byteviewer;

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTabbedPane;

public class MainPanel extends JTabbedPane {
	JFileChooser chooser = new JFileChooser();

	public MainPanel(Settings settings) {
		setFocusable(true);
		requestFocusInWindow();
	}

	public void openFile(File file) {
		try {
			FileViewer viewer = new FileViewer(file, Main.settings);
			int index = getTabCount();
			insertTab(file.getName(), null, viewer, null, index);
			setSelectedIndex(index);
		} catch (IOException e) {
			JOptionPane.showMessageDialog(getTopLevelAncestor(), "Error reading file:\n" + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	public void showOpenDialog() {
		chooser.showOpenDialog(this);
		chooser.setDialogTitle("Open File");

		openFile(chooser.getSelectedFile());
	}

	public void closeSelectedFile() {
		FileViewer viewer = (FileViewer) getSelectedComponent();
		if (viewer != null) {
			removeTabAt(getSelectedIndex());
			viewer.close();
		}
	}

	public void onResize() {
		for (int i = 0; i < getTabCount(); i++) {
			FileViewer viewer = (FileViewer) getComponentAt(i);
			viewer.onResize();
		}
	}

	public void onKeyPressed(KeyEvent e) {
		if (getSelectedIndex() != -1) {
			FileViewer viewer = (FileViewer) getComponentAt(getSelectedIndex());
			viewer.onKeyPressed(e);
		}
	}

	public boolean needsRepaint() {
		if (getSelectedIndex() != -1) {
			FileViewer viewer = (FileViewer) getComponentAt(getSelectedIndex());
			return viewer.needsRepaint();
		}
		return false;
	}
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\Menu.java

package com.troy.byteviewer;

import java.awt.event.ActionEvent;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;

public class Menu extends JMenuBar {
	public Menu() {
		JMenu file = new JMenu("File");
		ImageIcon openIcon = null, closeIcon = null;
		try {
			openIcon = new ImageIcon(ImageIO.read(Class.class.getResourceAsStream("/icons/open.png")));
			closeIcon = new ImageIcon(ImageIO.read(Class.class.getResourceAsStream("/icons/close.png")));
		} catch (IOException e) {
			e.printStackTrace();
		}
		JMenuItem open = new JMenuItem("Open", openIcon);
		open.addActionListener((ActionEvent e) -> {
			Main.window.getMainPanel().showOpenDialog();
		});
		
		JMenuItem close = new JMenuItem("Close", closeIcon);
		close.addActionListener((ActionEvent e) -> {
			Main.window.getMainPanel().closeSelectedFile();
		});
		file.add(open);
		file.add(close);
		
		add(file);
		
	}
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\Settings.java

package com.troy.byteviewer;

import java.awt.Font;

public class Settings {
	public int rows = 10, cols = 16;
	public Font font = new Font("Courier New", Font.BOLD, 23);
}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\SettingsWindow.java

package com.troy.byteviewer;

public class SettingsWindow {

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\StringUtils.java

package com.troy.byteviewer;

import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Globally available utility classes, mostly for string manipulation.
 * 
 * @author Jim Menard, <a href="mailto:jimm@io.com">jimm@io.com</a>
 */
public class StringUtils {
	/**
	 * Returns an array of strings, one for each line in the string after it has
	 * been wrapped to fit lines of <var>maxWidth</var>. Lines end with any of cr,
	 * lf, or cr lf. A line ending at the end of the string will not output a
	 * further, empty string.
	 * <p>
	 * This code assumes <var>str</var> is not <code>null</code>.
	 * 
	 * @param str
	 *            the string to split
	 * @param fm
	 *            needed for string width calculations
	 * @param maxWidth
	 *            the max line width, in points
	 * @return a non-empty list of strings
	 */
	public static List<String> wrap(String str, FontMetrics fm, int maxWidth) {
		List<String> lines = splitIntoLines(str);
		if (lines.size() == 0)
			return lines;

		ArrayList<String> strings = new ArrayList<String>();
		for (Iterator<String> iter = lines.iterator(); iter.hasNext();)
			wrapLineInto(iter.next(), strings, fm, maxWidth);
		return strings;
	}

	/**
	 * Given a line of text and font metrics information, wrap the line and add the
	 * new line(s) to <var>list</var>.
	 * 
	 * @param line
	 *            a line of text
	 * @param list
	 *            an output list of strings
	 * @param fm
	 *            font metrics
	 * @param maxWidth
	 *            maximum width of the line(s)
	 */
	public static void wrapLineInto(String line, List<String> list, FontMetrics fm, int maxWidth) {
		int len = line.length();
		int width;
		while (len > 0 && (width = fm.stringWidth(line)) > maxWidth) {
			// Guess where to split the line. Look for the next space before
			// or after the guess.
			int guess = len * maxWidth / width;
			String before = line.substring(0, guess).trim();

			width = fm.stringWidth(before);
			int pos;
			if (width > maxWidth) // Too long
				pos = findBreakBefore(line, guess);
			else { // Too short or possibly just right
				pos = findBreakAfter(line, guess);
				if (pos != -1) { // Make sure this doesn't make us too long
					before = line.substring(0, pos).trim();
					if (fm.stringWidth(before) > maxWidth)
						pos = findBreakBefore(line, guess);
				}
			}
			if (pos == -1)
				pos = guess; // Split in the middle of the word

			list.add(line.substring(0, pos).trim());
			line = line.substring(pos).trim();
			len = line.length();
		}
		if (len > 0)
			list.add(line);
	}

	/**
	 * Returns the index of the first whitespace character or '-' in <var>line</var>
	 * that is at or before <var>start</var>. Returns -1 if no such character is
	 * found.
	 * 
	 * @param line
	 *            a string
	 * @param start
	 *            where to star looking
	 */
	public static int findBreakBefore(String line, int start) {
		for (int i = start; i >= 0; --i) {
			char c = line.charAt(i);
			if (Character.isWhitespace(c) || c == '-')
				return i;
		}
		return -1;
	}

	/**
	 * Returns the index of the first whitespace character or '-' in <var>line</var>
	 * that is at or after <var>start</var>. Returns -1 if no such character is
	 * found.
	 * 
	 * @param line
	 *            a string
	 * @param start
	 *            where to star looking
	 */
	public static int findBreakAfter(String line, int start) {
		int len = line.length();
		for (int i = start; i < len; ++i) {
			char c = line.charAt(i);
			if (Character.isWhitespace(c) || c == '-')
				return i;
		}
		return -1;
	}

	/**
	 * Returns an array of strings, one for each line in the string. Lines end with
	 * any of cr, lf, or cr lf. A line ending at the end of the string will not
	 * output a further, empty string.
	 * <p>
	 * This code assumes <var>str</var> is not <code>null</code>.
	 * 
	 * @param str
	 *            the string to split
	 * @return a non-empty list of strings
	 */
	public static List<String> splitIntoLines(String str) {
		ArrayList<String> strings = new ArrayList<String>();

		int len = str.length();
		if (len == 0) {
			strings.add("");
			return strings;
		}

		int lineStart = 0;

		for (int i = 0; i < len; ++i) {
			char c = str.charAt(i);
			if (c == '\r') {
				int newlineLength = 1;
				if ((i + 1) < len && str.charAt(i + 1) == '\n')
					newlineLength = 2;
				strings.add(str.substring(lineStart, i));
				lineStart = i + newlineLength;
				if (newlineLength == 2) // skip \n next time through loop
					++i;
			} else if (c == '\n') {
				strings.add(str.substring(lineStart, i));
				lineStart = i + 1;
			}
		}
		if (lineStart < len)
			strings.add(str.substring(lineStart));

		return strings;
	}

	public static void drawStringPretty(int x, int y, Graphics g, String string) {
		drawStringPretty(x, y, g, string, g.getFontMetrics(), Integer.MAX_VALUE, 1.15);
	}

	public static void drawStringPretty(int x, int y, Graphics g, String string, int maxWidth, double spacing) {
		drawStringPretty(x, y, g, string, g.getFontMetrics(), maxWidth, spacing);
	}

	public static void drawStringPretty(int x, int y, Graphics g, String string, FontMetrics fontMetrics, int maxWidth, double spacing) {
		Rectangle2D rect = fontMetrics.getStringBounds(string, g);
		List<String> textList = StringUtils.wrap(string, fontMetrics, maxWidth);
		int height = fontMetrics.getHeight();
		int row = 0;
		for (String str : textList) {
			g.drawString(str, x, y + (int) (row * spacing * height));
			row++;
		}
	}

}

#File: C:\Empire Serialization\Byte Viewer\src\com\troy\byteviewer\Window.java

package com.troy.byteviewer;

import java.awt.Color;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import javax.swing.JFrame;

public class Window extends JFrame {
	private MainPanel panel;

	public Window() {
		super("Troy's Viewer");
		setFocusable(true);
		requestFocusInWindow();
		setSize(1280, 710);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setBackground(Color.WHITE);
		setLocationRelativeTo(null);
		setJMenuBar(new Menu());
		panel = new MainPanel(Main.settings);
		add(panel);
		addComponentListener(new ComponentAdapter() {
		    public void componentResized(ComponentEvent componentEvent) {
		    	panel.onResize();
		    }
		});
		addKeyListener(new KeyListener() {
			
			@Override
			public void keyTyped(KeyEvent e) {
				panel.onKeyPressed(e);
			}
			
			@Override
			public void keyReleased(KeyEvent e) {
				
			}
			
			@Override
			public void keyPressed(KeyEvent e) {
				panel.onKeyPressed(e);
			}
		});
		setVisible(true);
		panel.onResize();
	}

	public MainPanel getMainPanel() {
		return panel;
	}

	public void onResize() {
		panel.onResize();
	}

	public boolean needsRepaint() {
		return panel.needsRepaint();
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\BooleanValue.java

package com.troy.empireserialization.cache;

public class BooleanValue<E> {
	public E key;
	public boolean value;
	public BooleanValue<E> next;

	public BooleanValue(E key, boolean value, BooleanValue<E> next) {
		this.key = key;
		this.value = value;
		this.next = next;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\Cache.java

package com.troy.empireserialization.cache;

public abstract class Cache<Entry> {
	protected static final double DEFAULT_LOAD_FACTOR = 0.5;
	protected static final int DEFAULT_CAPACITY = 32;

	protected Entry[] table;
	protected double loadFactor;
	protected int size = 0;

	public Cache(int initalCapacity, double loadFactor) {
		this.loadFactor = loadFactor;
		resize(initalCapacity);
	}

	protected abstract void resize(int newSize);

	public int hash(Object key) {
		return key == null ? 0 : ((table.length - 1) & key.hashCode());
	}

	public int size() {
		return size;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntKey.java

package com.troy.empireserialization.cache;

public class IntKey<E> {
	public int key;
	public E value;
	public IntKey<E> next;

	public IntKey(int key, E value, IntKey<E> next) {
		this.key = key;
		this.value = value;
		this.next = next;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntKeyCache.java

package com.troy.empireserialization.cache;

public class IntKeyCache<E> extends Cache<IntKey<E>>{
	public IntKeyCache() {
		this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
	}

	public IntKeyCache(int initalCapacity) {
		this(initalCapacity, DEFAULT_LOAD_FACTOR);
	}

	public IntKeyCache(int initalCapacity, double loadFactor) {
		super(initalCapacity, loadFactor);

	}

	public void add(int key, E value) {
		if ((double) size / table.length >= loadFactor) {
			resize(size * 2);
		}
		int index = hash(key);
		IntKey<E> se = new IntKey<E>(key, value, null);
		if (table[index] == null) {
			table[index] = se;
		} else {
			IntKey<E> entry = table[index];
			while (entry.next != null) {
				if (entry.key == key)
					return;
				entry = entry.next;
			}
			if (entry.key == key)
				return;
			entry.next = se;
		}
		size++;
	}

	public IntKey<E> get(int key) {
		// Get a positive index using mod
		int index = hash(key);
		IntKey<E> entry = table[index];
		if (entry != null) {
			while (entry.next != null) {
				if (entry.key == key)
					return entry;
				entry = entry.next;
			}
		}
		return null;
	}

	protected void resize(int newSize) {
		IntKey<E>[] oldStrings = table;
		this.table = new IntKey[newSize];
		if (oldStrings != null) {
			for (int i = 0; i < oldStrings.length; i++) {
				IntKey<E> entry = oldStrings[i];
				while (entry != null) {
					add(entry.key, entry.value);
					entry = entry.next;
				}
			}
		}
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntStringCache.java

package com.troy.empireserialization.cache;

public class IntStringCache extends Cache<IntStringValue> {

	public IntStringCache() {
		this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
	}

	public IntStringCache(int initalCapacity) {
		this(initalCapacity, DEFAULT_LOAD_FACTOR);
	}

	public IntStringCache(int initalCapacity, double loadFactor) {
		super(initalCapacity, loadFactor);

	}

	public void add(int key, String value) {
		if ((double) size / table.length >= loadFactor) {
			resize(size * 2);
		}
		int index = hash(key);
		IntStringValue se = new IntStringValue(key, value, null);
		if (table[index] == null) {
			table[index] = se;
		} else {
			IntStringValue entry = table[index];
			while (entry.next != null) {
				if (entry.key == key)
					return;
				entry = entry.next;
			}
			if (entry.key == key)
				return;
			entry.next = se;
		}
		size++;
	}

	public IntStringValue get(int key) {
		// Get a positive index using mod
		int index = hash(key);
		IntStringValue entry = table[index];
		if (entry != null) {
			while (entry.next != null) {
				if (entry.key == key)
					return entry;
				entry = entry.next;
			}
		}
		return null;
	}

	protected void resize(int newSize) {
		IntStringValue[] oldStrings = table;
		this.table = new IntStringValue[newSize];
		if (oldStrings != null) {
			for (int i = 0; i < oldStrings.length; i++) {
				IntStringValue entry = oldStrings[i];
				while (entry != null) {
					add(entry.key, entry.value);
					entry = entry.next;
				}
			}
		}
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntStringValue.java

package com.troy.empireserialization.cache;

public class IntStringValue {
	public int key;
	public String value;
	public IntStringValue next;

	public IntStringValue(int key, String value, IntStringValue next) {
		this.key = key;
		this.value = value;
		this.next = next;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntValue.java

package com.troy.empireserialization.cache;

public class IntValue<E> {
	public E key;
	public int value;
	public IntValue<E> next;

	public IntValue(E key, int value, IntValue<E> next) {
		this.key = key;
		this.value = value;
		this.next = next;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\IntValueCache.java

package com.troy.empireserialization.cache;

public class IntValueCache<E> extends ObjectKeyCache<IntValue<E>, E> {

	public IntValueCache() {
		this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
	}

	public IntValueCache(int initalCapacity) {
		this(initalCapacity, DEFAULT_LOAD_FACTOR);
	}

	public IntValueCache(int initalCapacity, double loadFactor) {
		super(initalCapacity, loadFactor);

	}

	public void add(E key, int value) {
		if ((double) size >= loadFactor * table.length) {
			resize(size * 2);
		}
		int index = hash(key);
		IntValue<E> se = new IntValue<E>(key, value, null);
		if (table[index] == null) {
			table[index] = se;
		} else {
			IntValue<E> entry = table[index];
			while (entry.next != null) {
				if (entry.key.equals(key))
					return;
				entry = entry.next;
			}
			if (entry.key.equals(key))
				return;
			entry.next = se;
		}
		size++;
	}

	public IntValue<E> get(E key) {
		// Get a positive index using mod
		int index = hash(key);
		IntValue<E> entry = table[index];
		if (entry != null) {
			while (entry.next != null) {
				if (entry.key.equals(key))
					return entry;
				entry = entry.next;
			}
		}
		if (entry == null)
			return null;
		if (entry.key.equals(key))
			return entry;
		return null;
	}

	protected void resize(int newSize) {
		IntValue<E>[] oldTable = table;
		this.table = new IntValue[newSize];
		if (oldTable != null) {
			for (int i = 0; i < oldTable.length; i++) {
				IntValue<E> entry = oldTable[i];
				while (entry != null) {
					add(entry.key, entry.value);
					entry = entry.next;
				}
			}
		}
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\cache\ObjectKeyCache.java

package com.troy.empireserialization.cache;

public abstract class ObjectKeyCache<Entry, Key> extends Cache<Entry> {

	public ObjectKeyCache(int initalCapacity, double loadFactor) {
		super(initalCapacity, loadFactor);
	}
	
	public abstract Entry get(Key key);

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\charset\EmpireCharset.java

package com.troy.empireserialization.charset;

import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.NativeUtils;

public interface EmpireCharset {
	/**
	 * Decodes bytes from a source byte array to a char array
	 * 
	 * @param src
	 *            The source of encoded bytes to draw from
	 * @param dest
	 *            The resulting array to write to
	 * @param srcOffset
	 *            The offset on where to start writing to into dest
	 * @param chars
	 *            The number of characters to decode
	 * @return The number of bytes read from src
	 */
	public default long decode(Input src, final char[] dest, int srcOffset, final int chars) {
		if (NativeUtils.NATIVES_ENABLED && chars > NativeUtils.MIN_NATIVE_THRESHOLD) {
			long size = (long) Math.ceil((float) chars / getMinCharactersPerByte());
			NativeMemoryBlock block = src.map(size);
			long bytesEncoded = nDecodeImpl(dest, src, srcOffset, chars);
			block.setPosition(bytesEncoded);
			src.unmap(block);
			return bytesEncoded;
		} else {
			return decodeImpl(dest, src, srcOffset, chars);
		}
	}

	/**
	 * Encodes bytes from a char array into an output
	 * 
	 * @param src
	 *            The source of characters to draw from
	 * @param dest
	 *            The destination to write to
	 * @param srcOffset
	 *            The offset to start reading from in the source array
	 * @param chars
	 *            The number of characters to encode
	 * @return The number of bytes written to dest
	 */
	public default long encode(final char[] src, Output dest, int srcOffset, final int chars, int info) {
		if (NativeUtils.NATIVES_ENABLED && chars > NativeUtils.MIN_NATIVE_THRESHOLD) {
			long size = (long) (chars / getMinCharactersPerByte() + 1);
			dest.require(size);
			NativeMemoryBlock block = dest.map(size);
			int bytesEncoded = nEncodeImpl(src, block.address(), srcOffset, chars, info);
			block.setPosition(bytesEncoded);
			dest.unmap(block);
			return bytesEncoded;
		} else {
			return encodeImpl(src, dest, srcOffset, chars, info);
		}
	}

	/**
	 * Encodes a subset of the given character array to the desired output
	 * 
	 * @see #encode(char[], Output, int, int)
	 */
	public long encodeImpl(final char[] src, Output dest, int srcOffset, final int chars, int info);

	/**
	 * Decodes the given number of input chars and stores them starting at index offset in dest
	 * 
	 * @see #encode(char[], Output, int, int)
	 */
	public long decodeImpl(final char[] dest, Input src, int srcOffset, final int chars);

	/**
	 * Decodes the given number of input chars and stores them starting at index offset in dest 
	 * using a native method for speed
	 * 
	 * @see #encode(char[], Output, int, int)
	 */
	public long nDecodeImpl(final char[] dest, Input src, int srcOffset, final int chars);

	/**
	 * Encodes a subset of the given character array to the desired output using a
	 * native alternative
	 * 
	 * @see #encode(char[], Output, int, int)
	 */
	public abstract int nEncodeImpl(char[] src, long dest, int srcOffset, int chars, int info);

	public char[] getDecodingCache();

	public int[] getEncodingCache();

	public float getMinCharactersPerByte();

	/*
	 * public int encodeNative(final char[] src, Output dest, int srcOffset, final
	 * int chars, boolean checkForErrors) { NativeM
	 * 
	 * return 0; }
	 */

	public byte getOpCode();

	default public float getBytesPerCharacter() {
		return 1.0f / getMinCharactersPerByte();
	}

	public int getCharsetCode();

	public String name();
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\charset\EmpireCharsets.java

package com.troy.empireserialization.charset;

import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.util.*;

public class EmpireCharsets {
	public static final FourBitCharset FOUR_BIT_CHARSET = new FourBitCharset();
	public static final SixBitCharset SIX_BIT_CHARSET = new SixBitCharset();
	public static final VLE8Charset VLE8_CHARSET = new VLE8Charset();

	public static void init() {
	}

	/**
	 * Returns a charset capable of encoding the specified string
	 * 
	 * @param str
	 *            The string to use when identifying an appropriate charset
	 * @return A set of information containing a charset capable of encoding the
	 *         specified string and some general info
	 */
	public static StringInfo identifyCharset(String str, int offset, int length) {
		char[] chars = MiscUtil.getCharsFast(str);
		return identifyCharset(chars, offset, length);
	}

	public static StringInfo identifyCharset(char[] chars, int offset, int length) {
		if (true)
			return new StringInfo(VLE8_CHARSET, StringInfo.ALL_ASCII);
		if (NativeUtils.NATIVES_ENABLED) {
			int result = nIdentifyCharset(chars, offset, length);
			int value = result & 0b11;
			int info = (result >>> 2) & 0b11;
			StringInfo r = new StringInfo(info);

			if (value == FourBitCharset.CODE)
				r.charset = FOUR_BIT_CHARSET;
			else if (value == SixBitCharset.CODE)
				r.charset = SIX_BIT_CHARSET;
			else
				r.charset = VLE8_CHARSET;
			return r;
		} else {
			boolean fourOK = true;
			boolean sixOK = true;
			final int end = length + offset;
			int[] fourEncoding = FourBitCharset.ENCODING_CACHE;
			int[] sixEncoding = SixBitCharset.ENCODING_CACHE;
			boolean allASCII = true;
			for (int i = offset; i < end; i++) {
				char c = chars[i];
				if (allASCII && (c >>> 7) != 0)
					allASCII = false;
				if (fourOK && (c > fourEncoding.length || fourEncoding[c] == -1)) {
					fourOK = false;
					// System.out.println("four failed on character: " +c + " ("+((int)c)+")line " +
					// line);
				}
				if (sixOK && (c > sixEncoding.length || sixEncoding[c] == -1)) {
					sixOK = false;
					// System.out.println("six failed on character: " +c + " ("+((int)c)+")line " +
					// line);
				}
				if (!fourOK && !sixOK && !allASCII) {
					break;
				}
			}

			StringInfo r = new StringInfo(allASCII ? StringInfo.ALL_ASCII : StringInfo.OTHER);

			if (fourOK)
				r.charset = FOUR_BIT_CHARSET;
			else if (sixOK)
				r.charset = SIX_BIT_CHARSET;
			else
				r.charset = VLE8_CHARSET;
			return r;
		}
	}

	private static native int nIdentifyCharset(char[] chars, int offset, int length);

	public static void write(String str, Output out) {
		char[] chars = MiscUtil.getCharsFast(str);
		write(chars, 0, chars.length, out);
	}

	public static void write(char[] chars, Output out) {
		write(chars, 0, chars.length, out);
	}

	public static void write(char[] chars, int offset, int len, Output out) {
		StringInfo info = identifyCharset(chars, offset, len);
		info.charset.encode(chars, out, offset, len, info.info);
	}

	public static EmpireCharset get(int charset) {
		if (charset == FOUR_BIT_CHARSET.getCharsetCode())
			return FOUR_BIT_CHARSET;
		if (charset == SIX_BIT_CHARSET.getCharsetCode())
			return SIX_BIT_CHARSET;
		if (charset == VLE8_CHARSET.getCharsetCode())
			return VLE8_CHARSET;
		throw new IllegalArgumentException("Invalid charset code " + charset);
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\charset\FourBitCharset.java

package com.troy.empireserialization.charset;

import com.troy.empireserialization.io.in.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.util.*;

public final class FourBitCharset implements EmpireCharset {
	static {
		NativeUtils.init();
	}

	public static final byte CODE = 0b00;
	public static final int MASK = 0b00001111;
	public static final int MIN_VALUE = 0, MAX_VALUE = 15;
	// maps a four bit code -> java char value
	public static final char[] DECODING_CACHE = new char[] { 'e', 't', 'a', 'o', 'i', 'n', 's', 'h', 'r', 'd', 'l', 'c', 'u', 'm', 'w', 'f' };
	// maps a java char -> four bit code
	public static final int[] ENCODING_CACHE = SerializationUtils.constructEncodingFromDecoding(DECODING_CACHE);

	public native int nEncodeImpl(char[] src, long dest, int srcOffset, int chars, int info);

	@Override
	public long decode(Input src, char[] dest, int destOffset, final int chars) {
		boolean shift = true;
		final int end = destOffset + chars;
		byte b = 0;
		long count = 0;
		while (destOffset < end) {
			if (shift) {
				b = src.readByte();
				count++;
				dest[destOffset++] = DECODING_CACHE[b >>> 4];
			} else {
				dest[destOffset++] = DECODING_CACHE[b & MASK];
			}
			shift = !shift;
		}
		return count;
	}

	@Override
	public long encodeImpl(final char[] src, Output dest, final int srcOffset, final int chars, int info) {
		int i = srcOffset;
		final int end = (chars / 2) * 2;// round down to next multiple of two
		long count = 0;
		while (i < end) {
			char c = src[i++];
			char d = src[i++];
			dest.writeByte((byte) ((ENCODING_CACHE[c] << 4) | ENCODING_CACHE[d]));
			count++;
		}

		if (chars % 2 != 0) {// Write the remaining byte if there was an odd number
			dest.writeByte((byte) (ENCODING_CACHE[src[end]] << 4));
			count++;
		}
		return count;
	}

	@Override
	public float getMinCharactersPerByte() {
		return 2.0f;
	}

	@Override
	public int getCharsetCode() {
		return CODE;
	}

	@Override
	public String name() {
		return "4Bit-Encoding";
	}

	@Override
	public byte getOpCode() {
		return 0b00;
	}

	@Override
	public char[] getDecodingCache() {
		return DECODING_CACHE;
	}

	@Override
	public int[] getEncodingCache() {
		return ENCODING_CACHE;
	}

	@Override
	public long decodeImpl(char[] dest, Input src, int srcOffset, int chars) {

		return 0;
	}

	public native long nDecodeImpl(char[] dest, Input src, int srcOffset, int chars);

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\charset\SixBitCharset.java

package com.troy.empireserialization.charset;

import com.troy.empireserialization.io.in.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.util.*;

public class SixBitCharset implements EmpireCharset {
	static {
		NativeUtils.init();
	}
	public static final byte CODE = 0b01;
	public static final int MIN_VALUE = 0, MAX_VALUE = 63;
	private static final int MASK = 0b00111111;
	// maps a four bit code -> java char value
	// format:off
	public static final char[] DECODING_CACHE = new char[] { ' ', '.', '!', '?', ',', '\'', '\"', ';', ':', '\n', '-', '_', 'a', 'b', 'c', 'd', 'e',
			'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',
			'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', };
	// format:on

	// maps a java char -> four bit code
	public static final int[] ENCODING_CACHE = SerializationUtils.constructEncodingFromDecoding(DECODING_CACHE);

	@Override
	public native long nDecodeImpl(char[] dest, Input src, int srcOffset, int chars);

	@Override
	public long decodeImpl(final char[] dest, Input src, int srcOffset, final int chars) {
		int result;
		final int end = (chars / 3) * 3;// round down to next multiple of two
		long count = 0;
		while (count < end) {
			result = (src.readByte() << 16) | (src.readByte() << 8) | src.readByte();
			System.out.println(StringFormatter.toHexString(result));
			int c0 = (result >> 18) & 0b111111;
			int c1 = (result >> 12) & 0b111111;
			int c2 = (result >> 6) & 0b111111;
			int c3 = (result >> 0) & 0b111111;
			dest[srcOffset++] = DECODING_CACHE[c0];
			dest[srcOffset++] = DECODING_CACHE[c1];
			dest[srcOffset++] = DECODING_CACHE[c2];
			dest[srcOffset++] = DECODING_CACHE[c3];
			count += 3;
		}
		if (chars % 4 == 3) {// Write the remaining byte if there was an odd number
			result = src.readByte() << 16 | src.readByte() << 8 | src.readByte();
			int c1 = (result >> 12) & 0b111111;
			int c2 = (result >> 6) & 0b111111;
			int c3 = (result >> 0) & 0b111111;
			dest[srcOffset++] = DECODING_CACHE[c1];
			dest[srcOffset++] = DECODING_CACHE[c2];
			dest[srcOffset++] = DECODING_CACHE[c3];
			count += 3;
		} else if (chars % 4 == 2) {// Write the remaining byte if there was an odd number
			result = src.readByte() << 8 | src.readByte();
			int c2 = (result >> 6) & 0b111111;
			int c3 = (result >> 0) & 0b111111;
			dest[srcOffset++] = DECODING_CACHE[c2];
			dest[srcOffset++] = DECODING_CACHE[c3];
			count += 2;
		} else if (chars % 4 == 1) {// Write the remaining byte if there was an odd number
			dest[srcOffset++] = DECODING_CACHE[src.readByte()];
			count += 1;
		}
		return count;
	}

	public native int nEncodeImpl(char[] src, long dest, int srcOffset, int chars, int info);

	@Override
	public long encodeImpl(char[] src, Output dest, int srcOffset, int chars, int info) {
		int i = srcOffset;
		int result;
		final int end = (chars / 4) * 4;// round down to next multiple of two
		long count = 0;
		while (i < end) {
			int c0 = ENCODING_CACHE[src[i++]];
			int c1 = ENCODING_CACHE[src[i++]];
			int c2 = ENCODING_CACHE[src[i++]];
			int c3 = ENCODING_CACHE[src[i++]];
			result = c3;
			result |= c2 << 6;
			result |= c1 << 12;
			result |= c0 << 18;

			dest.writeByte((byte) ((result >> 16) & 0xFF));
			dest.writeByte((byte) ((result >> 8) & 0xFF));
			dest.writeByte((byte) ((result >> 0) & 0xFF));
			count += 3;
		}
		if (chars % 4 == 3) {// Write the remaining byte if there was an odd number
			int c0 = ENCODING_CACHE[src[i++]];
			int c1 = ENCODING_CACHE[src[i++]];
			int c2 = ENCODING_CACHE[src[i++]];
			result = 0;
			result |= c2 << 0;
			result |= c1 << 6;
			result |= c0 << 12;

			dest.writeByte((byte) ((result >> 16) & 0xFF));
			dest.writeByte((byte) ((result >> 8) & 0xFF));
			dest.writeByte((byte) ((result >> 0) & 0xFF));
			count += 3;
		} else if (chars % 4 == 2) {// Write the remaining byte if there was an odd number
			int c0 = ENCODING_CACHE[src[i++]];
			int c1 = ENCODING_CACHE[src[i++]];
			result = c1 << 0;
			result |= c0 << 6;

			dest.writeByte((byte) ((result >> 8) & 0xFF));
			dest.writeByte((byte) ((result >> 0) & 0xFF));
			count += 2;
		} else if (chars % 4 == 1) {// Write the remaining byte if there was an odd number
			dest.writeByte((byte) (ENCODING_CACHE[src[end]]));
			count += 1;
		}
		return count;
	}

	@Override
	public float getMinCharactersPerByte() {
		return (4.0f / 3.0f);
	}

	@Override
	public int getCharsetCode() {
		return CODE;
	}

	@Override
	public String name() {

		return "6Bit-Encoding";
	}

	@Override
	public byte getOpCode() {
		return 0b01;
	}

	@Override
	public char[] getDecodingCache() {
		return DECODING_CACHE;
	}

	@Override
	public int[] getEncodingCache() {
		return ENCODING_CACHE;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\charset\VLE8Charset.java

package com.troy.empireserialization.charset;

import com.troy.empireserialization.EmpireConstants;
import com.troy.empireserialization.io.in.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.util.*;

public class VLE8Charset implements EmpireCharset {

	public static final byte CODE = 0b10;
	private static final int INFO_MASK = 0b10000000;
	private static final int DATA_MASK = 0b01111111;

	private static final int HAS_NEXT_BYTE = 0b10000000;
	private static final int DOESNT_HAVE_NEXT_BYTE = 0b00000000;

	// Not used for encoding since java natively uses unicode only for implementing
	// methods
	private static final char[] DECODING_CACHE;
	private static final int[] ENCODING_CACHE;

	static {
		DECODING_CACHE = new char[Character.MAX_VALUE];
		for (int i = 0; i < DECODING_CACHE.length; i++) {
			DECODING_CACHE[i] = (char) i;
		}
		ENCODING_CACHE = SerializationUtils.constructEncodingFromDecoding(DECODING_CACHE);
	}

	public native int nEncodeImpl(char[] src, long dest, int srcOffset, int chars, int info);

	@Override
	public long decode(Input src, char[] dest, int destOffset, int chars) {
		long count = 0;
		final int end = destOffset + chars;
		for (int i = destOffset; i < end; i++) {
			int b = src.readByte();
			count++;
			int result = b & DATA_MASK;
			if ((b & INFO_MASK) == HAS_NEXT_BYTE) {
				b = src.readByte();
				count++;
				result |= (b & DATA_MASK) << 7;
				if ((b & INFO_MASK) == HAS_NEXT_BYTE) {
					b = src.readByte();
					count++;
					result |= (b & DATA_MASK) << 14;
				}
			}
			dest[i] = (char) result;
		}
		return count;
	}

	@Override
	public long encodeImpl(char[] src, Output dest, int srcOffset, int chars, int info) {
		final int end = srcOffset + chars;
		if (info == StringInfo.ALL_ASCII) {
			while (srcOffset < end)
				dest.writeByte(src[srcOffset++]);
			return chars;
		} else {
			long count = 0;
			while (srcOffset < end) {
				char value = src[srcOffset++];
				if (value >>> 7 == 0) {
					dest.writeByte((byte) value);
					count++;
				} else if (value >>> 14 == 0) {
					dest.writeByte((byte) ((value & DATA_MASK) | HAS_NEXT_BYTE));
					dest.writeByte((byte) (value >>> 7));
					count++;
				} else if (value >>> 21 == 0) {
					dest.writeByte((byte) ((value & DATA_MASK) | HAS_NEXT_BYTE));
					dest.writeByte((byte) (value >>> 7 | HAS_NEXT_BYTE));
					dest.writeByte((byte) (value >>> 14));
					count++;
				}
			}
			return count;
		}
	}

	@Override
	public float getMinCharactersPerByte() {
		return 1.0f / 3.0f;
	}

	@Override
	public int getCharsetCode() {
		return CODE;
	}

	@Override
	public String name() {
		return "VLE8";
	}

	@Override
	public byte getOpCode() {
		return CODE;
	}

	@Override
	public char[] getDecodingCache() {
		return DECODING_CACHE;
	}

	@Override
	public int[] getEncodingCache() {
		return ENCODING_CACHE;
	}

	@Override
	public long decodeImpl(char[] dest, Input src, int srcOffset, int chars) {
		int value;
		long count = 0;
		for (int i = 0; i < chars; i++) {
			value = src.readByte();
			count++;
			int result = value & EmpireConstants.VLE_MASK;
			if ((value & EmpireConstants.NEXT_BYTE_VLE) != 0) {
				value = src.readByte();
				count++;
				result |= (value & EmpireConstants.VLE_MASK) << 7;
				if ((value & EmpireConstants.NEXT_BYTE_VLE) != 0) {
					value = src.readByte();
					count++;
					result |= (value & EmpireConstants.VLE_MASK) << 14;
				}
			}
			
			dest[srcOffset++] = (char) (value & 0xFFFF);
		}

		return count;
	}

	@Override
	public native long nDecodeImpl(char[] dest, Input src, int srcOffset, int chars);

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\clazz\ClassData.java

package com.troy.empireserialization.clazz;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;

import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.serializers.FieldType;
import com.troy.empireserialization.util.MiscUtil;

import sun.misc.Unsafe;

public class ClassData<T> {
	private static final Unsafe unsafe = MiscUtil.getUnsafe();

	private final Class<?> type;

	public Field[] rawFields;
	public String[] fieldNames;
	public Class<?>[] fieldTypes;
	public long[] fieldOffsets;
	public FieldType[] myFieldTypes;

	public ClassData(Class<T> type) {
		this(type, SerializationSettings.defaultSettings);
	}

	public ClassData(Class<T> type, SerializationSettings settings) {
		this.type = type;
		init(settings);
	}

	private void init(SerializationSettings settings) {
		Class<?> superType = type.getSuperclass();
		if (type == null) {
		} else {
			Field[] fields = type.getDeclaredFields();
			int fieldsLength = fields.length;
			if (superType == Object.class) {// We are a child of the object class the only fields are in this class
				if (fieldsLength != 0) {
					int fieldCount = 0;
					for (int i = 0; i < fieldsLength; i++) {
						Field field = fields[i];
						if (isValidField(field))
							fieldCount++;
					}
					this.fieldNames = new String[fieldCount];
					this.fieldTypes = new Class[fieldCount];
					this.fieldOffsets = new long[fieldCount];
					this.rawFields = new Field[fieldCount];
					this.myFieldTypes = new FieldType[fieldCount];
					int realIndex = 0;
					for (int i = 0; i < fieldsLength; i++) {
						Field field = fields[i];
						if (isValidField(field))
							addField(field, realIndex++);
					}

				} else {
					// Nop
					// We dont need to do anything because this class has no fields
				}
			} else {// There are other classes between out super and the object class. We must
					// account for fields in superclasses
				ArrayList<Field> fieldsList = new ArrayList<Field>();
				for (int i = 0; i < fieldsLength; i++) {// Dump all into arraylist
					Field field = fields[i];
					if (isValidField(field))
						fieldsList.add(field);
				}
				while (superType != null && superType != Object.class) {
					fields = superType.getDeclaredFields();
					fieldsLength = fields.length;
					for (int i = 0; i < fieldsLength; i++) {// Dump all into arraylist
						Field field = fields[i];
						if (isValidField(field))
							fieldsList.add(field);
					}
					superType = superType.getSuperclass();
				}
				this.fieldNames = new String[fieldsList.size()];
				this.fieldTypes = new Class[fieldsList.size()];
				this.rawFields = new Field[fieldsList.size()];
				this.myFieldTypes = new FieldType[fieldsList.size()];
				if (unsafe != null)
					this.fieldOffsets = new long[fieldsList.size()];

				int i = 0;
				for (Field field : fieldsList) {
					addField(field, i++);
				}
			}
		}
	}

	private boolean isValidField(Field field) {
		int mods = field.getModifiers();
		return !Modifier.isStatic(mods) && !Modifier.isTransient(mods);
	}

	public void writeTypeDefinition(EmpireOutput out) {
		int length = rawFields.length;
		Output impl = out.getImpl();
		out.writeString(type.getSimpleName());
		impl.writeVLEInt(length);
		for (int i = 0; i < length; i++) {
			out.writeTypeComplete(fieldTypes[i]);
			out.writeString(fieldNames[i]);
		}
	}

	private void addField(Field field, int index) {
		field.setAccessible(true);
		rawFields[index] = field;
		fieldNames[index] = field.getName();
		fieldTypes[index] = field.getType();
		myFieldTypes[index] = FieldType.identifyFieldType(field);
		if (unsafe != null)
			fieldOffsets[index] = unsafe.objectFieldOffset(field);
	}

	public Field[] getFields() {
		return rawFields;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\clazz\ClassInfo.java

package com.troy.empireserialization.clazz;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class ClassInfo<T> {
	private Class<T> type;

	protected boolean ignoreTransient;
	protected Field[] ignoreTransientFields;
	
	private static final Field[] EMPTY_FIELD_ARRAY = new Field[0];

	public ClassInfo(Class<T> type, boolean ignoreTransient) {
		this.type = type;
		this.ignoreTransient = ignoreTransient;
		this.ignoreTransientFields = EMPTY_FIELD_ARRAY;
	}

	public ClassInfo(Class<T> type, boolean ignoreTransient, Field[] ignoreTransientFields) {
		this.type = type;
		this.ignoreTransient = ignoreTransient;
		this.ignoreTransientFields = ignoreTransientFields;
		int i = 0;
		for (Field field : ignoreTransientFields) {
			if (!type.isAssignableFrom(field.getDeclaringClass()))
				throw new IllegalArgumentException("Element at index " + i + " is not a member of the class " + type);

			i++;
		}
	}

	public static <T> ClassInfo<T> getFromAnnotations(Class<T> clazz) {
		Annotation[] ann = clazz.getDeclaredAnnotations();
		boolean ignoreTransient = false;
		for (Annotation a : ann) {
			if (a.annotationType() == IgnoreTransient.class) {
				return new ClassInfo<T>(clazz, true);
			}
		}
		Class<? super T> type = clazz;
		List<Field> ignoredFields = new ArrayList<Field>();
		while (type != null) {
			for (Field field : type.getDeclaredFields()) {
				for (Annotation a : field.getDeclaredAnnotations()) {
					if (a.annotationType() == IgnoreTransient.class) {
						ignoredFields.add(field);
					}
				}
			}

			type = type.getSuperclass();
		}
		return new ClassInfo<T>(clazz, false, ignoredFields.toArray(new Field[ignoredFields.size()]));
	}

	public boolean shouldSerialize(Field field) {
		assert type.isAssignableFrom(field.getDeclaringClass());

		if (ignoreTransient)
			return true;
		for (Field loop : ignoreTransientFields) {
			if (field == loop) {
				return true;
			}
		}
		return true;
	}

	public Class<T> getType() {
		return type;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\clazz\IgnoreTransient.java

package com.troy.empireserialization.clazz;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 * Informs the serializer that it should ignore the {@code transient} modifier on a class of field. 
 * If used on a class, the serializer will treat all fields as if they do not have the transient modifier.
 * If used on a field, the serializer will treat only that field as if it is missing the transient modifier. 
 * @author Troy Neubauer
 *
 */

@Retention(RUNTIME)
@Target({ TYPE, FIELD })
public @interface IgnoreTransient {

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\EmpireConstants.java

package com.troy.empireserialization;

public class EmpireConstants {

	public static final String HELLO_WORLD_STRING = "Hello, World!";

	//format:off
	public static final int NEXT_BYTE_VLE 			= 0b10000000;
	public static final int VLE_MASK 				= 0b01111111;
	
	public static final int PRIMITIVE_TYPE 			= 0b0 << 7;
	public static final int USER_DEFINED_TYPE 		= 0b1 << 7;
	
	public static final int GENERAL_TYPE 			= 0b0 << 6;
	public static final int DATA_STRUCTURE_TYPE 	= 0b1 << 6;

	public static final int TYPE_REF_TYPE 			= 0b0 << 6;
	public static final int TYPE_DEF_TYPE 			= 0b1 << 6;
	//format:on

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\EmpireInput.java

package com.troy.empireserialization;

import static com.troy.empireserialization.EmpireConstants.HELLO_WORLD_STRING;
import static com.troy.empireserialization.EmpireOpCodes.*;

import java.io.File;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.troy.empireserialization.cache.IntKeyCache;
import com.troy.empireserialization.cache.IntStringCache;
import com.troy.empireserialization.charset.EmpireCharset;
import com.troy.empireserialization.charset.EmpireCharsets;
import com.troy.empireserialization.exception.MismatchedInputException;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.in.NativeFileInput;
import com.troy.empireserialization.util.MiscUtil;
import com.troy.empireserialization.util.StringFormatter;

public class EmpireInput implements ObjectIn {

	private Input in;

	private IntStringCache stringCache = new IntStringCache(100, 1.0);
	private IntKeyCache<Class<?>> classCache = new IntKeyCache<Class<?>>(100, 1.0);
	private IntKeyCache<Object> objectCache = new IntKeyCache<Object>(200, 1.0);
	private SerializationSettings settings;

	public EmpireInput(Input in) {
		this(in, SerializationSettings.defaultSettings);
	}

	public EmpireInput(File file) {
		this(file, SerializationSettings.defaultSettings);
	}

	public EmpireInput(File file, SerializationSettings settings) {
		this(new NativeFileInput(file), SerializationSettings.defaultSettings);
	}

	public EmpireInput(Input in, SerializationSettings settings) {
		this.in = in;
		this.settings = settings;
	}

	@Override
	public Object readObject() {
		return readObjectImpl();
	}
	
	@Override
	public Object readObjectRecursive() {
		return readObjectImpl();
	}
	
	private Object readObjectImpl() {
		int opcode = in.readByte();
		int majorOpcode = opcode & MAJOR_CODE_MASK;
		int minorOpcode = opcode & MINIOR_CODE_MASK;
		if (majorOpcode == GENERAL_OPCODE_MAJOR_CODE) {
			if (opcode == TYPE_REF_OBJ_DEF_TYPE) {
			} else if (opcode == OBJ_REF_TYPE) {
				return objectCache.get(in.readVLEInt()).value;
			} else if (opcode == TYPE_DEF_OBJ_DEF_TYPE) {

			} else if (opcode == NULL_REF_CONST) {
				return null;
			} else if (opcode == STRING_REF_TYPE) {
				return stringCache.get(in.readVLEInt());
			} else if (opcode == EMPTY_STRING_CONST) {
				return "";// Hope that its not a data structure
			} else if (opcode == HELLO_WORLD_STRING_CONST) {
				return HELLO_WORLD_STRING;
			}
		} else if (majorOpcode == DATA_STRUCTURES_MAJOR_CODE) {
			int opcodeOver4 = minorOpcode / 4;
			if (opcodeOver4 / 4 == PRIMITIVE_ARRAY_TYPE / 4) {
				return readArrayImpl(opcode);
			} else if (opcodeOver4 / 4 == PRIMITIVE_MAP_TYPE / 4) {
				return readMapImpl(opcode);
			}
		} else if (majorOpcode == NUMBER_MAJOR_CODE) {
			return Integer.valueOf(minorOpcode);
		} else if (majorOpcode == STRING_MAJOR_CODE) {
			return readStringImpl(opcode);
		} else {// There should be no other major codes unless something is very wrong
			throw new Error();
		}
		return null;
	}

	private Object[] readArrayImpl(int opcode) {
		if (opcode == PRIMITIVE_ARRAY_TYPE) {

		} else if (opcode == USER_DEFINED_TYPE_DEF_ARRAY_TYPE) {

		} else if (opcode == USER_DEFINED_TYPE_REF_ARRAY_TYPE) {

		} else if (opcode == POLYMORPHIC_ARRAY_TYPE) {

		}
		return null;
	}

	private Map<?, ?> readMapImpl(int opcode) {
		if (opcode == PRIMITIVE_MAP_TYPE) {

		} else if (opcode == USER_DEFINED_TYPE_DEF_MAP_TYPE) {

		} else if (opcode == USER_DEFINED_TYPE_REF_MAP_TYPE) {

		} else if (opcode == POLYMORPHIC_MAP_TYPE) {

		}
		return null;
	}
	
	public String readString() {
		return readStringImpl(in.readByte());
	}

	private String readStringImpl(int opcode) {
		if ((opcode & MAJOR_CODE_MASK) != STRING_MAJOR_CODE) {
			throw new MismatchedInputException("Expected a String major opcode " + StringFormatter.toBinaryString(EmpireOpCodes.STRING_MAJOR_CODE)
					+ " but instead read " + StringFormatter.toBinaryString(opcode & MAJOR_CODE_MASK));
		}
		int charsetCode = (opcode & STRING_CHARSET_MASK) >> 4;
		EmpireCharset charset = EmpireCharsets.get(charsetCode);
		int length = opcode & STRING_LENGTH_MASK;
		if (length == 0) {
			length = in.readVLEInt();
		}
		char[] dest = new char[length];
		charset.decode(in, dest, 0, length);

		return MiscUtil.createString(dest);
	}
/*
	@Override
	public BigInteger readBigInteger() {
		return new BigInteger(in.readBytes(in.readVLEInt()));
	}

	@Override
	public BigDecimal readBigDecimal() {
		BigInteger integer = readBigInteger();
		int scale = in.readVLEInt();
		return new BigDecimal(integer, scale);
	}*/

	@Override
	public void close() {
		in.close();
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\EmpireOpCodes.java

package com.troy.empireserialization;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.troy.empireserialization.util.ClassHelper;

/**
 * 
 * See <a href=
 * "https://docs.google.com/document/d/1hk4uM8_i8ZAb3smQFcM6dKP8REH3ivORBcV8yDvftxo/edit?usp=sharing">https://docs.google.com</a>
 * 
 * @author Troy Neubauer
 */
public class EmpireOpCodes {

	//format:off
	public static final int MAJOR_CODE_MASK 					= 0b11 << 6;
	public static final int MINIOR_CODE_MASK 					= 0b00111111;
	
	public static final int GENERAL_OPCODE_MAJOR_CODE 			= 0b00 << 6;
	public static final int STRING_MAJOR_CODE 					= 0b01 << 6;
	public static final int DATA_STRUCTURES_MAJOR_CODE 			= 0b10 << 6;
	public static final int NUMBER_MAJOR_CODE 					= 0b11 << 6;
	
	public static final int STRING_CHARSET_MASK					= 0b00110000;
	public static final int STRING_LENGTH_MASK					= 0b00001111;
	
	//General minor codes
	public static final int NULL_REF_CONST 						= 0x00 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int FLAGS_TYPE	 						= 0x01 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int TYPE_DEF_OBJ_DEF_TYPE 				= 0x02 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int TYPE_REF_OBJ_DEF_TYPE 				= 0x03 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int OBJ_REF_TYPE 						= 0x04 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int STRING_REF_TYPE 					= 0x05 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int BOOLEAN_FALSE_CONST 				= 0x06 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int BOOLEAN_TRUE_CONST 					= 0x07 | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int STRING_TYPE 						= 0x08 | GENERAL_OPCODE_MAJOR_CODE;
	//9 Unassigned
	public static final int UNSIGNED_BYTE_TYPE 					= 0x0A | GENERAL_OPCODE_MAJOR_CODE;
	public static final int UNSIGNED_SHORT_TYPE 				= 0x0B | GENERAL_OPCODE_MAJOR_CODE;
	public static final int UNSIGNED_INT_TYPE					= 0x0C | GENERAL_OPCODE_MAJOR_CODE;
	public static final int UNSIGNED_LONG_TYPE					= 0x0D | GENERAL_OPCODE_MAJOR_CODE;
	public static final int UNSIGNED_lLONG_TYPE					= 0x0E | GENERAL_OPCODE_MAJOR_CODE;
	public static final int UNSIGNED_llLONG_TYPE				= 0x0F | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int SIGNED_BYTE_TYPE 					= 0x10 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int SIGNED_SHORT_TYPE 					= 0x11 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int SIGNED_INT_TYPE						= 0x12 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int SIGNED_LONG_TYPE					= 0x13 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int SIGNED_lLONG_TYPE					= 0x14 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int SIGNED_llLONG_TYPE					= 0x15 | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int BIG_INTEGER_TYPE					= 0x16 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int BIG_DECIMAL_TYPE					= 0x17 | GENERAL_OPCODE_MAJOR_CODE;
	//18 Unassigned
	public static final int HALF_TYPE							= 0x19 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int FLOAT_TYPE							= 0x1A | GENERAL_OPCODE_MAJOR_CODE;
	public static final int DOUBLE_TYPE							= 0x1B | GENERAL_OPCODE_MAJOR_CODE;
	public static final int QUADRUPLE_TYPE						= 0x1C | GENERAL_OPCODE_MAJOR_CODE;
	public static final int OCTUPLE_TYPE						= 0x1D | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int HELLO_WORLD_STRING_CONST 			= 0x1E | GENERAL_OPCODE_MAJOR_CODE;
	public static final int EMPTY_STRING_CONST		 			= 0x1F | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int VLE_UNSIGNED_SHORT_TYPE 			= 0x20 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int VLE_UNSIGNED_INT_TYPE 				= 0x21 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int VLE_UNSIGNED_LONG_TYPE 				= 0x22 | GENERAL_OPCODE_MAJOR_CODE;
	
	public static final int VLE_SIGNED_SHORT_TYPE 				= 0x23 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int VLE_SIGNED_INT_TYPE 				= 0x24 | GENERAL_OPCODE_MAJOR_CODE;
	public static final int VLE_SIGNED_LONG_TYPE 				= 0x25 | GENERAL_OPCODE_MAJOR_CODE;
	
	//Data Structures
	
	public static final int PRIMITIVE_ARRAY_TYPE		 		= 0x00 | DATA_STRUCTURES_MAJOR_CODE;
	public static final int USER_DEFINED_TYPE_DEF_ARRAY_TYPE	= 0x01 | DATA_STRUCTURES_MAJOR_CODE;
	public static final int USER_DEFINED_TYPE_REF_ARRAY_TYPE	= 0x02 | DATA_STRUCTURES_MAJOR_CODE;
	public static final int POLYMORPHIC_ARRAY_TYPE				= 0x03 | DATA_STRUCTURES_MAJOR_CODE;
	
	public static final int PRIMITIVE_MAP_TYPE		 			= 0x08 | DATA_STRUCTURES_MAJOR_CODE;
	public static final int USER_DEFINED_TYPE_DEF_MAP_TYPE		= 0x09 | DATA_STRUCTURES_MAJOR_CODE;
	public static final int USER_DEFINED_TYPE_REF_MAP_TYPE		= 0x0A | DATA_STRUCTURES_MAJOR_CODE;
	public static final int POLYMORPHIC_MAP_TYPE				= 0x0B | DATA_STRUCTURES_MAJOR_CODE;
	
	
	
	//format:on
	public static final HashMap<Class<?>, Integer> PRIMITIVE_TYPE_MAPPING;
	public static final HashMap<Class<?>, Integer> PRIMITIVE_TYPE_VLE_MAPPING;

	static {
		PRIMITIVE_TYPE_MAPPING = new HashMap<Class<?>, Integer>();
		PRIMITIVE_TYPE_MAPPING.put(boolean.class, UNSIGNED_BYTE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(byte.class, SIGNED_BYTE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(short.class, SIGNED_SHORT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(int.class, SIGNED_INT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(long.class, SIGNED_LONG_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(float.class, FLOAT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(double.class, DOUBLE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(char.class, UNSIGNED_SHORT_TYPE);

		PRIMITIVE_TYPE_MAPPING.put(Boolean.class, UNSIGNED_BYTE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Byte.class, SIGNED_BYTE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Short.class, SIGNED_SHORT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Integer.class, SIGNED_INT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Long.class, SIGNED_LONG_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Float.class, FLOAT_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Double.class, DOUBLE_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Character.class, SIGNED_SHORT_TYPE);

		PRIMITIVE_TYPE_MAPPING.put(boolean[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(byte[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(short[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(int[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(long[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(float[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(double[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(char[].class, PRIMITIVE_ARRAY_TYPE);

		PRIMITIVE_TYPE_MAPPING.put(Boolean[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Byte[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Short[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Integer[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Long[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Float[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Double[].class, PRIMITIVE_ARRAY_TYPE);
		PRIMITIVE_TYPE_MAPPING.put(Character[].class, PRIMITIVE_ARRAY_TYPE);

		PRIMITIVE_TYPE_MAPPING.put(String.class, STRING_TYPE);

		PRIMITIVE_TYPE_VLE_MAPPING = new HashMap<Class<?>, Integer>(PRIMITIVE_TYPE_MAPPING);

		PRIMITIVE_TYPE_VLE_MAPPING.put(short.class, VLE_SIGNED_SHORT_TYPE);
		PRIMITIVE_TYPE_VLE_MAPPING.put(int.class, VLE_SIGNED_INT_TYPE);
		PRIMITIVE_TYPE_VLE_MAPPING.put(long.class, VLE_SIGNED_LONG_TYPE);
		PRIMITIVE_TYPE_VLE_MAPPING.put(Short.class, VLE_SIGNED_SHORT_TYPE);
		PRIMITIVE_TYPE_VLE_MAPPING.put(Integer.class, VLE_SIGNED_INT_TYPE);
		PRIMITIVE_TYPE_VLE_MAPPING.put(Long.class, VLE_SIGNED_LONG_TYPE);

	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\EmpireOutput.java

package com.troy.empireserialization;

import static com.troy.empireserialization.EmpireOpCodes.*;

import java.io.File;
import java.nio.ByteOrder;
import java.util.List;
import java.util.Map;

import com.troy.empireserialization.cache.IntValue;
import com.troy.empireserialization.cache.IntValueCache;
import com.troy.empireserialization.charset.EmpireCharset;
import com.troy.empireserialization.charset.EmpireCharsets;
import com.troy.empireserialization.io.out.NativeFileOutput;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.serializers.Serializers;
import com.troy.empireserialization.util.ClassHelper;
import com.troy.empireserialization.util.MiscUtil;
import com.troy.empireserialization.util.StringInfo;

public class EmpireOutput implements ObjectOut {

	private Output out;
	private IntValueCache<String> stringCache = new IntValueCache<String>(100, 1.0);
	private IntValueCache<Class<?>> classCache = new IntValueCache<Class<?>>(100, 1.0);
	private IntValueCache<Object> objectCache = new IntValueCache<Object>(200, 1.0);
	private SerializationSettings settings;

	public EmpireOutput(File file) {
		this(new NativeFileOutput(file), SerializationSettings.defaultSettings);
	}

	public EmpireOutput(File file, SerializationSettings settings) {
		this(new NativeFileOutput(file), settings);
	}

	public EmpireOutput(Output out) {
		this(out, SerializationSettings.defaultSettings);
	}

	public EmpireOutput(Output out, SerializationSettings settings) {
		this.out = out;
		setSettings(settings);
	}

	/**
	 * Sets the settings to use and writes them out if nessarry. Subclasses should
	 * override this method if plugins are present or for any other reason in which
	 * certain settings must be specific values.
	 * 
	 * @param newSettings
	 */
	protected void setSettings(SerializationSettings newSettings) {
		SerializationSettings oldSettings = this.settings;
		this.settings = newSettings;
		if ((oldSettings == null && newSettings.getFlagsData() != 0)
				|| (oldSettings != null && (newSettings.getFlagsData() != oldSettings.getFlagsData()))) {
			out.setByteOrder(settings.useLittleEndian ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
			writeFlags();
		}
	}

	private void writeFlags() {
		out.writeByte(EmpireOpCodes.FLAGS_TYPE);
		out.writeByte(settings.getFlagsData());
	}

	public <T> void writeObjectImpl(T obj, boolean writeHeader, long extra) {
		if (obj == null) {
			out.writeByte(EmpireOpCodes.NULL_REF_CONST);
			return;
		}
		Class<T> type = (Class<T>) obj.getClass();
		if (ClassHelper.isPrimitive(type)) {
			writeObjectDefinition(obj, type, writeHeader, false, extra);
		} else {
			IntValue<Class<?>> classEntry = classCache.get(type);
			if (classEntry == null) {// Determine if the class hasn't been written before
				// We need to define the class and object
				out.writeByte(TYPE_DEF_OBJ_DEF_TYPE);
				writeTypeDefinition(type);
				writeObjectDefinition(obj, type, writeHeader, true, extra);
			} else {// The class has been written before - we either need to define the fields, or
					// reference the previously
					// written object
				IntValue<Object> objEntry = null;
				if (settings.useObjectCache) {
					objEntry = objectCache.get(obj);
				}
				if (objEntry == null) {// We need to define the object but not the type
					if (settings.useObjectCache)
						registerObject(obj);

					out.writeByte(TYPE_REF_OBJ_DEF_TYPE);
					// Write the type's id
					out.writeVLEInt(classEntry.value);
					writeObjectDefinition(obj, type, writeHeader, true, extra);
				} else {// The object already exists so just reference it
					out.writeByte(OBJ_REF_TYPE);
					// Write only the object's id
					out.writeVLEInt(objEntry.value);
				}
			}
		}
	}

	public <T> void writeObject(T obj) {
		writeObjectImpl(obj, true, -1L);
	}

	@Override
	public <T> void writeObjectRecursive(T obj, long extra) {
		writeObjectImpl(obj, false, extra);
	}

	private <T> void writeObjectDefinition(T obj, Class<T> type, boolean writeHeader, boolean registerObject, long extra) {
		if(registerObject) registerObject(obj);
		Serializers.getSerializer(type, this).write(this, (T) obj, out, writeHeader, settings, extra);
	}

	private void registerClass(Class<?> type) {
		if (classCache.get(type) != null)
			throw new IllegalArgumentException(type + " already exists in the class cache!");
		classCache.add(type, classCache.size());
	}

	private void registerObject(Object obj) {
		objectCache.add(obj, objectCache.size());
	}

	private void registerString(String str) {
		stringCache.add(str, stringCache.size());
	}

	public void writeTypeReference(IntValue<Class<?>> entry) {
		out.writeVLEInt(entry.value);
	}

	public void writeTypeDefinition(Class<?> type) {
		if (classCache.get(type) != null)
			throw new IllegalArgumentException();
		registerClass(type);
		Serializers.getSerializer(type, this).writeTypeDefinition(this);
	}

	public void writeString(String str) {
		if (str.equals(EmpireConstants.HELLO_WORLD_STRING)) {
			out.writeByte(HELLO_WORLD_STRING_CONST);
		} else {
			int len = str.length();
			if (len == 0) {
				out.writeByte(EMPTY_STRING_CONST);
			} else {
				IntValue<String> cached = null;
				if (settings.useStringCache)
					cached = stringCache.get(str);
				if (cached != null) {
					out.writeByte(STRING_REF_TYPE);
					out.writeVLEInt(cached.value);
				} else {
					if (settings.useStringCache)
						registerString(str);
					StringInfo info = EmpireCharsets.identifyCharset(str, 0, str.length());
					EmpireCharset charset = info.charset;
					int opCode = STRING_MAJOR_CODE;
					opCode |= (charset.getCharsetCode() & 0b11) << 4;
					boolean lengthFitsIntoOpCode = len < (1 << 4);
					if (lengthFitsIntoOpCode) {
						opCode |= len;
					} else {
						opCode |= 0b0000;
					}
					out.writeByte(opCode);
					if (!lengthFitsIntoOpCode) {
						out.writeVLEInt(len);
					}
					charset.encode(MiscUtil.getCharsFast(str), out, 0, len, info.info);
				}
			}
		}
	}

	/**
	 * Writes a full type descriptor for all types, primitive, user defined, writes
	 * a full type definition for a non primitive type if necessary
	 * 
	 * @param elementType
	 */
	public void writeTypeComplete(Class<?> type) {
		int opcode;
		if (type == null) {
			throw new NullPointerException();
		} else if (ClassHelper.isPrimitive(type)) {
			opcode = EmpireConstants.PRIMITIVE_TYPE;
			if (ClassHelper.isDataStructure(type)) {
				opcode |= EmpireConstants.DATA_STRUCTURE_TYPE;
			} else {
				opcode |= EmpireConstants.GENERAL_TYPE;
			}
			if (Map.class.isAssignableFrom(type)) {// Put in the correct opcode for the primitive
				opcode |= (EmpireOpCodes.POLYMORPHIC_MAP_TYPE & EmpireOpCodes.MINIOR_CODE_MASK);
			} else if (type.isArray() || List.class.isAssignableFrom(type)) {
				opcode |= (EmpireOpCodes.POLYMORPHIC_ARRAY_TYPE & EmpireOpCodes.MINIOR_CODE_MASK);
			} else {// Non data structure primitive type
				if (settings.useVLE) {
					opcode |= (PRIMITIVE_TYPE_VLE_MAPPING.get(type) & EmpireOpCodes.MINIOR_CODE_MASK);
				} else {
					opcode |= (PRIMITIVE_TYPE_MAPPING.get(type) & EmpireOpCodes.MINIOR_CODE_MASK);
				}
			}
			out.writeByte(opcode);
		} else {
			opcode = EmpireConstants.USER_DEFINED_TYPE;
			IntValue<Class<?>> entry = classCache.get(type);
			boolean idFitsInOpCode = true;
			int typeID = -1;
			if (entry == null) {// Type def
				opcode |= EmpireConstants.TYPE_DEF_TYPE;
			} else {// Type ref
				opcode |= EmpireConstants.TYPE_REF_TYPE;
				typeID = entry.value;
				idFitsInOpCode = typeID < EmpireConstants.TYPE_DEF_TYPE;
				if (idFitsInOpCode) {
					opcode |= typeID;
				} else {
					opcode |= 0b000000;// Zero indicates that we will encode the Id after the opcode using VLE
				}
			}
			out.writeByte(opcode);
			if (entry == null) {// We have a type definition
				writeTypeDefinition(type);
			} else {// If we are using a type reference
				if (!idFitsInOpCode) {
					out.writeVLEInt(typeID);
				}
			}
		}
	}

	@Override
	public void close() {
		out.close();
	}

	@Override
	public void flush() {
		out.flush();
	}

	public Output getImpl() {
		return out;
	}

	public IntValueCache<Object> getObjectCache() {
		return objectCache;
	}

	public IntValueCache<Class<?>> getClassCache() {
		return classCache;
	}

	public IntValueCache<String> getStringCache() {
		return stringCache;
	}
	
	public SerializationSettings getSettings() {
		return settings;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\AlreadyClosedException.java

package com.troy.empireserialization.exception;

/**
 * Signals that some closable source or destination has already been closed and is unusable
 * 
 * @author Troy Neubauer
 *
 */
public class AlreadyClosedException extends RuntimeException {

	public AlreadyClosedException() {
		super();
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\AlreadyMappedException.java

package com.troy.empireserialization.exception;

/**
 * Thrown when a buffer attempts to map itself, but cannot because the caller has not unmapped it.
 * @author Troy Neubauer
 *
 */
public class AlreadyMappedException extends RuntimeException {
	public AlreadyMappedException(String message) {
		super(message);
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\EmpireSerializationIOException.java

package com.troy.empireserialization.exception;

/**
 * Thrown to indicate that an IO exception occurred internally. Unlike {@link java.io.IOException}, 
 * {@link EmpireSerializationIOException} is an unchecked exception, meaning that callers of a method that throws
 * an {@link EmpireSerializationIOException} do not need to surround such call with a try and catch block. Although try
 * and catch should be used in production code, the unchecked nature of this class allows for writing significantly
 * cleaner test code. 
 * @author Troy Neubauer
 *
 */
public class EmpireSerializationIOException extends RuntimeException {

	public EmpireSerializationIOException() {
		super();
	}

	public EmpireSerializationIOException(String message, Throwable cause) {
		super(message, cause);
	}

	public EmpireSerializationIOException(String message) {
		super(message);
	}

	public EmpireSerializationIOException(Throwable cause) {
		super(cause);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\EndOfInputException.java

package com.troy.empireserialization.exception;

/**
 * Signals that the end of some input has occurred
 * 
 * @author Troy Neubauer
 *
 */
public class EndOfInputException extends RuntimeException {

	public EndOfInputException() {
		super();
	}

	public EndOfInputException(String message, Throwable cause) {
		super(message, cause);
	}

	public EndOfInputException(String message) {
		super(message);
	}

	public EndOfInputException(Throwable cause) {
		super(cause);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\MismatchedInputException.java

package com.troy.empireserialization.exception;

import com.troy.empireserialization.io.in.Input;

/**
 * Thrown when an {@link Input} expects one type but detects another. 
 * @author Troy Neubauer
 *
 */
public class MismatchedInputException extends RuntimeException {

	public MismatchedInputException() {
		super();
	}
	public MismatchedInputException(String message, Throwable cause) {
		super(message, cause);
	}

	public MismatchedInputException(String message) {
		super(message);
	}

	public MismatchedInputException(Throwable cause) {
		super(cause);
	}
	
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\NoBufferException.java

package com.troy.empireserialization.exception;

/**
 * Indicates that some IO object has no internal buffer to obtain
 * @author Troy Neubauer
 *
 */
public class NoBufferException extends RuntimeException {

	public NoBufferException() {
		super();
	}

	public NoBufferException(String message, Throwable cause) {
		super(message, cause);
	}

	public NoBufferException(String message) {
		super(message);
	}

	public NoBufferException(Throwable cause) {
		super(cause);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\exception\UnsupportedCharacterException.java

package com.troy.empireserialization.exception;

import com.troy.empireserialization.charset.*;

/**
 * Signals that a character is unsupported by a specific charset and that the charset unable to encode the string into bytes
 * @author Troy Neubauer
 *
 */
public class UnsupportedCharacterException extends RuntimeException {

	public UnsupportedCharacterException(char c, int index, EmpireCharset charset) {
		super("Invalid character \'" + c + "\' at index " + index + " for charset " + charset.name());
	}

	public UnsupportedCharacterException(char c, EmpireCharset charset) {
		super("Invalid character \'" + c + "\' for charset " + charset.name());
	}

	public UnsupportedCharacterException(EmpireCharset charset) {
		super("Invalid character for charset " + charset.name());
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\EmpireIO.java

package com.troy.empireserialization.io;

import java.io.*;
import java.nio.*;

import com.troy.empireserialization.*;
import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.memory.NativeMemoryBlock;

/**
 * The super interface for all streams that read or write primitives. This class provides an abstraction for
 * reading/writing all primitive types, byte arrays, and variable length encoded numbers. The size in bytes of basic
 * primitives is equal to their native java size (byte=1, short=2, char=2, int=4, float=4, long=8, double=8). A boolean
 * on its own is one byte where a value of zero indicates false, and any other value indicates true.
 * 
 * <p>
 * <h2>Variable Length Encoding</h2>
 * Variable length encoding is the practice of encoding numbers using a variable amount bytes to ideally achieve 
 * a smaller end size, compared to native, fixed size encoding. Although this may cause larger numbers to be encoded 
 * using more bytes, numbers less than 128 and greater than -1 will be encoded using one byte as opposed to 1, 2, 4, or 8 bytes.
 * Variable length encoding works be using the most significant bit of each byte as a marker for identifying when a particular
 * Primitive ends. A byte with the most significant bit (MSB) set to one tells the deserializer that the next byte is also a part of
 * the next primitive. A MSB of zero tells the deserializer that the current primitive ends. 
 * 
 * @author Troy Neubauer
 *
 */
public interface EmpireIO extends Closeable {

	/**
	 * @return {@code true} if this IO has a java based byte array to buffer data, {@code false} otherwise. <br>
	 *         This method should be used to verify that a buffer is present before calling methods that require a
	 *         buffer like {@link #getBufferPosition()} and {@link #getBuffer()}
	 */
	public boolean hasBuffer();

	/**
	 * Returns the current offset used with the internal buffer. If no buffer is present, a {@link NoBufferException}
	 * will be thrown.
	 * 
	 * @return The offset in bytes if the buffer buffer is present
	 * @throws NoBufferException
	 *             If the implemenentation of this IO does not buffered by a java byte array
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 * @see #hasBuffer()
	 */
	public int getBufferPosition();
	
	/**
	 * Sets the current offset used with the internal buffer. If no buffer is present, a {@link NoBufferException}
	 * will be thrown.
	 * 
	 * @throws NoBufferException
	 *             If the implemenentation of this IO does not buffered by a java byte array
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 * @see #hasBuffer()
	 */
	public void setBufferPosition(int newPosition);

	/**
	 * Returns the byte array backing this IO. If no buffer is present, a {@link NoBufferException} will be thrown.
	 * 
	 * @return The buffer used by this IO
	 * @throws NoBufferException
	 *             If the implemenentation of this IO does not buffered by a java byte array
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 * 
	 * @see #hasBuffer()
	 */
	public byte[] getBuffer();

	/**
	 * Ensures that a certain amount of bytes can be written to or read from this IO. If this IO is an output with a
	 * buffer, this method ensures that there is enough space to store x amount of bytes after the current position
	 * before overflowing the buffer. If this IO is an input, this method will block until x bytes are available, or
	 * throw an {@link EndOfInputException} the end of stream is reached before x bytes are available.
	 * 
	 * @param bytes
	 *            The number of bytes to require this IO to have
	 * @throws EndOfInputException
	 *             If this IO is an input end the of stream is reached before x bytes are available
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 */
	public void require(long bytes);

	/**
	 * Increments the internal pointer used for buffering data by the number of bytes specified in the last call to
	 * {@link #require(long)}. <br>
	 * If the implemenentation of this IO doesn't use an internal buffer, this method does nothing. <br>
	 * This method should be used when bytes are written or read from this IO without incrementing internal offsets. For
	 * example, native methods.
	 */
	public void addRequired();

	/**
	 * Closes any resources used by this object. If any IO related are called after calling this method, an
	 * {@link AlreadyClosedException} will be thrown. Calling this method after the IO is already closed will have no
	 * effect.
	 * 
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void close();

	/**
	 * Sets the byte order for this IO to use.
	 * 
	 * @param byteOrder
	 *            The new byte order to use
	 */
	public void setByteOrder(ByteOrder byteOrder);

	/**
	 * Returns the byte order that this IO is currently using
	 * 
	 * @return The current byte order
	 */
	public ByteOrder getByteOrder();

	/**
	 * Mapping an IO involves creating a temporary native buffer containing empty space to write to (if this IO is an
	 * output), or space filled with the data (if this IO is an input). Returns a temporary buffer that can be used in
	 * native code. An IO can only be mapped at one instance in time. Use {@link NativeMemoryBlock#position()} to
	 * indicate how many bytes Call {@link #unmap(NativeMemoryBlock)} once reading/writing to the buffer is finished to
	 * commit all changed back to the IO
	 * 
	 * @param bytes
	 *            The number of bytes to require the buffer to have
	 * @return A native block of memory that can be used to speed up operations
	 * 
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public NativeMemoryBlock map(long bytes);

	/**
	 * Commits all changes back to the IO after use is complete {@link NativeMemoryBlock#setPosition(long)} should be
	 * used to convey how many bytes were consumed. Native code should increment the position by how many bytes were
	 * consumed as this method will only commit those changes
	 * 
	 * @param block
	 *            The block to unmap
	 * 
	 * 
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void unmap(NativeMemoryBlock block);

	/**
	 * 
	 * @return {@code true} if the endianness of the underlying system and the desired endianness are different, in
	 *         which case values written in native code need to be swapped. {@code false} otherwise
	 */
	default boolean swapEndinessInNative() {
		return (getByteOrder() == ByteOrder.BIG_ENDIAN) ^ (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\AbstractInput.java

package com.troy.empireserialization.io.in;

import java.nio.ByteOrder;

import com.troy.empireserialization.EmpireConstants;

public abstract class AbstractInput implements Input {

	private boolean bigEndian = true;

	public abstract boolean hasBuffer();

	public abstract int getBufferPosition();

	public abstract byte[] getBuffer();

	public abstract void require(long bytes);

	@Override
	public void setByteOrder(ByteOrder byteOrder) {
		bigEndian = (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ^ (byteOrder == ByteOrder.BIG_ENDIAN);
	}

	@Override
	public ByteOrder getByteOrder() {
		return bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
	}

	@Override
	public byte readByte() {
		require(Byte.BYTES);
		return readByteImpl();
	}

	@Override
	public short readShort() {
		require(Short.BYTES);
		if (bigEndian) {
			return (short) (readByteImpl() << 8 | readByteImpl());
		} else {
			return (short) (readByteImpl() | readByteImpl() << 8);
		}
	}

	@Override
	public int readInt() {
		require(Integer.BYTES);
		if (bigEndian) {
			return (int) (readByteImpl() << 24 | readByteImpl() << 16 | readByteImpl() << 8 | readByteImpl());
		} else {
			return (int) (readByteImpl() | readByteImpl() << 8 | readByteImpl() << 16 | readByteImpl() << 24);
		}
	}

	@Override
	public long readLong() {
		require(Long.BYTES);
		if (bigEndian) {
			return (long) (readByteImpl() << 56 | readByteImpl() << 48 | readByteImpl() << 40 | readByteImpl() << 32 | readByteImpl() << 24
					| readByteImpl() << 16 | readByteImpl() << 8 | readByteImpl());
		} else {
			return (long) (readByteImpl() | readByteImpl() << 8 | readByteImpl() << 16 | readByteImpl() << 24 | readByteImpl() << 32
					| readByteImpl() << 40 | readByteImpl() << 48 | readByteImpl() << 56);
		}
	}

	@Override
	public float readFloat() {
		require(Float.BYTES);
		return Float.intBitsToFloat(readInt());
	}

	@Override
	public double readDouble() {
		require(Double.BYTES);
		return Double.longBitsToDouble(readLong());
	}

	@Override
	public char readChar() {
		require(Character.BYTES);
		if (bigEndian) {
			return (char) (readByteImpl() << 8 | readByteImpl());
		} else {
			return (char) (readByteImpl() | readByteImpl() << 8);
		}
	}

	@Override
	public short readVLEShort() {
		require(1);
		int b = readByte();
		int result = b & EmpireConstants.VLE_MASK;
		if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
			require(1);
			b = readByte();
			result |= (b & EmpireConstants.VLE_MASK) << 7;
			if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
				require(1);
				b = readByte();
				result |= (b & EmpireConstants.VLE_MASK) << 14;
			}
		}
		return (short) result;
	}

	@Override
	public int readVLEInt() {
		require(1);
		int b = readByte();
		int result = b & EmpireConstants.VLE_MASK;
		if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
			require(1);
			b = readByte();
			result |= (b & EmpireConstants.VLE_MASK) << 7;
			if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
				require(1);
				b = readByte();
				result |= (b & EmpireConstants.VLE_MASK) << 14;
				if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
					require(1);
					b = readByte();
					result |= (b & EmpireConstants.VLE_MASK) << 21;
					if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
						require(1);
						b = readByte();
						result |= (b & EmpireConstants.VLE_MASK) << 28;
					}
				}
			}
		}
		return result;
	}

	@Override
	public long readVLELong() {
		require(1);
		long b = readByte();
		long result = b & EmpireConstants.VLE_MASK;
		if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
			require(1);
			b = readByte();
			result |= (b & EmpireConstants.VLE_MASK) << 7;
			if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
				require(1);
				b = readByte();
				result |= (b & EmpireConstants.VLE_MASK) << 14;
				if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
					require(1);
					b = readByte();
					result |= (b & EmpireConstants.VLE_MASK) << 21;
					if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
						require(1);
						b = readByte();
						result |= (b & EmpireConstants.VLE_MASK) << 28;
						if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
							require(1);
							b = readByte();
							result |= (b & EmpireConstants.VLE_MASK) << 35;
							if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
								require(1);
								b = readByte();
								result |= (b & EmpireConstants.VLE_MASK) << 42;
								if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
									require(1);
									b = readByte();
									result |= (b & EmpireConstants.VLE_MASK) << 49;
									if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
										require(1);
										b = readByte();
										result |= (b & EmpireConstants.VLE_MASK) << 56;
										if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
											require(1);
											b = readByte();
											result |= (b & EmpireConstants.VLE_MASK) << 63;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return result;
	}

	@Override
	public char readVLEChar() {
		require(1);
		int b = readByte();
		int result = b & EmpireConstants.VLE_MASK;
		if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
			require(1);
			b = readByte();
			result |= (b & EmpireConstants.VLE_MASK) << 7;
			if ((b & EmpireConstants.NEXT_BYTE_VLE) != 0) {
				require(1);
				b = readByte();
				result |= (b & EmpireConstants.VLE_MASK) << 14;
			}
		}
		return (char) result;
	}

	@Override
	public boolean readBoolean() {
		require(1);
		return readByteImpl() != 0;
	}

	@Override
	public void readBytes(byte[] src, int offset, int elements) {
		require(elements);
		for (int i = offset; i < offset + elements; i++) {
			src[i] = readByteImpl();
		}
	}

	@Override
	public void readShorts(short[] src, int offset, int elements) {
		require(elements * Short.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = (short) ((readByteImpl() << 8) | readByteImpl());
			} else {
				src[i] = (short) (readByteImpl() | (readByteImpl() << 8));
			}
		}
	}

	@Override
	public void readInts(int[] src, int offset, int elements) {
		require(elements * Integer.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = (readByteImpl() << 24) | (readByteImpl() << 16) | (readByteImpl() << 8) | readByteImpl();
			} else {
				src[i] = readByteImpl() | (readByteImpl() << 8) | (readByteImpl() << 16) | (readByteImpl() << 24);
			}
		}
	}

	@Override
	public void readLongs(long[] src, int offset, int elements) {
		require(elements * Long.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = (readByteImpl() << 56) | (readByteImpl() << 48) | (readByteImpl() << 40) | (readByteImpl() << 32) | (readByteImpl() << 24)
						| (readByteImpl() << 16) | (readByteImpl() << 8) | readByteImpl();
			} else {
				src[i] = readByteImpl() | (readByteImpl() << 8) | (readByteImpl() << 16) | (readByteImpl() << 24) | (readByteImpl() << 32)
						| (readByteImpl() << 40) | (readByteImpl() << 48) | (readByteImpl() << 56);
			}
		}
	}

	@Override
	public void readFloats(float[] src, int offset, int elements) {
		// Read float does require every time so we don't need to do anything
		for (int i = offset; i < offset + elements; i++) {
			src[i] = readFloat();
		}
	}

	@Override
	public void readDoubles(double[] src, int offset, int elements) {
		// Read float does require every time so we don't need to do anything
		for (int i = offset; i < offset + elements; i++) {
			src[i] = readDouble();
		}
	}

	@Override
	public void readChars(char[] src, int offset, int elements) {
		require(elements * Character.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = (char) (readByteImpl() << 8 | readByteImpl());
			} else {
				src[i] = (char) (readByteImpl() | readByteImpl() << 8);
			}
		}
	}

	@Override
	public void readBooleans(boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			src[i] = readByteImpl() != 0;
		}
	}

	@Override
	public void readBooleansCompact(boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			// TODO
		}
	}

	@Override
	public void readBytes(Byte[] src, int offset, int elements) {
		require(elements);
		for (int i = offset; i < offset + elements; i++) {
			src[i] = Byte.valueOf(readByteImpl());
		}
	}

	@Override
	public void readShorts(Short[] src, int offset, int elements) {
		require(elements * Short.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = Short.valueOf((short) ((readByteImpl() << 8) | readByteImpl()));
			} else {
				src[i] = Short.valueOf((short) (readByteImpl() | (readByteImpl() << 8)));
			}
		}
	}

	@Override
	public void readInts(Integer[] src, int offset, int elements) {
		require(elements * Integer.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = Integer.valueOf((readByteImpl() << 24) | (readByteImpl() << 16) | (readByteImpl() << 8) | readByteImpl());
			} else {
				src[i] = Integer.valueOf(readByteImpl() | (readByteImpl() << 8) | (readByteImpl() << 16) | (readByteImpl() << 24));
			}
		}
	}

	@Override
	public void readLongs(Long[] src, int offset, int elements) {
		require(elements * Long.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = Long.valueOf((long) ((readByteImpl() << 56) | (readByteImpl() << 48) | (readByteImpl() << 40) | (readByteImpl() << 32)
						| (readByteImpl() << 24) | (readByteImpl() << 16) | (readByteImpl() << 8) | readByteImpl()));
			} else {
				src[i] = Long.valueOf((long) (readByteImpl() | (readByteImpl() << 8) | (readByteImpl() << 16) | (readByteImpl() << 24)
						| (readByteImpl() << 32) | (readByteImpl() << 40) | (readByteImpl() << 48) | (readByteImpl() << 56)));
			}
		}
	}

	@Override
	public void readFloats(Float[] src, int offset, int elements) {
		// Read float does require every time so we don't need to do anything
		for (int i = offset; i < offset + elements; i++) {
			src[i] = Float.valueOf(readFloat());
		}
	}

	@Override
	public void readDoubles(Double[] src, int offset, int elements) {
		// Read float does require every time so we don't need to do anything
		for (int i = offset; i < offset + elements; i++) {
			src[i] = Double.valueOf(readDouble());
		}
	}

	@Override
	public void readChars(Character[] src, int offset, int elements) {
		require(elements * Character.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			if (bigEndian) {
				src[i] = Character.valueOf((char) (readByteImpl() << 8 | readByteImpl()));
			} else {
				src[i] = Character.valueOf((char) (readByteImpl() | readByteImpl() << 8));
			}
		}
	}

	@Override
	public void readBooleans(Boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			src[i] = Boolean.valueOf(readByteImpl() != 0);
		}
	}

	@Override
	public void readBooleansCompact(Boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			// TODO
		}
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\AbstractNativeInput.java

package com.troy.empireserialization.io.in;

import java.nio.ByteOrder;

import com.troy.empireserialization.exception.NoBufferException;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.InternalLog;

import sun.misc.Cleaner;

public abstract class AbstractNativeInput<Deallocator extends Runnable> extends AbstractInput {
	private Cleaner cleaner;
	private Deallocator deallocator;

	public void setDeallocator(Deallocator deallocator) {
		cleaner = Cleaner.create(this, new AbstractNativeOutputRunnable());
		this.deallocator = deallocator;
	}

	private class AbstractNativeOutputRunnable implements Runnable {
		@Override
		public void run() {
			deallocator.run();
			InternalLog.log("Releasing native input " + this);
		}

	}

	protected Deallocator getDeallocator() {
		return deallocator;
	}

	@Override
	public void close() {
		cleaner.clean();
	}

	//Let subclasses override these methods if they need to
	@Override
	public void setBufferPosition(int newPosition) {
		throw new NoBufferException();
	}

	@Override
	public boolean hasBuffer() {
		return false;
	}

	@Override
	public int getBufferPosition() {
		throw new NoBufferException();
	}

	@Override
	public byte[] getBuffer() {
		throw new NoBufferException();
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\ArrayInput.java

package com.troy.empireserialization.io.in;

/**
 * An interface that allows writing all primitive array types to an output.
 * 
 * @author Troy Neubauer
 *
 */
public interface ArrayInput {

	public void readBytes(byte[] src, int offset, int elements);

	public void readShorts(short[] src, int offset, int elements);

	public void readInts(int[] src, int offset, int elements);

	public void readLongs(long[] src, int offset, int elements);

	public void readFloats(float[] src, int offset, int elements);

	public void readDoubles(double[] src, int offset, int elements);

	public void readChars(char[] src, int offset, int elements);

	public void readBooleans(boolean[] src, int offset, int elements);

	public void readBooleansCompact(boolean[] src, int offset, int elements);
	
	
	
	
	
	public void readBytes(Byte[] src, int offset, int elements);

	public void readShorts(Short[] src, int offset, int elements);

	public void readInts(Integer[] src, int offset, int elements);

	public void readLongs(Long[] src, int offset, int elements);

	public void readFloats(Float[] src, int offset, int elements);

	public void readDoubles(Double[] src, int offset, int elements);

	public void readChars(Character[] src, int offset, int elements);

	public void readBooleans(Boolean[] src, int offset, int elements);

	public void readBooleansCompact(Boolean[] src, int offset, int elements);
	

	public default void readBytes(byte[] src) {
		readBytes(src, 0, src.length);
	}

	public default void readShorts(short[] src) {
		readShorts(src, 0, src.length);
	}

	public default void readInts(int[] src) {
		readInts(src, 0, src.length);
	}

	public default void readLongs(long[] src) {
		readLongs(src, 0, src.length);
	}

	public default void readFloats(float[] src) {
		readFloats(src, 0, src.length);
	}

	public default void readDoubles(double[] src) {
		readDoubles(src, 0, src.length);
	}

	public default void readChars(char[] src) {
		readChars(src, 0, src.length);
	}

	public default void readBooleans(boolean[] src) {
		readBooleans(src, 0, src.length);
	}

	public default void readBooleansCompact(boolean[] src) {
		readBooleansCompact(src, 0, src.length);
	}
	
	
	
	
	
	public default void readBytes(Byte[] src) {
		readBytes(src, 0, src.length);
	}

	public default void readShorts(Short[] src) {
		readShorts(src, 0, src.length);
	}

	public default void readInts(Integer[] src) {
		readInts(src, 0, src.length);
	}

	public default void readLongs(Long[] src) {
		readLongs(src, 0, src.length);
	}

	public default void readFloats(Float[] src) {
		readFloats(src, 0, src.length);
	}

	public default void readDoubles(Double[] src) {
		readDoubles(src, 0, src.length);
	}

	public default void readChars(Character[] src) {
		readChars(src, 0, src.length);
	}

	public default void readBooleans(Boolean[] src) {
		readBooleans(src, 0, src.length);
	}

	public default void readBooleansCompact(Boolean[] src) {
		readBooleansCompact(src, 0, src.length);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\ByteArrayInput.java

package com.troy.empireserialization.io.in;

import com.troy.empireserialization.*;
import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.*;

public class ByteArrayInput extends AbstractInput {

	private int position;
	private byte[] buffer;

	private int required;
	private MasterMemoryBlock block;

	@Override
	public byte readByteImpl() {
		try {
			return buffer[position++];
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		}
	}

	@Override
	public void addRequired() {
		position += required;
	}

	@Override
	public void close() {
		buffer = null;// Help GC
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		// Will throw an exception if there aren't x unconsumed bytes
		require(bytes);
		if (block == null) {
			block = MasterMemoryBlock.allocate(bytes);
		} else {
			block.require(bytes);
		}
		block.setPosition(0);
		NativeUtils.bytesToNative(block.address(), buffer, position, (int) bytes);
		return block;
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		this.position += block.position();
	}

	@Override
	public boolean hasBuffer() {
		return true;
	}

	@Override
	public int getBufferPosition() {
		return position;
	}

	@Override
	public void setBufferPosition(int newPosition) {
		if (newPosition < 0 || newPosition >= buffer.length)
			throw new IllegalArgumentException("New position out of range! " + newPosition);
		this.position = newPosition;
	}

	@Override
	public byte[] getBuffer() {
		if (buffer == null)
			throw new AlreadyClosedException();
		return buffer;
	}

	@Override
	public void require(long bytes) {
		if (bytes > buffer.length - position)
			throw new EndOfInputException();
		required = (int) bytes;
	}

	@Override
	public long remaining() {
		return buffer.length - position;
	}

	@Override
	public void readBytes(byte[] dest, int offset, int count) {
		System.arraycopy(buffer, position, dest, offset, count);
		position += count;

	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\Input.java

package com.troy.empireserialization.io.in;

import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.io.*;

/**
 * Allows for reading primitive types from a linear input source.
 * 
 * @author Troy Neubauer
 *
 */
public interface Input extends EmpireIO, ArrayInput {
	/**
	 * Reads the next byte in this input without checking for errors. This method should be used as the base method to
	 * implement reading primitives. This method should be called any number of times to retrieve the required data for
	 * reading higher level primitives after checking for errors.
	 * 
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next byte
	 */
	byte readByteImpl();

	/**
	 * Reads the next byte in this input. This method will block until input is available if reading from a stream.
	 * 
	 * @return The next byte
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next byte
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public byte readByte();

	/**
	 * Reads the next two big-endian bytes and composes them into a 16 bit short.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next two bytes as a short
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public short readShort();

	/**
	 * Reads the next four big-endian bytes and composes them into a 32 bit integer.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next four bytes as an int
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public int readInt();

	/**
	 * Reads the next eight big-endian bytes and composes them into a 64 bit long.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next eight bytes as a long
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public long readLong();

	/**
	 * Reads the next four big-endian bytes and composes them into an IEEE 32 bit floating point number.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next four bytes as a float
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public float readFloat();

	/**
	 * Reads the next eight big-endian bytes and composes them into an IEEE 64 bit floating point number.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next eight bytes as a double
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public double readDouble();

	/**
	 * Reads the next two big-endian bytes and composes them into a 16 bit character.<br>
	 * This method will block until input is available if reading from a stream.
	 * 
	 * @return The next two bytes as a char
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public char readChar();

	/**
	 * Reads a string using a charset and the character count This method will block until input is available if reading
	 * from a stream.
	 * 
	 * @return A string based on the number of characters and the charset to use to decode
	 * @throws EndOfInputException
	 *             If the end of input was reached while attempting to read the next bytes
	 * @throws AlreadyClosedException
	 *             If the underlying input was already closed
	 */
	public boolean readBoolean();

	public short readVLEShort();

	public int readVLEInt();

	public long readVLELong();

	public char readVLEChar();

	/**
	 * Returns an estimate as to number of bytes that can be read (or skipped over) from this input without blocking. A
	 * single read of this many bytes will not block, and neither will reading fewer bytes.
	 *
	 * <p>
	 * Note that while some implementations of {@code Input} will return the total number of bytes in the stream, many
	 * will not. Especially when dealing with web sockets, where the number of bytes remaining depends on the other
	 * side. It is never correct to use the return value of this method to allocate a buffer intended to hold all data
	 * in this stream.
	 * 
	 * @return An estimate as to number of bytes that can be read (or skipped over) from this input without blocking
	 */
	public long remaining();

	public void readBytes(byte[] dest, int offset, int elements);

	public default byte[] readBytes(int length) {
		byte[] dest = new byte[length];
		readBytes(dest, 0, length);
		return dest;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\InputStreamInput.java

package com.troy.empireserialization.io.in;

import java.io.*;
import java.util.*;

import com.troy.empireserialization.*;
import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.*;

public class InputStreamInput extends AbstractInput {

	private InputStream in;

	public InputStreamInput(InputStream in) {
		this.in = Objects.requireNonNull(in);
	}

	@Override
	public byte readByteImpl() {
		try {
			return (byte) in.read();
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public void addRequired() {
		// Nothing because InputStream.read handles everything for us
	}

	@Override
	public void close() {
		try {
			in.close();
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
		in = null;
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		byte[] temp = ByteArrayPool.aquire((int) Math.min(bytes, 1048576));
		MasterMemoryBlock block = null;
		try {
			try {
				block = MasterMemoryBlock.allocate(bytes);
				System.out
						.println("allocated " + bytes + " for the native buffer. Temp buffer " + temp.length + "bytes");
				int read = 0;
				long total = 0;
				while (total < bytes) {
					read = in.read(temp, 0, (int) Math.min(temp.length, bytes - total));
					System.out.println("total: " + total + " just read " + read);
					if (read == -1)
						throw new EndOfInputException();
					NativeUtils.bytesToNative(block.address + total, temp, 0, read);
					System.out.println("Native copy was nominal. Just copied " + read + " bytes");
					total += read;
				}

				return block;
			} catch (NullPointerException e) {
				if (block != null)
					block.free();
				throw new AlreadyClosedException();
			} catch (IOException e) {
				if (block != null)
					block.free();
				throw new EmpireSerializationIOException(e);
			}
		} finally {
			ByteArrayPool.restore(temp);

		}
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		block.setPosition(0);
	}

	@Override
	public boolean hasBuffer() {
		return false;
	}

	@Override
	public int getBufferPosition() {
		throw new NoBufferException();
	}

	@Override
	public void setBufferPosition(int newPosition) {
		throw new NoBufferException();
	}

	@Override
	public byte[] getBuffer() {
		throw new NoBufferException();
	}

	@Override
	public void require(long bytes) {
		// Nothing because java.io.InputStream.read handles everything for us
	}

	@Override
	public long remaining() {
		try {
			return in.available();
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public void readBytes(byte[] dest, int offset, int count) {
		try {
			in.read(dest, offset, count);
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\in\NativeFileInput.java

package com.troy.empireserialization.io.in;

import static com.troy.empireserialization.util.NativeUtils.fclose;
import static com.troy.empireserialization.util.NativeUtils.fopen;

import java.io.File;
import java.nio.file.Path;

import com.troy.empireserialization.exception.EmpireSerializationIOException;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.NativeUtils;
import com.troy.empireserialization.util.SerializationUtils;

public class NativeFileInput extends AbstractNativeInput<com.troy.empireserialization.io.in.NativeFileInput.Deallocator> {

	static {
		SerializationUtils.init();
	}

	private long fd;
	private MasterMemoryBlock block;

	public NativeFileInput(File file) {
		this(file.getAbsolutePath());
	}

	public NativeFileInput(Path file) {
		this(file.toString());
	}

	public NativeFileInput(String file) {
		fd = fopen(file, "rb");
		if (fd == 0)
			throw new EmpireSerializationIOException("Unable to open file \"" + file + "\" for writing");
		if (fd == SerializationUtils.OUT_OF_MEMORY)
			throw new OutOfMemoryError("Unable to open file " + file + " because the creating the name in native code failed");
		setDeallocator(new Deallocator(fd));
	}

	class Deallocator implements Runnable {
		private long fd;
		private MasterMemoryBlock block;

		public Deallocator(long fd) {
			this.fd = fd;
		}

		@Override
		public void run() {
			if (fd != 0) {
				fclose(fd);
				fd = 0;
			}
			if (block != null) {
				block.free();
				block = null;
			}
		}
	}

	@Override
	public byte readByteImpl() {
		return 0;
	}

	@Override
	public long remaining() {
		return NativeUtils.remaining(fd);
	}

	@Override
	public void readBytes(byte[] dest, int offset, int count) {
		NativeUtils.fReadToBytes(fd, dest, offset, count);
	}

	@Override
	public byte readByte() {
		return NativeUtils.fReadToByte(fd);
	}

	@Override
	public short readShort() {
		return NativeUtils.fReadToShort(fd, swapEndinessInNative());
	}

	@Override
	public int readInt() {
		return NativeUtils.fReadToInt(fd, swapEndinessInNative());
	}

	@Override
	public long readLong() {
		return NativeUtils.fReadToLong(fd, swapEndinessInNative());
	}

	@Override
	public float readFloat() {
		return NativeUtils.fReadToFloat(fd, swapEndinessInNative());
	}

	@Override
	public double readDouble() {
		return NativeUtils.fReadToDouble(fd, swapEndinessInNative());
	}

	@Override
	public char readChar() {
		return NativeUtils.fReadToChar(fd, swapEndinessInNative());
	}

	@Override
	public void readShorts(short[] dest, int offset, int elements) {
		NativeUtils.fReadToShorts(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readInts(int[] dest, int offset, int elements) {
		NativeUtils.fReadToInts(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readLongs(long[] dest, int offset, int elements) {
		NativeUtils.fReadToLongs(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readFloats(float[] dest, int offset, int elements) {
		NativeUtils.fReadToFloats(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readDoubles(double[] dest, int offset, int elements) {
		NativeUtils.fReadToDoubles(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readChars(char[] dest, int offset, int elements) {
		NativeUtils.fReadToChars(elements, dest, offset, elements, swapEndinessInNative());
	}

	@Override
	public void readBooleans(boolean[] dest, int offset, int elements) {
		NativeUtils.fReadToBooleans(elements, dest, offset, elements);
	}

	@Override
	public void readBooleansCompact(boolean[] dest, int offset, int elements) {
		// TODO
		super.readBooleansCompact(dest, offset, elements);
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		if (block == null) {
			block = MasterMemoryBlock.allocate(bytes);
			getDeallocator().block = this.block;
		} else {
			// Reset it
			block.setPosition(0);
			block.require(bytes);
		}
		NativeUtils.fReadToNative(fd, block.address, bytes);
		return block;
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		// Nothing.
	}

	@Override
	public void require(long bytes) {
		// fread does everything for us
	}

	@Override
	public void addRequired() {
		// fread does everything for us
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\AbstractNativeOutput.java

package com.troy.empireserialization.io.out;

import com.troy.empireserialization.exception.NoBufferException;
import com.troy.empireserialization.util.*;

import sun.misc.Cleaner;

public abstract class AbstractNativeOutput<Deallocator extends Runnable> extends AbstractOutput {

	private Cleaner cleaner;
	private Deallocator deallocator;

	public void setDeallocator(Deallocator deallocator) {
		cleaner = Cleaner.create(this, new AbstractNativeOutputRunnable());
		this.deallocator = deallocator;
	}

	private class AbstractNativeOutputRunnable implements Runnable {
		@Override
		public void run() {
			deallocator.run();
			InternalLog.log("Releasing native output " + this);
		}

	}

	protected Deallocator getDeallocator() {
		return deallocator;
	}

	@Override
	public void close() {
		cleaner.clean();
	}

	@Override
	public boolean isNative() {
		return true;// Hell yeah we are!
	}

	@Override
	public void setBufferPosition(int newPosition) {
		throw new NoBufferException();
	}

	@Override
	public boolean hasBuffer() {
		return false;
	}

	@Override
	public int getBufferPosition() {
		throw new NoBufferException();
	}

	@Override
	public byte[] getBuffer() {
		throw new NoBufferException();
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\AbstractOutput.java

package com.troy.empireserialization.io.out;

import java.nio.ByteOrder;

import com.troy.empireserialization.EmpireConstants;

public abstract class AbstractOutput implements Output {

	// Weather or not were writing in big endian
	protected boolean bigEndian = true;
	private boolean alreadyMapped = false;

	public AbstractOutput() {
	}

	@Override
	public void writeByte(int b) {
		require(Byte.BYTES);
		writeByteImpl((byte) b);
	}

	@Override
	public void writeByte(byte b) {
		require(Byte.BYTES);
		writeByteImpl(b);
	}

	@Override
	public void writeShort(short b) {
		require(Short.BYTES);
		if (bigEndian) {
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 0) & 0xFF));
		} else {
			writeByteImpl((byte) ((b >> 0) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
		}
	}

	@Override
	public void writeInt(int b) {
		require(Integer.BYTES);
		if (bigEndian) {
			writeByteImpl((byte) ((b >> 24) & 0xFF));
			writeByteImpl((byte) ((b >> 16) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 0) & 0xFF));
		} else {
			writeByteImpl((byte) ((b >> 0) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 16) & 0xFF));
			writeByteImpl((byte) ((b >> 24) & 0xFF));
		}
	}

	@Override
	public void writeLong(long b) {
		require(Long.BYTES);
		if (bigEndian) {
			writeByteImpl((byte) ((b >> 56) & 0xFF));
			writeByteImpl((byte) ((b >> 48) & 0xFF));
			writeByteImpl((byte) ((b >> 40) & 0xFF));
			writeByteImpl((byte) ((b >> 32) & 0xFF));
			writeByteImpl((byte) ((b >> 24) & 0xFF));
			writeByteImpl((byte) ((b >> 16) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 0) & 0xFF));
		} else {
			writeByteImpl((byte) ((b >> 0) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 16) & 0xFF));
			writeByteImpl((byte) ((b >> 24) & 0xFF));
			writeByteImpl((byte) ((b >> 32) & 0xFF));
			writeByteImpl((byte) ((b >> 40) & 0xFF));
			writeByteImpl((byte) ((b >> 48) & 0xFF));
			writeByteImpl((byte) ((b >> 56) & 0xFF));
		}
	}

	@Override
	public void writeUnsignedByte(short b) {
		if (b > 0xFFL || b < 0)
			throw new IllegalArgumentException("The value " + b + " is out of range for an unsigned byte");
		writeByte(b);
	}

	@Override
	public void writeUnsignedShort(int b) {
		if (b > 0xFFFF || b < 0)
			throw new IllegalArgumentException("The value " + b + " is out of range for an unsigned short");
		writeShort((short) b);
	}

	@Override
	public void writeUnsignedInt(long b) {
		if (b > 0xFFFFFFFFL || b < 0)
			throw new IllegalArgumentException("The value " + b + " is out of range for an unsigned int");
		writeInt((int) b);
	}

	@Override
	public void writeFloat(float b) {
		writeInt(Float.floatToRawIntBits(b));
	}

	@Override
	public void writeDouble(double b) {
		writeLong(Double.doubleToRawLongBits(b));
	}

	@Override
	public void writeChar(char b) {
		require(Character.BYTES);
		if (bigEndian) {
			writeByteImpl((byte) ((b >> 8) & 0xFF));
			writeByteImpl((byte) ((b >> 0) & 0xFF));
		} else {
			writeByteImpl((byte) ((b >> 0) & 0xFF));
			writeByteImpl((byte) ((b >> 8) & 0xFF));
		}
	}

	@Override
	public void writeBoolean(boolean b) {
		require(1);
		writeByteImpl((byte) (b ? 1 : 0));
	}

	@Override
	public void writeVLEShort(short s) {
		if (s >>> 7 == 0) {
			require(1);
			writeByteImpl((byte) s);
		} else if (s >>> 14 == 0) {
			require(2);
			writeByteImpl((byte) (s >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (s & EmpireConstants.VLE_MASK));
		} else {
			require(3);
			writeByteImpl((byte) (s >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (s >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (s & EmpireConstants.VLE_MASK));
		}
	}

	@Override
	public void writeVLEInt(int i) {
		if (i >>> 7 == 0) {
			require(1);
			writeByteImpl((byte) i);
		} else if (i >>> 14 == 0) {
			require(2);
			writeByteImpl((byte) (i >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i & EmpireConstants.VLE_MASK));
		} else if (i >>> 21 == 0) {
			require(3);
			writeByteImpl((byte) (i >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i & EmpireConstants.VLE_MASK));
		} else if (i >>> 28 == 0) {
			require(4);
			writeByteImpl((byte) (i >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i & EmpireConstants.VLE_MASK));
		} else {
			require(5);
			writeByteImpl((byte) (i >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (i & EmpireConstants.VLE_MASK));
		}
	}

	@Override
	public void writeVLELong(long l) {
		if (l >>> 7 == 0) {
			require(1);
			writeByteImpl((byte) l);
		} else if (l >>> 14 == 0) {
			require(2);
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 21 == 0) {
			require(3);
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 28 == 0) {
			require(4);
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 35 == 0) {
			require(5);
			writeByteImpl((byte) (l >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 42 == 0) {
			require(6);
			writeByteImpl((byte) (l >>> 35 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 49 == 0) {
			require(7);
			writeByteImpl((byte) (l >>> 42 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 35 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else if (l >>> 56 == 0) {
			require(8);
			writeByteImpl((byte) (l >>> 49 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 42 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 35 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		} else {
			require(9);
			writeByteImpl((byte) (l >>> 56 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 49 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 42 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 35 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 28 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 21 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (l & EmpireConstants.VLE_MASK));
		}
	}

	@Override
	public void writeVLEChar(char c) {
		if (c >>> 7 == 0) {
			require(1);
			writeByteImpl((byte) c);
		} else if (c >>> 14 == 0) {
			require(2);
			writeByteImpl((byte) (c >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (c & EmpireConstants.VLE_MASK));
		} else {
			require(3);
			writeByteImpl((byte) (c >>> 14 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (c >>> 7 | EmpireConstants.NEXT_BYTE_VLE));
			writeByteImpl((byte) (c & EmpireConstants.VLE_MASK));
		}
	}

	@Override
	public void writeBytes(byte[] src, int offset, int elements) {
		require(elements * Byte.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			writeByteImpl(src[i]);
		}
	}

	@Override
	public void writeShorts(short[] src, int offset, int elements) {
		require(elements * Short.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			short b = src[i];
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
			}
		}
	}

	@Override
	public void writeInts(int[] src, int offset, int elements) {
		require(elements * Integer.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			int b = src[i];
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
			}
		}
	}

	@Override
	public void writeLongs(long[] src, int offset, int elements) {
		require(elements * Long.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			long b = src[i];
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 56) & 0xFF));
				writeByteImpl((byte) ((b >> 48) & 0xFF));
				writeByteImpl((byte) ((b >> 40) & 0xFF));
				writeByteImpl((byte) ((b >> 32) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 32) & 0xFF));
				writeByteImpl((byte) ((b >> 40) & 0xFF));
				writeByteImpl((byte) ((b >> 48) & 0xFF));
				writeByteImpl((byte) ((b >> 56) & 0xFF));
			}
		}
	}

	@Override
	public void writeFloats(float[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeFloat(src[i]);
		}
	}

	@Override
	public void writeDoubles(double[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeDouble(src[i]);
		}
	}

	@Override
	public void writeChars(char[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeChar(src[i]);
		}
	}

	@Override
	public void writeBooleans(boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeBoolean(src[i]);
		}
	}

	@Override
	public void writeBooleansCompact(boolean[] src, int offset, int elements) {
		// TODO
	}

	@Override
	public void writeBytes(Byte[] src, int offset, int elements) {
		require(elements * Byte.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			writeByteImpl(src[i].byteValue());
		}
	}

	@Override
	public void writeShorts(Short[] src, int offset, int elements) {
		require(elements * Short.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			short b = src[i].shortValue();
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
			}
		}
	}

	@Override
	public void writeInts(Integer[] src, int offset, int elements) {
		require(elements * Integer.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			int b = src[i].intValue();
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
			}
		}
	}

	@Override
	public void writeLongs(Long[] src, int offset, int elements) {
		require(elements * Long.BYTES);
		for (int i = offset; i < offset + elements; i++) {
			long b = src[i].longValue();
			if (bigEndian) {
				writeByteImpl((byte) ((b >> 56) & 0xFF));
				writeByteImpl((byte) ((b >> 48) & 0xFF));
				writeByteImpl((byte) ((b >> 40) & 0xFF));
				writeByteImpl((byte) ((b >> 32) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 0) & 0xFF));
			} else {
				writeByteImpl((byte) ((b >> 0) & 0xFF));
				writeByteImpl((byte) ((b >> 8) & 0xFF));
				writeByteImpl((byte) ((b >> 16) & 0xFF));
				writeByteImpl((byte) ((b >> 24) & 0xFF));
				writeByteImpl((byte) ((b >> 32) & 0xFF));
				writeByteImpl((byte) ((b >> 40) & 0xFF));
				writeByteImpl((byte) ((b >> 48) & 0xFF));
				writeByteImpl((byte) ((b >> 56) & 0xFF));
			}
		}
	}

	@Override
	public void writeFloats(Float[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeFloat(src[i].floatValue());
		}
	}

	@Override
	public void writeDoubles(Double[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeDouble(src[i].doubleValue());
		}
	}

	@Override
	public void writeChars(Character[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeChar(src[i].charValue());
		}
	}

	@Override
	public void writeBooleans(Boolean[] src, int offset, int elements) {
		for (int i = offset; i < offset + elements; i++) {
			writeBoolean(src[i].booleanValue());
		}
	}

	@Override
	public void writeBooleansCompact(Boolean[] src, int offset, int elements) {
		// TODO
	}

	@Override
	public void setByteOrder(ByteOrder byteOrder) {
		bigEndian = (byteOrder == ByteOrder.BIG_ENDIAN);
	}

	@Override
	public ByteOrder getByteOrder() {
		return bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\ArrayOutput.java

package com.troy.empireserialization.io.out;

/**
 * An interface that allows writing all primitive array types to an output. 
 * @author Troy Neubauer
 *
 */
public interface ArrayOutput {

	public void writeBytes(byte[] src, int offset, int elements);

	public void writeShorts(short[] src, int offset, int elements);

	public void writeInts(int[] src, int offset, int elements);

	public void writeLongs(long[] src, int offset, int elements);

	public void writeFloats(float[] src, int offset, int elements);

	public void writeDoubles(double[] src, int offset, int elements);

	public void writeChars(char[] src, int offset, int elements);

	public void writeBooleans(boolean[] src, int offset, int elements);

	public void writeBooleansCompact(boolean[] src, int offset, int elements);
	
	
	
	
	public void writeBytes(Byte[] src, int offset, int elements);

	public void writeShorts(Short[] src, int offset, int elements);

	public void writeInts(Integer[] src, int offset, int elements);

	public void writeLongs(Long[] src, int offset, int elements);

	public void writeFloats(Float[] src, int offset, int elements);

	public void writeDoubles(Double[] src, int offset, int elements);

	public void writeChars(Character[] src, int offset, int elements);

	public void writeBooleans(Boolean[] src, int offset, int elements);

	public void writeBooleansCompact(Boolean[] src, int offset, int elements);
	

	public default void writeBytes(byte[] src) {
		writeBytes(src, 0, src.length);
	}

	public default void writeShorts(short[] src) {
		writeShorts(src, 0, src.length);
	}

	public default void writeInts(int[] src) {
		writeInts(src, 0, src.length);
	}

	public default void writeLongs(long[] src) {
		writeLongs(src, 0, src.length);
	}

	public default void writeFloats(float[] src) {
		writeFloats(src, 0, src.length);
	}

	public default void writeDoubles(double[] src) {
		writeDoubles(src, 0, src.length);
	}

	public default void writeChars(char[] src) {
		writeChars(src, 0, src.length);
	}

	public default void writeBooleans(boolean[] src) {
		writeBooleans(src, 0, src.length);
	}

	public default void writeBooleansCompact(boolean[] src) {
		writeBooleansCompact(src, 0, src.length);
	}


	public default void writeBytes(Byte[] src) {
		writeBytes(src, 0, src.length);
	}

	public default void writeShorts(Short[] src) {
		writeShorts(src, 0, src.length);
	}

	public default void writeInts(Integer[] src) {
		writeInts(src, 0, src.length);
	}

	public default void writeLongs(Long[] src) {
		writeLongs(src, 0, src.length);
	}

	public default void writeFloats(Float[] src) {
		writeFloats(src, 0, src.length);
	}

	public default void writeDoubles(Double[] src) {
		writeDoubles(src, 0, src.length);
	}

	public default void writeChars(Character[] src) {
		writeChars(src, 0, src.length);
	}

	public default void writeBooleans(Boolean[] src) {
		writeBooleans(src, 0, src.length);
	}

	public default void writeBooleansCompact(Boolean[] src) {
		writeBooleansCompact(src, 0, src.length);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\ByteArrayOutput.java

package com.troy.empireserialization.io.out;

import java.util.Arrays;

import com.troy.empireserialization.exception.AlreadyClosedException;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.MiscUtil;
import com.troy.empireserialization.util.NativeUtils;

import sun.misc.Unsafe;

public class ByteArrayOutput extends AbstractOutput {
	private static final Unsafe unsafe = MiscUtil.getUnsafe();

	private static final int NATIVE_ARRAY_COPY_THRESH_HOLD = 16;

	private MasterMemoryBlock mapped;

	private byte[] buffer;
	private int position;
	private int requested;

	public ByteArrayOutput() {
		this(116);// A Hotspot array header is 12 bytes so 116 + 12 = 128 therefore no bytes are
					// wasted due to multiple of eight packing
	}

	public ByteArrayOutput(int initalSize) {
		if (initalSize <= 0)
			throw new IllegalArgumentException("Inital size cannot be <= 0!");
		this.buffer = new byte[initalSize];
	}

	@Override
	public void writeByteImpl(byte b) {
		try {
			buffer[position++] = b;
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		}
	}

	@Override
	public boolean hasBuffer() {
		return true;
	}

	@Override
	public int getBufferPosition() {
		return position;
	}

	@Override
	public void setBufferPosition(int newPosition) {
		if (newPosition < 0 || newPosition >= buffer.length)
			throw new IllegalArgumentException("New position out of range! " + newPosition);
		this.position = newPosition;
	}

	@Override
	public byte[] getBuffer() {
		return buffer;
	}

	@Override
	public void require(long bytes) {
		try {
			if (position + bytes > buffer.length) {
				buffer = Arrays.copyOf(buffer, (int) (buffer.length * 2.5 + 1));
			}
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		}
		if (bytes > (long) Integer.MAX_VALUE)
			throw new IllegalArgumentException();
		requested = (int) bytes;
	}

	@Override
	public void close() {
		buffer = null;// Help GC
		position = -1;
		if (mapped != null)
			mapped.free();
	}

	@Override
	public void flush() {
		// Nop nothing to flush
	}

	@Override
	public void writeBytes(byte[] src, int offset, int elements) {
		require(elements * Byte.BYTES);
		System.arraycopy(src, offset, buffer, position, elements);
		addRequired();
	}

	@Override
	public void writeShorts(short[] src, int offset, int elements) {
		require(elements * Short.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.shortsToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeShorts(src, offset, elements);
		}

	}

	@Override
	public void writeInts(int[] src, int offset, int elements) {
		require(elements * Integer.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.intsToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeInts(src, offset, elements);
		}
	}

	@Override
	public void writeLongs(long[] src, int offset, int elements) {
		require(elements * Long.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.longsToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeLongs(src, offset, elements);
		}
	}

	@Override
	public void writeFloats(float[] src, int offset, int elements) {
		require(elements * Float.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.floatsToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeFloats(src, offset, elements);
		}
	}

	@Override
	public void writeDoubles(double[] src, int offset, int elements) {
		require(elements * Double.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.doublesToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeDoubles(src, offset, elements);
		}
	}

	@Override
	public void writeChars(char[] src, int offset, int elements) {
		require(elements * Character.BYTES);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.charsToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeChars(src, offset, elements);
		}
	}

	@Override
	public void writeBooleans(boolean[] src, int offset, int elements) {
		require(elements * 1);
		if (NativeUtils.NATIVES_ENABLED) {
			NativeUtils.booleansToBytes(buffer, src, offset, position, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeBooleans(src, offset, elements);
		}
	}

	@Override
	public void writeBooleansCompact(boolean[] src, int offset, int elements) {
		require((elements + 7) / 8);
		if (NativeUtils.NATIVES_ENABLED) {
			int result = NativeUtils.booleansToBytesCompact(buffer, src, offset, position, elements);
			if (result < 0) {// Error happened

			} else {
				addRequired();
			}
		} else {
			super.writeBooleansCompact(src, offset, elements);
		}

	}

	public void addRequired() {
		position += requested;
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		if (mapped == null)
			mapped = MasterMemoryBlock.allocate(bytes);
		else {
			mapped.require(bytes);
		}
		return mapped;
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		if (block != mapped)
			throw new IllegalArgumentException("NativeMemoryBlock block " + block + " is not the block mapped by this buffer!");
		if (block.position() + position > Integer.MAX_VALUE)
			NativeUtils.throwByteIndexOutOfBounds();
		NativeUtils.nativeToBytes(buffer, block.address(), position, (int) block.position());
		position += block.position();
		block.setPosition(0);
	}

	@Override
	public boolean isNative() {
		return false;// We use a Java array. So no
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\NativeFileOutput.java

package com.troy.empireserialization.io.out;

import static com.troy.empireserialization.util.NativeUtils.booleanToFWrite;
import static com.troy.empireserialization.util.NativeUtils.booleansToFWrite;
import static com.troy.empireserialization.util.NativeUtils.byteToFWrite;
import static com.troy.empireserialization.util.NativeUtils.bytesToFWrite;
import static com.troy.empireserialization.util.NativeUtils.charToFWrite;
import static com.troy.empireserialization.util.NativeUtils.charsToFWrite;
import static com.troy.empireserialization.util.NativeUtils.doubleToFWrite;
import static com.troy.empireserialization.util.NativeUtils.doublesToFWrite;
import static com.troy.empireserialization.util.NativeUtils.fclose;
import static com.troy.empireserialization.util.NativeUtils.fflush;
import static com.troy.empireserialization.util.NativeUtils.floatToFWrite;
import static com.troy.empireserialization.util.NativeUtils.floatsToFWrite;
import static com.troy.empireserialization.util.NativeUtils.fopen;
import static com.troy.empireserialization.util.NativeUtils.fputc;
import static com.troy.empireserialization.util.NativeUtils.intToFWrite;
import static com.troy.empireserialization.util.NativeUtils.intsToFWrite;
import static com.troy.empireserialization.util.NativeUtils.longToFWrite;
import static com.troy.empireserialization.util.NativeUtils.longsToFWrite;
import static com.troy.empireserialization.util.NativeUtils.nativeToFWrite;
import static com.troy.empireserialization.util.NativeUtils.shortToFWrite;
import static com.troy.empireserialization.util.NativeUtils.shortsToFWrite;

import java.io.File;
import java.nio.file.Path;

import com.troy.empireserialization.exception.EmpireSerializationIOException;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.SerializationUtils;

public class NativeFileOutput extends AbstractNativeOutput<com.troy.empireserialization.io.out.NativeFileOutput.Deallocator> {

	static {
		SerializationUtils.init();
	}

	private MasterMemoryBlock block;


	private long fd;

	public NativeFileOutput(File file) {
		this(file.getPath());
	}

	public NativeFileOutput(Path path) {
		this(path.toAbsolutePath().toString());
	}

	class Deallocator implements Runnable {
		private long fd;
		private MasterMemoryBlock block;

		public Deallocator(long fd) {
			this.fd = fd;
		}

		@Override
		public void run() {
			if (fd != 0) {
				fclose(fd);
				fd = 0;
			}
			if (block != null) {
				block.free();
				block = null;
			}
		}
	}

	public NativeFileOutput(String file) {
		fd = fopen(file, "wb");
		if (fd == 0)
			throw new EmpireSerializationIOException("Unable to open file \"" + file + "\" for writing");
		if (fd == SerializationUtils.OUT_OF_MEMORY)
			throw new OutOfMemoryError("Unable to open file " + file + " because the creating the name in native code failed");
		setDeallocator(new Deallocator(fd));
	}

	@Override
	public void writeByteImpl(byte b) {
		fputc(b, fd);
	}

	@Override
	public void writeByte(byte b) {
		byteToFWrite(fd, b);
	}

	@Override
	public void writeShort(short s) {
		shortToFWrite(fd, s, swapEndinessInNative());
	}

	@Override
	public void writeInt(int i) {
		intToFWrite(fd, i, swapEndinessInNative());
	}

	@Override
	public void writeLong(long l) {
		longToFWrite(fd, l, swapEndinessInNative());
	}

	@Override
	public void writeFloat(float f) {
		floatToFWrite(fd, f, swapEndinessInNative());
	}

	@Override
	public void writeDouble(double d) {
		doubleToFWrite(fd, d, swapEndinessInNative());
	}

	@Override
	public void writeChar(char c) {
		charToFWrite(fd, c, swapEndinessInNative());
	}
	
	@Override
	public void writeBoolean(boolean b) {
		booleanToFWrite(fd, b);
	}

	@Override
	public void flush() {
		fflush(fd);
	}

	@Override
	public void require(long bytes) {
		// fwrite does everything for us so we don't need to insure anything
	}

	@Override
	public void addRequired() {
		// Do nothing
	}

	@Override
	public void writeBytes(byte[] src, int offset, int bytes) {
		bytesToFWrite(fd, src, offset, bytes);
	}

	@Override
	public void writeShorts(short[] src, int offset, int bytes) {
		shortsToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeInts(int[] src, int offset, int bytes) {
		intsToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeLongs(long[] src, int offset, int bytes) {
		longsToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeFloats(float[] src, int offset, int bytes) {
		floatsToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeDoubles(double[] src, int offset, int bytes) {
		doublesToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeChars(char[] src, int offset, int bytes) {
		charsToFWrite(fd, src, offset, bytes, swapEndinessInNative());
	}

	@Override
	public void writeBooleans(boolean[] src, int offset, int bytes) {
		booleansToFWrite(fd, src, offset, bytes);
	}

	@Override
	public void writeBooleansCompact(boolean[] src, int offset, int bytes) {
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		if (block == null) {
			block = MasterMemoryBlock.allocate(bytes);
			getDeallocator().block = this.block;
		} else {
			// Reset it
			block.setPosition(0);
			block.require(bytes);
		}
		return block;
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		nativeToFWrite(fd, block.address(), block.position());
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\NativeOutput.java

package com.troy.empireserialization.io.out;

import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.MiscUtil;
import com.troy.empireserialization.util.NativeUtils;
import com.troy.empireserialization.util.SerializationUtils;

import sun.misc.Unsafe;

public class NativeOutput extends AbstractNativeOutput<com.troy.empireserialization.io.out.NativeOutput.Deallocator> {

	static {
		SerializationUtils.init();
	}

	private static final Unsafe unsafe = MiscUtil.getUnsafe();
	private static final long DEFAULT_CAPACITY = 128;

	/**
	 * Provides the native implemenentation for this output
	 */
	private MasterMemoryBlock impl;
	private long requested;

	public NativeOutput() {
		this(DEFAULT_CAPACITY);
	}

	class Deallocator implements Runnable {

		public Deallocator() {
		}

		@Override
		public void run() {
			if (impl != null) {
				impl.free();
			}
		}
	}

	public NativeOutput(long capacity) {
		this.impl = MasterMemoryBlock.allocate(capacity);
		setDeallocator(new Deallocator());
	}

	@Override
	public void writeByteImpl(byte b) {
		unsafe.putByte(impl.address + impl.position++, b);
	}

	@Override
	public void flush() {
		// Nop
	}

	@Override
	public void require(long bytes) {
		impl.require(bytes);
		requested = bytes;
	}

	@Override
	public void addRequired() {
		impl.position += requested;
	}

	@Override
	public void writeBytes(byte[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Short.BYTES);
			NativeUtils.bytesToNative(impl.address + impl.position, src, offset, elements);
			addRequired();
		} else {
			super.writeBytes(src, offset, elements);// The superclass increments position so we're ok without
													// addRequired();
		}
	}

	@Override
	public void writeShorts(short[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Short.BYTES);
			NativeUtils.shortsToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeShorts(src, offset, elements);// The superclass increments position so we're ok without
														// addRequired();
		}
	}

	@Override
	public void writeInts(int[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Integer.BYTES);
			NativeUtils.intsToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeInts(src, offset, elements);// The superclass increments position so we're ok without
													// addRequired();
		}
	}

	@Override
	public void writeLongs(long[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Long.BYTES);
			NativeUtils.longsToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeLongs(src, offset, elements);// The superclass increments position so we're ok without
													// addRequired();
		}
	}

	@Override
	public void writeFloats(float[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Float.BYTES);
			NativeUtils.floatsToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeFloats(src, offset, elements);// The superclass increments position so we're ok without
														// addRequired();
		}
	}

	@Override
	public void writeDoubles(double[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Double.BYTES);
			NativeUtils.doublesToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeDoubles(src, offset, elements);// The superclass increments position so we're ok without
														// addRequired();
		}
	}

	@Override
	public void writeChars(char[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Character.BYTES);
			NativeUtils.charsToNative(impl.address + impl.position, src, offset, elements, swapEndinessInNative());
			addRequired();
		} else {
			super.writeChars(src, offset, elements);// The superclass increments position so we're ok without
													// addRequired();
		}
	}

	@Override
	public void writeBooleans(boolean[] src, int offset, int elements) {
		if (NativeUtils.NATIVES_ENABLED) {
			require(elements * Integer.BYTES);
			NativeUtils.booleansToNative(impl.address + impl.position, src, offset, elements);
			addRequired();
		} else {
			super.writeBooleans(src, offset, elements);// The superclass increments position so we're ok without
														// addRequired();
		}
	}

	@Override
	public void writeBooleansCompact(boolean[] src, int offset, int elements) {
		super.writeBooleansCompact(src, offset, elements);// The superclass increments position so we're ok without
															// addRequired();
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		return impl.subset(impl.position, bytes);
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		// No copying needed since the block that we "mapped" was just a portion of the greater block.
		// Only add to position
		impl.position += block.position();
	}

	/**
	 * Returns the address of the buffer used by this out
	 */
	public long address() {
		return impl.address();
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\Output.java

package com.troy.empireserialization.io.out;

import java.io.*;

import com.troy.empireserialization.io.*;

/**
 * An interface for writing primitives to a linear output
 * 
 * @author Troy Neubauer
 *
 */
public interface Output extends EmpireIO, ArrayOutput, Flushable {

	/**
	 * Writes a byte to the output without checking for overflow with require(). This function should be called by every
	 * other write function to implement writing larger sized types.
	 * 
	 * @param b
	 *            The byte to write
	 ** @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	void writeByteImpl(byte b);

	/**
	 * Writes a byte to this output
	 * 
	 * @param b
	 *            The byte to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeByte(byte b);

	/**
	 * Writes a byte to this output<br>
	 * Note, this method takes in an int, this is solely for convince. This method ignores the 24 high bits of the
	 * argument
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeByte(int b);

	/**
	 * Writes a 16 bit integer to this output
	 * 
	 * @param b
	 *            The short to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 *
	 */
	public void writeShort(short b);

	/**
	 * Writes a 32 bit integer to this output
	 * 
	 * @param b
	 *            The int to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeInt(int b);

	/**
	 * Writes a 64 bit integer to this output
	 * 
	 * @param b
	 *            The long to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeLong(long b);

	/**
	 * Writes a byte to this output, interpreting the short as if it was an unsigned byte.
	 * 
	 * @param b
	 *            The byte to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeUnsignedByte(short b);

	/**
	 * Writes a short to this output, interpreting the int as if it was an unsigned short.
	 * 
	 * @param b
	 *            The short to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeUnsignedShort(int b);

	/**
	 * Writes an int to this output, interpreting the long as if it was an unsigned int.
	 * 
	 * @param b
	 *            The int to write
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 *
	 */
	public void writeUnsignedInt(long b);

	/**
	 * Writes a 32 bit floating point number to this output
	 * 
	 * @param b
	 *            The float to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeFloat(float b);

	/**
	 * Writes a 64 bit floating point number to this output
	 * 
	 * @param b
	 *            The double to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeDouble(double b);

	/**
	 * Writes a 16 bit unicode character to this output
	 * 
	 * @param b
	 *            The char to write
	 */
	public void writeChar(char b);

	/**
	 * Writes a 1 byte boolean to this output
	 * 
	 * @param b
	 *            The boolean to write
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeBoolean(boolean b);

	/**
	 * Writes a variable length encoded 16 bit big endian integer to this output
	 * 
	 * @param b
	 *            The short to write using variable length encoding
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeVLEShort(short b);

	/**
	 * Writes a variable length encoded 32 bit big endian integer to this output
	 * 
	 * @param b
	 *            The int to write using variable length encoding
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeVLEInt(int b);

	/**
	 * Writes a variable length encoded 64 bit big endian integer to this output
	 * 
	 * @param b
	 *            The long to write using variable length encoding
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeVLELong(long b);

	/**
	 * Writes a variable length encoded 16 bit big unicode character to this output
	 * 
	 * @param b
	 *            The char to write using variable length encoding
	 *
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void writeVLEChar(char b);

	/**
	 * Flushes this output and forces any buffered output bytes to be written out. The general contract of
	 * <code>flush</code> is that calling it is an indication that, if any bytes previously written have been buffered
	 * by the implementation of the output stream, such bytes should immediately be written to their intended
	 * destination.
	 * <p>
	 * If the intended destination of this stream is an abstraction provided by the underlying operating system, for
	 * example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed
	 * to the operating system for writing; it does not guarantee that they are actually written to a physical device
	 * such as a disk drive.
	 * <p>
	 * @throws EmpireSerializationIOException
	 *             If an I/O exception occurs
	 * @throws AlreadyClosedException
	 *             If {@link #close()} has already been called on this IO.
	 */
	public void flush();

	public default void writeBytes(byte[] src) {
		writeBytes(src, 0, src.length);
	}

	public void writeBytes(byte[] src, int offset, int bytes);
	
	/**
	 * Returns {@code true} if this is internally backed by some native IO, {@code false} otherwise. 
	 * If this method returns true, using {@link #map(long)} will be very efficient and desired.
	 * If this method returns false, it doesn't mean that {@link #map(long)} shouldn't be used, 
	 * (in most cases for large data sets it will be faster) it only means to serve as a hint for optimization
	 * 
	 * @return Weather or not this Output is backed by some native IO.
	 */
	public boolean isNative();

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\io\out\OutputStreamOutput.java

package com.troy.empireserialization.io.out;

import java.io.*;
import java.util.*;

import com.troy.empireserialization.*;
import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.memory.MasterMemoryBlock;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.*;

public class OutputStreamOutput extends AbstractOutput {

	private OutputStream out;
	private MasterMemoryBlock block;

	public OutputStreamOutput(OutputStream out) {
		this.out = Objects.requireNonNull(out);
	}

	@Override
	public void writeByteImpl(byte b) {
		try {
			out.write(b);
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public boolean hasBuffer() {
		return false;
	}

	@Override
	public int getBufferPosition() {
		throw new NoBufferException();
	}

	@Override
	public void setBufferPosition(int newPosition) {
		throw new NoBufferException();
	}

	@Override
	public byte[] getBuffer() {
		throw new NoBufferException();
	}

	@Override
	public void require(long bytes) {
		// Nop
	}

	@Override
	public void addRequired() {
		// Nop
	}

	@Override
	public void close() {
		try {
			out.close();
			out = null;
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public void flush() {
		try {
			out.flush();
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public void writeBytes(byte[] src, int offset, int bytes) {
		try {
			out.write(src, offset, bytes);
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		}
	}

	@Override
	public void writeShorts(short[] src, int offset, int bytes) {
	}

	@Override
	public void writeInts(int[] src, int offset, int bytes) {
	}

	@Override
	public void writeLongs(long[] src, int offset, int bytes) {
	}

	@Override
	public void writeFloats(float[] src, int offset, int bytes) {
	}

	@Override
	public void writeDoubles(double[] src, int offset, int bytes) {
	}

	@Override
	public void writeChars(char[] src, int offset, int bytes) {
	}

	@Override
	public void writeBooleans(boolean[] src, int offset, int bytes) {
	}

	@Override
	public void writeBooleansCompact(boolean[] src, int offset, int bytes) {
	}

	@Override
	public NativeMemoryBlock map(long bytes) {
		if (block == null)
			block = MasterMemoryBlock.allocate(Math.max(bytes, NativeUtils.DEFAULT_NATIVE_SIZE));
		else {
			block.require(bytes);
		}
		return block;
	}

	@Override
	public void unmap(NativeMemoryBlock block) {
		if (block.position() > Integer.MAX_VALUE)
			NativeUtils.throwByteIndexOutOfBounds();
		int size = (int) block.position();
		byte[] temp = ByteArrayPool.aquire(size);
		NativeUtils.nativeToBytes(temp, block.address(), 0, size);
		try {
			out.write(temp, 0, size);
		} catch (NullPointerException e) {
			throw new AlreadyClosedException();
		} catch (IOException e) {
			throw new EmpireSerializationIOException(e);
		} finally {
			ByteArrayPool.restore(temp);
		}
		block.setPosition(0);
	}

	@Override
	public boolean isNative() {
		return false;// NO
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\memory\MasterMemoryBlock.java

package com.troy.empireserialization.memory;

import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.util.*;

import sun.misc.Unsafe;

/**
 * Represents a block of native memory that os owned by this object
 * 
 * @author Troy Neubauer
 *
 */
public class MasterMemoryBlock implements NativeMemoryBlock {
	private static final Unsafe unsafe = MiscUtil.getUnsafe();

	public long address, capacity, position;

	public MasterMemoryBlock(long address, long capacity, long position) {
		this.address = address;
		this.capacity = capacity;
		this.position = position;
	}

	public static MasterMemoryBlock allocate(long bytes) {
		return new MasterMemoryBlock(unsafe.allocateMemory(bytes), bytes, 0);
	}

	@Override
	public long address() {
		if (address == 0)
			throw new AlreadyClosedException();
		return address;
	}

	@Override
	public long capacity() {
		return capacity;
	}

	@Override
	public long position() {
		return position;
	}

	@Override
	public void setPosition(long position) {
		this.position = position;
	}

	@Override
	public NativeMemoryBlock subset(long offset, long length) {
		if (offset < 0 || length < 0)
			throw new IllegalArgumentException();
		if (offset + length > capacity)
			throw new IllegalArgumentException("Attempting to create a subset from memory that is out of bounds capacity: " + capacity
					+ " Requested offset: " + offset + " Requested length " + length);
		return new SubMemoryBlock(this, offset, length);
	}

	@Override
	public void free() {
		if (address != 0)
			unsafe.freeMemory(address);
		address = 0;
	}

	@Override
	public void resize(long bytes) {
		if (address == 0)
			throw new AlreadyClosedException();
		if (bytes > capacity) {
			address = unsafe.reallocateMemory(address, bytes);
			capacity = bytes;
		}
	}

	@Override
	public String toString() {
		return "MasterMemoryBlock [address=" + address + ", capacity=" + capacity + ", position=" + position + "]";
	}

	@Override
	public void checkOffset(long offset) {
		if (offset < 0)
			throw new RuntimeException("Negative offset not allowed! Offset " + offset);
		if (offset >= capacity)
			throw new RuntimeException("Offset out of range! Buffer Capacity: " + capacity + " offset " + offset);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\memory\NativeMemoryBlock.java

package com.troy.empireserialization.memory;

/**
 * Represents a block of native memory
 * @author Troy Neubauer
 *
 */
public interface NativeMemoryBlock {
	/**
	 * Returns the address of the start of the memory block
	 */
	public long address();

	/**
	 * Returns the number of bytes this buffer currently has allocated for it
	 */
	public long capacity();

	/**
	 * Returns the number of bytes consumed by this buffer. Set using{@link #setPosition(long)}
	 */
	public long position();

	/**
	 * Sets the number of consumed byte for this memory block
	 * 
	 * @param position
	 *            The new position
	 */
	public void setPosition(long position);

	/**
	 * Returns the number of bytes left between the position and the end of this buffer
	 */
	public default long remaining() {
		return capacity() - position();
	}

	/**
	 * Returns a subset of this memory block
	 * 
	 * @param offset
	 *            The number of bytes into this block that the new block should start at
	 * @param length
	 *            The number of bytes in the resulting buffer
	 */
	public NativeMemoryBlock subset(long offset, long length);

	/**
	 * Frees the native memory used by this block if this object owns it. If this object represents a subset of another
	 * block of memory, no action is taken
	 */
	public void free();

	/**
	 * Ensures that there is at least x bytes between this block's position and its capacity, resizing the buffer if the
	 * condition is not met.
	 * 
	 * @param bytes
	 *            The number of bytes to require
	 */
	public default void require(long bytes) {
		if (position() + bytes > capacity()) {
			long newSize = capacity();
			while(newSize < bytes + position()) {
				newSize <<= 1;
			}
			resize(newSize);
		}
	}

	/**
	 * Resizes this buffer to a new size so that it can hold at exactly x bytes after this method call
	 * 
	 * @param bytes
	 *            The new capacity of this buffer
	 */
	void resize(long bytes);
	
	/**
	 * Throws a runtime exception if the offset passed in is out of the range of this buffer
	 * @param offset The offset to check
	 * @throws RuntimeException If the offset is out of range
	 */
	public void checkOffset(long offset);
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\memory\SubMemoryBlock.java

package com.troy.empireserialization.memory;

import com.troy.empireserialization.util.*;

import sun.misc.*;

/**
 * Represents a sub section of a larger block of memory
 * 
 * @author Troy Neubauer
 *
 */
public class SubMemoryBlock implements NativeMemoryBlock {
	private static final Unsafe unsafe = MiscUtil.getUnsafe();

	private NativeMemoryBlock parent;
	private long offset, capacity, position;

	public SubMemoryBlock(NativeMemoryBlock parent, long offset, long length) {
		this.parent = parent;
		this.offset = offset;
		this.capacity = length;
	}

	@Override
	public long address() {
		return parent.address() + offset;
	}

	@Override
	public long capacity() {
		return capacity;
	}

	@Override
	public long position() {
		return position;
	}

	@Override
	public void setPosition(long position) {
		this.position = position;

	}

	@Override
	public NativeMemoryBlock subset(long offset, long length) {
		if (offset < 0 || length < 0)
			throw new IllegalArgumentException();
		if (offset + length > capacity)
			throw new IllegalArgumentException("Attempting to create a subset from memory that is out of bounds capacity: " + capacity
					+ " Requested offset: " + offset + " Requested length " + length);

		return new SubMemoryBlock(this, offset, length);
	}

	@Override
	public void free() {
		// Nothing as we do not own this memory, our parent does
	}

	@Override
	public void resize(long bytes) {
		this.capacity = bytes;
		parent.resize(bytes + offset);
	}

	@Override
	public String toString() {
		return "SubMemoryBlock [parent=" + parent + ", offset=" + offset + ", capacity=" + capacity + ", position=" + position + "]";
	}

	@Override
	public void checkOffset(long offset) {
		// Add this offset so that the parent receives an offset relative to them, not
		// us
		parent.checkOffset(offset + this.offset);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\nativelibrary\ClassPathLibraryProvider.java

package com.troy.empireserialization.nativelibrary;

public class ClassPathLibraryProvider extends LibraryProvider {

	@Override
	public void load(NativeLibrary lib) throws Exception {
		System.loadLibrary(lib.getPlatformIndependentName());
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\nativelibrary\LibraryProvider.java

package com.troy.empireserialization.nativelibrary;

import java.util.*;

import com.troy.empireserialization.nativelibrary.NativeLibrary.*;
import com.troy.empireserialization.util.*;

public abstract class LibraryProvider {

	private static final List<LibraryProvider> providers = new ArrayList<LibraryProvider>();
	protected static final List<NativeLibrary> libs = new ArrayList<NativeLibrary>();

	private static final Object LOAD_LOCK = new Object();

	static {
		providers.add(new ClassPathLibraryProvider());
		libs.add(new NativeLibrary("TS", new NativeLibraryNameResolver() {
			@Override
			public String getPlatformIndependentName(String baseName, boolean _64Bit) {
				return baseName + (_64Bit ? "64" : "32");
			}

		}) {//Override toString
			@Override
			public String toString() {
				return "TS Native Library";
			}
		});
	}

	public static boolean loadLibrary() {
		for (LibraryProvider provider : providers) {
			for (NativeLibrary lib : libs) {
				try {
					synchronized (LOAD_LOCK) {
						InternalLog.log("Attempting to load native library: " + lib);
						provider.load(lib);
						InternalLog.log("\tLibrary: " + lib + " is now loaded with the VM");
					}
					return true;
				} catch (Exception e) {
					InternalLog.log("\tFailed to load native library: " + lib + "\n" + MiscUtil.getStackTrace(e));
				}
			}
		}
		return false;
	}

	/**
	 * Attempts to load the requested native library, throwing an exception if any
	 * error occurs, otherwise returning normally
	 * 
	 * @param lib
	 *            The native library to load
	 * @throws Exception
	 *             If any issue is detected that would prevent the desired native
	 *             library from being loaded and linked successfully
	 */
	public abstract void load(NativeLibrary lib) throws Exception;
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\nativelibrary\NativeLibrary.java

package com.troy.empireserialization.nativelibrary;

import java.util.Objects;

import com.troy.empireserialization.util.*;

public class NativeLibrary {
	private String baseName;
	private NativeLibraryNameResolver resolver;

	public NativeLibrary(String baseName, NativeLibraryNameResolver resolver) {
		this.baseName = Objects.requireNonNull(baseName);
		this.resolver = Objects.requireNonNull(resolver);
	}

	public String getNativeName() {
		return System.mapLibraryName(getPlatformIndependentName());
	}

	public String getPlatformIndependentName() {
		return resolver.getPlatformIndependentName(baseName, NativeUtils.IS_64_BIT);
	}

	public interface NativeLibraryNameResolver {
		/**
		 * Returns the name of the native library stripped of any platform specific prefix using the info provided
		 * 
		 * @param baseName The name of library as passed to the constructor
		 * @param _64Bit
		 * @return
		 */
		public String getPlatformIndependentName(String baseName, boolean _64Bit);

	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\ObjectIn.java

package com.troy.empireserialization;

public interface ObjectIn extends AutoCloseable {
	
	public Object readObject();
	
	Object readObjectRecursive();

	public void close();
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\ObjectOut.java

package com.troy.empireserialization;

import java.io.Flushable;

import com.troy.empireserialization.cache.IntValue;
import com.troy.empireserialization.cache.IntValueCache;

public interface ObjectOut extends Flushable, AutoCloseable {

	public <T> void writeObject(T obj);

	public void flush();

	public void close();

	/**
	 * Called recursively to write an instance variable of an object
	 * 
	 * @param object
	 *            The object to write
	 */
	<T> void writeObjectRecursive(T object, long extra);
	
	public void writeString(String str);
	
	void writeTypeReference(IntValue<Class<?>> entry);

	void writeTypeDefinition(Class<?> type);
	
	public void writeTypeComplete(Class<?> type);

	public IntValueCache<Object> getObjectCache();

	public IntValueCache<Class<?>> getClassCache();

	public IntValueCache<String> getStringCache();

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\SerializationSettings.java

package com.troy.empireserialization;

public class SerializationSettings {
	public static final SerializationSettings defaultSettings = new SerializationSettings();


	public boolean inferFinalClasses;
	public boolean useObjectCache, useStringCache;

	public boolean useVLE;
	public boolean useLittleEndian;
	public boolean pluginsPresent;
	public int version = Version.VERSION_1;

	public SerializationSettings() {
		inferFinalClasses = true;
		useVLE = true;
		useObjectCache = true;
		useStringCache = true;
	}

	public SerializationSettings inferFinalClasses(boolean inferFinalClasses) {
		this.inferFinalClasses = inferFinalClasses;
		return this;
	}

	public SerializationSettings useObjectCache(boolean useObjectCache) {
		this.useObjectCache = useObjectCache;
		return this;
	}

	public SerializationSettings useStringCache(boolean useStringCache) {
		this.useStringCache = useStringCache;
		return this;
	}

	public SerializationSettings useVLE(boolean useVLE) {
		this.useVLE = useVLE;
		return this;
	}

	public SerializationSettings useLittleEndian(boolean useLittleEndian) {
		this.useLittleEndian = useLittleEndian;
		return this;
	}

	public static SerializationSettings getDefaultSettings() {
		return defaultSettings;
	}

	public int getFlagsData() {

		return 0;
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\AbstractObjectSerializer.java

package com.troy.empireserialization.serializers;

import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.util.ClassHelper;

public abstract class AbstractObjectSerializer<T> implements ObjectSerializer<T> {
	protected Class<T> type;

	public AbstractObjectSerializer(Class<T> type) {
		this.type = type;
	}

	@Override
	public Class<T> getType() {
		return type;
	}

	public T newInstance() {
		return null;// Delegate. Sub classes can override this if necessary
	}

	@Override
	public void writeTypeDefinition(EmpireOutput out) {
		ClassHelper.getClassData(type).writeTypeDefinition(out);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\ArraySerializer.java

package com.troy.empireserialization.serializers;

import java.lang.reflect.Array;
import java.util.Arrays;

import com.troy.empireserialization.EmpireOpCodes;
import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.cache.IntValue;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.util.ClassHelper;

public class ArraySerializer extends AbstractObjectSerializer<Object[]> {

	public static final ArraySerializer SERIALIZER = new ArraySerializer();

	public ArraySerializer() {
		super(Object[].class);
	}

	@Override
	public void write(ObjectOut objectOut, Object[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
		if (obj == null) {
			out.writeByte(EmpireOpCodes.NULL_REF_CONST);
			return;
		}
		if (obj.length == 0) {
			out.writeByte(EmpireOpCodes.EMPTY_STRING_CONST);
			return;
		}
		int offset;
		int length;
		if (extra == -1) {
			offset = 0;
			length = obj.length;
		} else {
			offset = (int) ((extra >>> 32) & 0xFFFFFFFF);
			length = (int) ((extra >>> 0) & 0xFFFFFFFF);
		}
		boolean sameType = true, typeRef;
		Class<?> lastType = null;
		for (int i = offset; i < offset + length; i++) {
			Class<?> currentType = obj[i].getClass();
			if (lastType != null && currentType != lastType) {
				sameType = false;
				break;
			}
			lastType = currentType;
		}
		if (sameType && ClassHelper.isPrimitive(lastType)) {
			Object array = Array.newInstance(lastType, length);
			for (int i = 0; i < length; i++) {
				Array.set(array, i, obj[i]);
			}
			objectOut.writeObjectRecursive(array, extra);
			return;
		} else if (sameType) {
			IntValue<Class<?>> cached = objectOut.getClassCache().get(lastType);
			if (cached == null) {// We need to define the type
				out.writeByte(EmpireOpCodes.TYPE_DEF_OBJ_DEF_TYPE);
				objectOut.writeTypeDefinition(lastType);
			} else {// Reference the type
				out.writeByte(EmpireOpCodes.TYPE_REF_OBJ_DEF_TYPE);
				objectOut.writeTypeReference(cached);
			}
			// Write the data
			for (int i = offset; i < offset + length; i++) {
				objectOut.writeObjectRecursive(obj[i], -1L);
			}
		} else {// Polymorphic
			out.writeByte(EmpireOpCodes.POLYMORPHIC_ARRAY_TYPE);
			for (int i = offset; i < offset + length; i++) {
				Object element = obj[i];
				objectOut.writeTypeComplete(element.getClass());
				objectOut.writeObjectRecursive(element, -1L);
			}
		}
	}

	@Override
	public void read(ObjectIn objIn, Object[] obj, Input in, Class<Object[]> type, long extra) {
		// TODO
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\DefaultObjectSerializer.java

package com.troy.empireserialization.serializers;

import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.clazz.ClassData;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.util.ClassHelper;
import com.troy.empireserialization.util.MiscUtil;

import sun.misc.Unsafe;

public class DefaultObjectSerializer<T> extends AbstractObjectSerializer<T> {

	public DefaultObjectSerializer(Class<T> type, EmpireOutput out) {
		super(type);
	}

	private static final Unsafe unsafe = MiscUtil.getUnsafe();

	@Override
	public void write(ObjectOut objectOut, T obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
		ClassData<T> data = ClassHelper.getClassData(type);

		int size = data.rawFields.length;
		for (int i = 0; i < size; i++) {
			Class<?> type = data.fieldTypes[i];
			if (type.isPrimitive()) {
				long offset = data.fieldOffsets[i];
				if (type == int.class) {
					out.writeInt(unsafe.getInt(obj, offset));
				} else if (type == long.class) {
					out.writeLong(unsafe.getLong(obj, offset));
				} else if (type == double.class) {
					out.writeDouble(unsafe.getDouble(obj, offset));
				} else if (type == float.class) {
					out.writeFloat(unsafe.getFloat(obj, offset));
				} else if (type == char.class) {
					out.writeChar(unsafe.getChar(obj, offset));
				} else if (type == boolean.class) {
					out.writeBoolean(unsafe.getBoolean(obj, offset));
				} else if (type == byte.class) {
					out.writeByte(unsafe.getByte(obj, offset));
				} else if (type == short.class) {
					out.writeShort(unsafe.getShort(obj, offset));
				}

			} else if (type == String.class) {
				objectOut.writeString((String) unsafe.getObject(obj, data.fieldOffsets[i]));
			} else {
				objectOut.writeObjectRecursive(unsafe.getObject(obj, data.fieldOffsets[i]), -1L);
			}
		}
	}

	@Override
	public void read(ObjectIn out, T obj, Input in, Class<T> type, long extra) {
		ClassData<T> info = ClassHelper.getClassData(type);
		for (int i = 0; i < info.rawFields.length; i++) {
			Class<?> fieldType = info.fieldTypes[i];
			if (fieldType.isPrimitive()) {
				if (type == int.class) {
					unsafe.putInt(obj, info.fieldOffsets[i], in.readInt());
				} else if (type == long.class) {
					unsafe.putLong(obj, info.fieldOffsets[i], in.readLong());
				} else if (type == double.class) {
					unsafe.putDouble(obj, info.fieldOffsets[i], in.readDouble());
				} else if (type == float.class) {
					unsafe.putFloat(obj, info.fieldOffsets[i], in.readFloat());
				} else if (type == char.class) {
					unsafe.putChar(obj, info.fieldOffsets[i], in.readChar());
				} else if (type == boolean.class) {
					unsafe.putBoolean(obj, info.fieldOffsets[i], in.readBoolean());
				} else if (type == byte.class) {
					unsafe.putByte(obj, info.fieldOffsets[i], in.readByte());
				} else if (type == short.class) {
					unsafe.putShort(obj, info.fieldOffsets[i], in.readShort());
				}
			}
			try {
				info.rawFields[i].set(obj, out.readObjectRecursive());
			} catch (IllegalArgumentException | IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}

	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\DynamicSerializer.java

package com.troy.empireserialization.serializers;

public interface DynamicSerializer {
	
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\FieldType.java

package com.troy.empireserialization.serializers;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.util.ClassHelper;

public enum FieldType {
	WILDCARD(0b00), PRIMITIVE(0b01), USER_DEFINED(0b10);
	public static final int MASK = 0b11;

	int code;

	FieldType(int code) {
		this.code = code;
	}

	public static FieldType identifyFieldType(Field field) {
		return identifyFieldType(field, SerializationSettings.defaultSettings);
	}

	public static FieldType identifyFieldType(Field field, SerializationSettings settings) {
		Class<?> type = field.getType();
		if (ClassHelper.isPrimitive(type))
			return FieldType.PRIMITIVE;
		if (Modifier.isFinal(type.getModifiers()))
			return FieldType.USER_DEFINED;
		if (Modifier.isAbstract(type.getModifiers()) || type == Object.class)
			return FieldType.WILDCARD;
		if (settings.inferFinalClasses) {
			if (ClassHelper.hasSubClass(type))
				return FieldType.WILDCARD;
			else
				return FieldType.USER_DEFINED;
		}
		return FieldType.WILDCARD;
	}

	public int getCode() {
		return code;
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\ListSerializer.java

package com.troy.empireserialization.serializers;

import java.util.List;

import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;
import com.troy.empireserialization.util.ReflectionUtils;

public class ListSerializer extends AbstractObjectSerializer<List> {

	public static final ListSerializer SERIALIZER = new ListSerializer();
	
	public ListSerializer() {
		super(List.class);
	}

	@Override
	public void write(ObjectOut objectOut, List obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
		Object[] data = ReflectionUtils.getListData(obj);
		if(extra == -1) {//Keep the offset at 0 but put in the length
			extra = obj.size();
		}
		objectOut.writeObjectRecursive(data, extra);
	}

	@Override
	public void read(ObjectIn objIn, List obj, Input in, Class<List> type, long extra) {
		Object[] listData = ReflectionUtils.getListData(obj);
		ArraySerializer.SERIALIZER.read(objIn, listData, in, (Class<Object[]>) listData.getClass(), extra);
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\ObjectSerializer.java

package com.troy.empireserialization.serializers;

import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;

public interface ObjectSerializer<T> {

	/**
	 * Returns the type this serializer can handle
	 */
	public Class<T> getType();

	/**
	 * Writes an object's fields to the output stream so that It can be
	 * de-serialized later using {@link #readFields(Object, Input)}
	 * 
	 * @param obj
	 *            The object to write
	 * @param out
	 *            The output to write to
	 */
	public void write(ObjectOut objectOut, T obj, Output out, boolean writeHeader, SerializationSettings settings, long extra);

	/**
	 * 
	 * Reads from the input provided to assign the fields of the object passed in.
	 * 
	 * @param objIn
	 *            The object input stream to read from in case this object has other
	 *            objects as instance variables
	 * @param obj
	 *            The object whose fields should be assigned
	 * @param in
	 *            The input to read from
	 * @param type
	 *            The type of the object to read
	 * @param extraData
	 *            an array always of length 16 that can provide some implementation
	 *            specific data to the deserializer
	 */
	public void read(ObjectIn objIn, T obj, Input in, Class<T> type, long extra);

	/**
	 * Returns a new instance of the type represented by this serializer. If an
	 * instance cannot be created by this serializer for any reason, it should
	 * return null to delegate instance creation to the current instantiation
	 * strategy.
	 * 
	 * @return A new instance of the type represented by this serializer
	 */
	public T newInstance();

	/**
	 * Writes a TS Standard compliant type definition for the type this serializer
	 * represents
	 * 
	 * @param out
	 *            The output to write the definition to
	 */
	public void writeTypeDefinition(EmpireOutput out);
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\PrimitiveArraySerializers.java

package com.troy.empireserialization.serializers;

import com.troy.empireserialization.EmpireOpCodes;
import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;

public class PrimitiveArraySerializers {
	static {
		try {
			// Adds array serializers for all primitive types and all wrapper classes
			Serializers.addSerializer(new AbstractObjectSerializer<byte[]>(byte[].class) {

				@Override
				public void write(ObjectOut objectOut, byte[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(byte.class));
					out.writeBytes(obj);
				}

				@Override
				public void read(ObjectIn objIn, byte[] obj, Input in, Class<byte[]> type, long extra) {
					in.readBytes(obj);
				}

			});
			Serializers.addSerializer(new AbstractObjectSerializer<short[]>(short[].class) {

				@Override
				public void write(ObjectOut objectOut, short[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(short.class));
					out.writeShorts(obj);
				}

				@Override
				public void read(ObjectIn objIn, short[] obj, Input in, Class<short[]> type, long extra) {
					in.readShorts(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<int[]>(int[].class) {

				@Override
				public void write(ObjectOut objectOut, int[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(int.class));
					out.writeInts(obj);
				}

				@Override
				public void read(ObjectIn objIn, int[] obj, Input in, Class<int[]> type, long extra) {
					in.readInts(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<long[]>(long[].class) {

				@Override
				public void write(ObjectOut objectOut, long[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(long.class));
					out.writeLongs(obj);
				}

				@Override
				public void read(ObjectIn objIn, long[] obj, Input in, Class<long[]> type, long extra) {
					in.readLongs(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<float[]>(float[].class) {

				@Override
				public void write(ObjectOut objectOut, float[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(float.class));
					out.writeFloats(obj);
				}

				@Override
				public void read(ObjectIn objIn, float[] obj, Input in, Class<float[]> type, long extra) {
					in.readFloats(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<double[]>(double[].class) {

				@Override
				public void write(ObjectOut objectOut, double[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(double.class));
					out.writeDoubles(obj);
				}

				@Override
				public void read(ObjectIn objIn, double[] obj, Input in, Class<double[]> type, long extra) {
					in.readDoubles(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<char[]>(char[].class) {

				@Override
				public void write(ObjectOut objectOut, char[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(char.class));
					out.writeChars(obj);
				}

				@Override
				public void read(ObjectIn objIn, char[] obj, Input in, Class<char[]> type, long extra) {
					in.readChars(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<boolean[]>(boolean[].class) {

				@Override
				public void write(ObjectOut objectOut, boolean[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(boolean.class));
					out.writeBooleansCompact(obj);
				}

				@Override
				public void read(ObjectIn objIn, boolean[] obj, Input in, Class<boolean[]> type, long extra) {
					in.readBooleansCompact(obj);
				}
			});

			// Yuck wrapper classes!

			Serializers.addSerializer(new AbstractObjectSerializer<Byte[]>(Byte[].class) {

				@Override
				public void write(ObjectOut objectOut, Byte[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Byte.class));
					out.writeBytes(obj);
				}

				@Override
				public void read(ObjectIn objIn, Byte[] obj, Input in, Class<Byte[]> type, long extra) {
					in.readBytes(obj);
				}

			});
			Serializers.addSerializer(new AbstractObjectSerializer<Short[]>(Short[].class) {

				@Override
				public void write(ObjectOut objectOut, Short[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Short.class));
					out.writeShorts(obj);
				}

				@Override
				public void read(ObjectIn objIn, Short[] obj, Input in, Class<Short[]> type, long extra) {
					in.readShorts(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<Integer[]>(Integer[].class) {

				@Override
				public void write(ObjectOut objectOut, Integer[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Integer.class));
					out.writeInts(obj);
				}

				@Override
				public void read(ObjectIn objIn, Integer[] obj, Input in, Class<Integer[]> type, long extra) {
					in.readInts(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<Long[]>(Long[].class) {

				@Override
				public void write(ObjectOut objectOut, Long[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Long.class));
					out.writeLongs(obj);
				}

				@Override
				public void read(ObjectIn objIn, Long[] obj, Input in, Class<Long[]> type, long extra) {
					in.readLongs(obj);
				}
			});
			Serializers.addSerializer(new AbstractObjectSerializer<Float[]>(Float[].class) {

				@Override
				public void write(ObjectOut objectOut, Float[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Float.class));
					out.writeFloats(obj);
				}

				@Override
				public void read(ObjectIn objIn, Float[] obj, Input in, Class<Float[]> type, long extra) {
					in.readFloats(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<Double[]>(Double[].class) {

				@Override
				public void write(ObjectOut objectOut, Double[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Double.class));
					out.writeDoubles(obj);
				}

				@Override
				public void read(ObjectIn objIn, Double[] obj, Input in, Class<Double[]> type, long extra) {
					in.readDoubles(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<Character[]>(Character[].class) {

				@Override
				public void write(ObjectOut objectOut, Character[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Character.class));
					out.writeChars(obj);
				}

				@Override
				public void read(ObjectIn objIn, Character[] obj, Input in, Class<Character[]> type, long extra) {
					in.readChars(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<Boolean[]>(Boolean[].class) {

				@Override
				public void write(ObjectOut objectOut, Boolean[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(Boolean.class));
					out.writeBooleansCompact(obj);
				}

				@Override
				public void read(ObjectIn objIn, Boolean[] obj, Input in, Class<Boolean[]> type, long extra) {
					in.readBooleansCompact(obj);
				}
			});

			Serializers.addSerializer(new AbstractObjectSerializer<String[]>(String[].class) {

				@Override
				public void write(ObjectOut objectOut, String[] obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
					if (writeHeader)
						out.writeByte(EmpireOpCodes.PRIMITIVE_ARRAY_TYPE);
					out.writeVLEInt(obj.length);
					out.writeByte(EmpireOpCodes.PRIMITIVE_TYPE_MAPPING.get(String.class));
					for (int i = 0; i < obj.length; i++) {
						objectOut.writeString(obj[i]);
					}
				}

				@Override
				public void read(ObjectIn objIn, String[] obj, Input in, Class<String[]> type, long extra) {
					// TODO
				}
			});

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void init() {
		// Invokes static initializer
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\PrimitiveSerializers.java

package com.troy.empireserialization.serializers;

import com.troy.empireserialization.EmpireOpCodes;
import com.troy.empireserialization.ObjectIn;
import com.troy.empireserialization.ObjectOut;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.in.Input;
import com.troy.empireserialization.io.out.Output;

public class PrimitiveSerializers {

	static {
		Serializers.addSerializer(new AbstractObjectSerializer<Byte>(Byte.class) {

			@Override
			public void write(ObjectOut objectOut, Byte obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.SIGNED_BYTE_TYPE);
				out.writeByte(obj.byteValue());
			}

			@Override
			public void read(ObjectIn objIn, Byte obj, Input in, Class<Byte> type, long extra) {
				// TODO
			}
		});

		Serializers.addSerializer(new AbstractObjectSerializer<Short>(Short.class) {

			@Override
			public void write(ObjectOut objectOut, Short obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.SIGNED_SHORT_TYPE);
				if (settings.useVLE)
					out.writeVLEShort(obj.shortValue());
				else
					out.writeShort(obj.shortValue());
			}

			@Override
			public void read(ObjectIn objIn, Short obj, Input in, Class<Short> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Integer>(Integer.class) {

			@Override
			public void write(ObjectOut objectOut, Integer obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.SIGNED_INT_TYPE);
				if (settings.useVLE)
					out.writeVLEInt(obj.intValue());
				else
					out.writeInt(obj.intValue());
			}

			@Override
			public void read(ObjectIn objIn, Integer obj, Input in, Class<Integer> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Long>(Long.class) {

			@Override
			public void write(ObjectOut objectOut, Long obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.SIGNED_LONG_TYPE);
				out.writeLong(obj.longValue());
			}

			@Override
			public void read(ObjectIn objIn, Long obj, Input in, Class<Long> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Float>(Float.class) {

			@Override
			public void write(ObjectOut objectOut, Float obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.FLOAT_TYPE);
				out.writeFloat(obj.floatValue());
			}

			@Override
			public void read(ObjectIn objIn, Float obj, Input in, Class<Float> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Double>(Double.class) {

			@Override
			public void write(ObjectOut objectOut, Double obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.DOUBLE_TYPE);
				out.writeDouble(obj.doubleValue());
			}

			@Override
			public void read(ObjectIn objIn, Double obj, Input in, Class<Double> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Character>(Character.class) {

			@Override
			public void write(ObjectOut objectOut, Character obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (writeHeader)
					out.writeByte(EmpireOpCodes.UNSIGNED_SHORT_TYPE);
				out.writeChar(obj.charValue());
			}

			@Override
			public void read(ObjectIn objIn, Character obj, Input in, Class<Character> type, long extra) {
				// TODO
			}
		});
		Serializers.addSerializer(new AbstractObjectSerializer<Boolean>(Boolean.class) {

			@Override
			public void write(ObjectOut objectOut, Boolean obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				if (obj.booleanValue())
					out.writeByte(EmpireOpCodes.BOOLEAN_TRUE_CONST);
				else
					out.writeByte(EmpireOpCodes.BOOLEAN_FALSE_CONST);
			}

			@Override
			public void read(ObjectIn objIn, Boolean obj, Input in, Class<Boolean> type, long extra) {
				// TODO
			}
		});

		Serializers.addSerializer(new AbstractObjectSerializer<String>(String.class) {

			@Override
			public void write(ObjectOut objectOut, String obj, Output out, boolean writeHeader, SerializationSettings settings, long extra) {
				objectOut.writeString(obj);
			}

			@Override
			public void read(ObjectIn objIn, String obj, Input in, Class<String> type, long extra) {
				// TODO
			}
		});

	}

	public static void init() {

	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\serializers\Serializers.java

package com.troy.empireserialization.serializers;

import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.util.SerializationUtils;

public class Serializers {

	private final static HashMap<Class<?>, ObjectSerializer<?>> map = new HashMap<Class<?>, ObjectSerializer<?>>(100, 0.5f);

	static {
		PrimitiveSerializers.init();
		PrimitiveArraySerializers.init();
		addSerializer(ArraySerializer.SERIALIZER);
		addSerializer(ListSerializer.SERIALIZER);
	}

	/**
	 * Fetches and returns the serializer associated with the desired type, or
	 * creates a new serializer if there is currently no mapping associated with
	 * requested type.
	 * 
	 * @return The serializer associated with the given type
	 */
	public static <T> ObjectSerializer<T> getSerializer(Class<T> type, EmpireOutput out) {
		ObjectSerializer<T> ser = (ObjectSerializer<T>) map.get(type);
		if (ser == null) {
			if (type.isArray() && Object.class.isAssignableFrom(type.getComponentType())) {
				ser = (ObjectSerializer<T>) ArraySerializer.SERIALIZER;
			}
			if (List.class.isAssignableFrom(type)) {
				ser = (ObjectSerializer<T>) ListSerializer.SERIALIZER;
			} else
				ser = createSerializer(type, out);
			map.put(type, ser);
		}
		return ser;
	}

	/**
	 * Registers the given type to be serialized using the desired serializer.
	 * Returns {@code true} if calling this method overrode a previous type -
	 * serializer entry.
	 * 
	 * @param type
	 *            The type to associate with the given serializer
	 * @param serializer
	 *            The serializer to associate with the given type
	 * @return True if calling this method overrode a previous type - serializer
	 *         entry.
	 */
	public static <T> boolean setSerializer(Class<T> type, ObjectSerializer<T> serializer) {
		return map.put(Objects.requireNonNull(type), Objects.requireNonNull(serializer)) != null;
	}

	protected static void addSerializer(ObjectSerializer<?> serializer) {
		map.put(serializer.getType(), serializer);
	}

	private static <T> ObjectSerializer<T> createSerializer(Class<T> type, EmpireOutput out) {
		if (!SerializationUtils.DYNAMIC_CLASS_LOADING_ENABLED) {// Use the default one if we can't create a dynamic one
			return new DefaultObjectSerializer<T>(type, out);
		} // Create a dynamic one

		return null;// TODO create dynamic serializer creation system
	}

	public static void init() {

	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\ArrayUtil.java

package com.troy.empireserialization.util;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.List;

public class ArrayUtil {

	public static <T> T[] concat(T[] a, T[] b) {
		int aLen = a.length;
		int bLen = b.length;
		T[] c = (T[]) Array.newInstance(a.getClass().getComponentType(), aLen + bLen);
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static byte[] concat(byte[] a, byte[] b) {
		int aLen = a.length;
		int bLen = b.length;

		byte[] c = new byte[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static short[] concat(short[] a, short[] b) {
		int aLen = a.length;
		int bLen = b.length;

		short[] c = new short[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static char[] concat(char[] a, char[] b) {
		int aLen = a.length;
		int bLen = b.length;

		char[] c = new char[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static int[] concat(int[] a, int[] b) {
		int aLen = a.length;
		int bLen = b.length;

		int[] c = new int[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static long[] concat(long[] a, long[] b) {
		int aLen = a.length;
		int bLen = b.length;

		long[] c = new long[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static float[] concat(float[] a, float[] b) {
		int aLen = a.length;
		int bLen = b.length;

		float[] c = new float[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static double[] concat(double[] a, double[] b) {
		int aLen = a.length;
		int bLen = b.length;

		double[] c = new double[aLen + bLen];
		System.arraycopy(a, 0, c, 0, aLen);
		System.arraycopy(b, 0, c, aLen, bLen);

		return c;
	}

	public static byte[] subArray(byte[] array, int start, int end) {
		if (start < 0 || end < 0) {
			throw new IllegalArgumentException("Invalid start or end! Start: " + start + "  End: " + end);
		}
		int newLength = end - start;
		if (newLength < 0)
			throw new IllegalArgumentException(
					"New array length is < 0!  Start: " + start + "  End: " + end + "  New Length: " + newLength);
		byte[] newArray = new byte[newLength];
		System.arraycopy(array, start, newArray, 0, newLength);
		return newArray;
	}

	public static byte[] trimZeros(byte[] data) {
		if ((data == null) || isEmpty(data))
			return new byte[0];

		int beginIndex = 0, endIndex = data.length - 1;
		for (int i = 0; i < data.length; i++) {
			if (data[i] == 0x0)
				beginIndex = i + 1;
			else
				break;
		}
		for (int i = data.length - 1; i >= 0; i--) {
			if (data[i] == 0x0)
				endIndex = i - 1;
			else
				break;
		}

		byte[] result = new byte[endIndex - beginIndex + 1];
		int index = 0;
		for (int i = beginIndex; i <= endIndex; i++, index++)
			result[index] = data[i];

		return result;

	}

	public static byte[] toByteArray(List<Byte> data) {
		byte[] finalArray = new byte[data.size()];
		Iterator<Byte> i = data.iterator();
		int count = 0;
		while (i.hasNext()) {
			finalArray[count] = (byte) i.next();
			count++;
		}
		return finalArray;
	}

	public static boolean isEmpty(byte[] data) {
		if (data == null)
			return true;
		for (int i = 0; i < data.length; i++)
			if (data[i] != 0x0)
				return false;

		return true;
	}

	public static String toBinaryString(byte[] bytes) {
		StringBuilder sb = new StringBuilder();
		sb.append("[");
		for (int i = 0; i < bytes.length; i++) {
			sb.append(StringFormatter.toBinaryString(bytes[i]));
			if (i != bytes.length - 1)
				sb.append(", ");
		}
		sb.append("]");
		return sb.toString();
	}

	public static String toHexString(byte[] a) {
		if (a == null)
			return "null";
		int iMax = a.length - 1;
		if (iMax == -1)
			return "[]";

		StringBuilder b = new StringBuilder();
		b.append('[');
		for (int i = 0;; i++) {
			b.append("0x" + StringFormatter.toHexString(a[i]));
			if (i == iMax)
				return b.append(']').toString();
			b.append(", ");
		}
	}

	public static String toHexString(short[] a) {
		if (a == null)
			return "null";
		int iMax = a.length - 1;
		if (iMax == -1)
			return "[]";

		StringBuilder b = new StringBuilder();
		b.append('[');
		for (int i = 0;; i++) {
			b.append("0x" + StringFormatter.toHexString(a[i]));
			if (i == iMax)
				return b.append(']').toString();
			b.append(", ");
		}
	}

	public static String toHexString(char[] a) {
		if (a == null)
			return "null";
		int iMax = a.length - 1;
		if (iMax == -1)
			return "[]";

		StringBuilder b = new StringBuilder();
		b.append('[');
		for (int i = 0;; i++) {
			b.append("0x" + StringFormatter.toHexString(a[i]));
			if (i == iMax)
				return b.append(']').toString();
			b.append(", ");
		}
	}

	public static String toHexString(int[] a) {
		if (a == null)
			return "null";
		int iMax = a.length - 1;
		if (iMax == -1)
			return "[]";

		StringBuilder b = new StringBuilder();
		b.append('[');
		for (int i = 0;; i++) {
			b.append("0x" + StringFormatter.toHexString(a[i]));
			if (i == iMax)
				return b.append(']').toString();
			b.append(", ");
		}
	}

	public static String toHexString(long[] a) {
		if (a == null)
			return "null";
		int iMax = a.length - 1;
		if (iMax == -1)
			return "[]";

		StringBuilder b = new StringBuilder();
		b.append('[');
		for (int i = 0;; i++) {
			b.append("0x" + StringFormatter.toHexString(a[i]));
			if (i == iMax)
				return b.append(']').toString();
			b.append(", ");
		}
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\ByteArrayPool.java

package com.troy.empireserialization.util;

import java.util.*;

public class ByteArrayPool {

	private static final List<byte[]> avilable = new ArrayList<byte[]>();

	static {
		for (int i = 6; i < 16; i++) {
			int size = (int) Math.pow(2, i);
			for (int j = 0; j < 3; j++) {
				avilable.add(new byte[size]);
			}
		}
	}

	public static byte[] aquire(int minLength) {
		// Binary search
		int low = 0;
		int high = avilable.size() - 1;

		while (low <= high) {
			int mid = (low + high) >>> 1;
			byte[] midVal = avilable.get(mid);
			if (midVal.length < minLength)
				low = mid + 1;
			else {
				avilable.remove(mid);
				sort();
				return midVal;
			}
		}
		byte[] bytes = new byte[minLength];
		avilable.add(bytes);
		sort();
		return bytes;
	}
	
	public static void restore(byte[] bytes) {
		avilable.add(bytes);
		sort();
	}

	private static void sort() {
		avilable.sort(comp);
	}
	
	private static final Comparator<byte[]> comp = new Comparator<byte[]>() {
		@Override
		public int compare(byte[] o1, byte[] o2) {
			return Integer.compare(o1.length, o2.length);
		}
	};

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\ClassHelper.java

package com.troy.empireserialization.util;

import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import com.troy.empireserialization.clazz.ClassData;

import io.github.lukehutch.fastclasspathscanner.FastClasspathScanner;
import io.github.lukehutch.fastclasspathscanner.scanner.ScanResult;

public class ClassHelper {

	private static final HashMap<Class<?>, Boolean> HAS_SUBCLASS_CACHE = new HashMap<Class<?>, Boolean>();
	private static final HashMap<Class<?>, ClassData<?>> CLASS_DATA = new HashMap<Class<?>, ClassData<?>>();
	private static final Object DATA_LOCK = new Object();

	public static <T> ClassData<T> getClassData(Class<T> type) {
		ClassData<T> data = (ClassData<T>) CLASS_DATA.get(type);
		if (data == null) {
			synchronized (DATA_LOCK) {
				data = new ClassData<T>(type);
				CLASS_DATA.put(type, data);
			}
		}
		return data;
	}

	/**
	 * Manually assigns weather or not a class has a subclass
	 * 
	 * @param type
	 *            The class to set the property for
	 * @param hasSubclass
	 *            Weather or not the specified class has subclass
	 */
	public static void setHasSubclass(Class<?> type, boolean hasSubclass) {
		if (Modifier.isFinal(type.getModifiers()))
			throw new IllegalArgumentException("The " + type + " is final, therefore it cannot have a subclass");
		HAS_SUBCLASS_CACHE.put(type, Boolean.valueOf(hasSubclass));
	}

	/**
	 * Returns {@code true} if the specified class has a subclass {@code false}
	 * otherwise.
	 * <p>
	 * This method conducts a classpath search if a cached result for weather or not
	 * this class has a subclass doesnt exist. This can be extremely expensive. This
	 * can be avoided if the user already knows weather or not a class has a
	 * subclass using {@link ClassHelper#setHasSubclass(Class, boolean)}
	 * 
	 * @param type
	 *            The class to search for
	 * @return
	 */
	public static <T> boolean hasSubClass(Class<T> type) {
		Boolean cached = HAS_SUBCLASS_CACHE.get(type);
		if (cached != null)
			return cached.booleanValue();
		boolean hasSubclass = false;
		hasSubclass = parseList(type, findAllSubclassesFast(type));// Search the current directory
		if (!hasSubclass) // Scan the entire classpath if it wasn't found in the current directory
			hasSubclass = parseList(type, findAllSubclassesSlow(type));

		HAS_SUBCLASS_CACHE.put(type, Boolean.valueOf(hasSubclass));
		return hasSubclass;
	}

	private static boolean parseList(Class<?> type, List<String> list) {
		for (String element : list) {
			try {
				Class<?> temp = Class.forName(element);
				if (temp != type && type.isAssignableFrom(temp)) {
					return true;
				}
			} catch (Exception e) {

			}
		}
		return false;

	}

	public static boolean isDataStructure(Class<?> type) {
		// List because is is basically a fancy array.
		return type.isArray() || List.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type);
	}

	public static boolean isPrimitive(Class<?> type) {
		return type.isPrimitive() || type == String.class || type.isArray() || type == Integer.class || type == Long.class || type == Float.class
				|| type == Double.class || type == Short.class || type == Byte.class || type == Character.class || type == Boolean.class
				|| List.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type);
	}

	private static final Object fastLock = new Object(), slowLock = new Object();
	private static ScanResult fast, slow;
	private static CurrentThreadExecutorService service = new CurrentThreadExecutorService();

	public static List<String> findAllSubclassesFast(Class<?> clazz) {
		if (fast == null) {
			synchronized (fastLock) {
				fast = new FastClasspathScanner(clazz.getPackage().getName()).scan(service, 1);
			}
		}
		return fast.getNamesOfSubclassesOf(clazz.getName());
	}

	public static List<String> findAllSubclassesSlow(Class<?> clazz) {
		if (slow == null) {
			synchronized (slowLock) {
				slow = new FastClasspathScanner().scan();// Scan the entire classpath
			}
		}
		return slow.getNamesOfSubclassesOf(clazz.getName());
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\CurrentThreadExecutorService.java

package com.troy.empireserialization.util;

import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.TimeUnit;

public class CurrentThreadExecutorService extends AbstractExecutorService {

	@Override
	public void shutdown() {
		
	}

	@Override
	public List<Runnable> shutdownNow() {
		return null;
	}

	@Override
	public boolean isShutdown() {
		return true;
	}

	@Override
	public boolean isTerminated() {
		return true;
	}

	@Override
	public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
		return true;
	}

	@Override
	public void execute(Runnable command) {
		command.run();
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\DataUtil.java

package com.troy.empireserialization.util;

import com.troy.empireserialization.EmpireOutput;

public class DataUtil {
	public static void write(EmpireOutput output, Object[] data) {
		
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\InternalLog.java

package com.troy.empireserialization.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

public class InternalLog {

	private static final ByteArrayOutputStream streamImpl = new ByteArrayOutputStream(1024);
	private static final OutputStreamWriter stream = new OutputStreamWriter(streamImpl);
	
	private static final List<PrintStream> otherStreams = new ArrayList<PrintStream>();
	
	public static void addStream(PrintStream stream) {
		otherStreams.add(stream);
	}

	public static void dumpLogTo(PrintStream stream) {
		try {
			InternalLog.stream.flush();
			stream.write(streamImpl.toByteArray());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static void clear() {
		streamImpl.reset();
	}
	
	public static void dumpToError() {
		dumpLogTo(System.err);
	}
	
	public static void dumpToOut() {
		dumpLogTo(System.out);
	}
	
	/**
	 * Writes a string to the internal log along with a newline
	 * 
	 * @param s
	 *            The string to write
	 */
	public static void log(String s) {
		try {
			stream.write(s);
			stream.write('\n');
			for(PrintStream stream : otherStreams) {
				stream.println(s);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Writes a string to the internal log without writing a newline
	 * 
	 * @param s
	 *            The string to write
	 */
	public static void print(String s) {
		try {
			stream.write(s);
			for(PrintStream stream : otherStreams) {
				stream.print(s);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Writes a string to the internal log along with a newline
	 * 
	 * @param s
	 *            The string to write
	 */
	public static void log(Object o) {
		log(String.valueOf(o));
	}

	/**
	 * Writes a string to the internal log without writing a newline
	 * 
	 * @param s
	 *            The string to write
	 */
	public static void print(Object s) {
		print(String.valueOf(s));
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\MiscUtil.java

package com.troy.empireserialization.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.nio.Buffer;
import java.nio.ByteOrder;
import java.util.*;

import sun.misc.Unsafe;

public class MiscUtil {

	private static final Unsafe unsafe = retriveUnsafe();

	private static final String UNSAFE_CLASS = "sun.misc.Unsafe", DISABLE_UNSAFE_ARG = "DisableUnsafe";

	private static final long NIO_BUFFER_ADDRESS_OFFSET = findBufferAddress();

	private static final Field STRING_VALUE;
	private static final Constructor<String> STRING_CHAR_CONSTRUCTOR;

	private static final Map<Class<?>, Integer> TYPE_SIZES = new HashMap<Class<?>, Integer>() {
		public Integer get(Object key) {
			Class<?> type = (Class<?>) key;
			if (!type.isPrimitive()) {
				return Unsafe.ADDRESS_SIZE;
			}
			return super.get(key);
		};
	};

	static {
		Class<?>[] types = { Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class,
				Character.class };
		for (Class<?> type : types) {
			try {
				Field field = type.getField("BYTES");
				int bytes = field.getInt(null);
				TYPE_SIZES.put((Class<?>) type.getField("TYPE").get(null), bytes);
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}

		Field f = null;
		for (Field field : String.class.getDeclaredFields()) {
			if (field.getType() == char[].class) {
				f = field;
				break;
			}
		}
		if (f == null)
			throw new Error("Unable to locate char[] inside the string class");
		f.setAccessible(true);
		STRING_VALUE = f;

		Constructor<String> c = null;
		for (Constructor<?> constructor : String.class.getDeclaredConstructors()) {
			if (constructor.getParameterCount() == 2 && constructor.getParameterTypes()[0] == char[].class) {
				c = (Constructor<String>) constructor;
				break;
			}
		}
		if (c == null)
			throw new Error("Unable to locate the String(char[]) constructor");
		c.setAccessible(true);
		STRING_CHAR_CONSTRUCTOR = c;

	}

	public static int sizeof(Class<?> type) {
		return TYPE_SIZES.get(type);
	}

	public static boolean isBigEndian() {
		return ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
	}

	public static boolean isLittleEndian() {
		return ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;
	}

	public static Class<?> getGenericType(Object obj) {
		return (Class<?>) ((ParameterizedType) obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
	}

	public static boolean isClassLoaded(String binaryName) {
		try {
			Method m = ClassLoader.class.getDeclaredMethod("findLoadedClass", new Class[] { String.class });
			m.setAccessible(true);

			return m.invoke(MiscUtil.class.getClassLoader(), binaryName) != null;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Returns an Enum object representing the enum declared in class {@code class} with the ordinal {@code ordinal}
	 * 
	 * @param clazz
	 *            The class to look in. Must be an enum class
	 * @param ordinal
	 *            The ordinal of the enum to look for
	 * @return the enum declared in class {@code class} with the ordinal {@code ordinal} {@link Enum#ordinal()}<br>
	 *         {@link Enum}
	 */
	public static <T> T getEnum(Class<T> clazz, int ordinal) {
		assert clazz.isEnum();
		try {
			Method m = clazz.getDeclaredMethod("values");
			Object values = m.invoke(null);
			Enum<?>[] thing = (Enum<?>[]) values;
			for (Enum<?> e : thing) {
				if (e.ordinal() == ordinal)
					return (T) e;
			}
		} catch (NoSuchMethodException e) {
			throw new IllegalArgumentException(clazz + " is not an enum!");
		} catch (SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			throw new RuntimeException(e);
		}
		return null;

	}

	/**
	 * Returns {@code true} if the class a contains b in the hierarchy
	 * 
	 * @param baseClass
	 *            The class's hierarchy to use
	 * @param lookFor
	 *            The class to compare to
	 * @return {@code true} if the class a contains b in a superclass, otherwise false
	 */
	public static boolean classSharesSuperClassOrInterface(Class<?> baseClass, Class<?> lookFor) {
		if (baseClass == lookFor)
			return true;
		Class<?> origionalBaseClass = baseClass;
		while ((baseClass = baseClass.getSuperclass()) != null)
			if (baseClass == lookFor)
				return true;
		return classImplementsInterface(origionalBaseClass, lookFor);
	}

	public static boolean classImplementsInterface(Class<?> baseClass, Class<?> lookFor) {
		for (Class<?> interfac : baseClass.getInterfaces()) {
			if (interfac == lookFor)
				return true;
			if (classImplementsInterface(interfac, lookFor))
				return true;
		}
		return false;
	}

	/**
	 * Returns the memory address of the given object
	 * 
	 * @param obj
	 *            The object to locate the address of
	 * @return The memory address of Object obj
	 */
	public static long memoryAddress(Object obj) {
		if (unsafe == null)
			throw new IllegalStateException("Unsafe is NOT unsupported!! So the memory address cannot be retrived!!!");
		Object helperArray[] = new Object[] { obj };
		long baseOffset = unsafe.arrayBaseOffset(Object[].class);
		long addressOfObject = unsafe.getLong(helperArray, baseOffset);
		return addressOfObject;
	}

	/**
	 * Returns JVM type signature for given class.
	 */
	public static String getClassSignature(Class<?> cl) {
		StringBuilder sbuf = new StringBuilder();
		while (cl.isArray()) {
			sbuf.append('[');
			cl = cl.getComponentType();
		}
		if (cl.isPrimitive()) {
			if (cl == Integer.TYPE) {
				sbuf.append('I');
			} else if (cl == Byte.TYPE) {
				sbuf.append('B');
			} else if (cl == Long.TYPE) {
				sbuf.append('J');
			} else if (cl == Float.TYPE) {
				sbuf.append('F');
			} else if (cl == Double.TYPE) {
				sbuf.append('D');
			} else if (cl == Short.TYPE) {
				sbuf.append('S');
			} else if (cl == Character.TYPE) {
				sbuf.append('C');
			} else if (cl == Boolean.TYPE) {
				sbuf.append('Z');
			} else if (cl == Void.TYPE) {
				sbuf.append('V');
			} else {
				throw new InternalError();
			}
		} else {
			sbuf.append('L' + cl.getName().replace('.', '/') + ';');
		}
		return sbuf.toString();
	}

	/**
	 * Gets the class for a signature (only handles one signature at a time)
	 * 
	 * @param signature
	 *            The signature
	 * @return The class representing the specified signature
	 * @throws ClassNotFoundException
	 */
	public static Class<?> getClassFromSignature(String signature) throws ClassNotFoundException {
		if (signature.isEmpty())
			throw new IllegalArgumentException("Signature cannot be empty!");
		if (signature.charAt(0) == '[') {
			if (signature.contains("L"))
				return Array.newInstance(Class.forName(signature.substring(1, signature.length()).replace("/", ".")), 1)
						.getClass();
			int arrayDimensions = signature.lastIndexOf('[') + 1;
			char type = signature.charAt(signature.length() - 1);
			if (arrayDimensions == 1) {
				if (type == 'B')
					return byte[].class;
				if (type == 'S')
					return short[].class;
				if (type == 'C')
					return char[].class;
				if (type == 'I')
					return int[].class;
				if (type == 'J')
					return long[].class;
				if (type == 'F')
					return float[].class;
				if (type == 'D')
					return double[].class;
				if (type == 'Z')
					return boolean[].class;
			} else if (arrayDimensions == 2) {
				if (type == 'B')
					return byte[][].class;
				if (type == 'S')
					return short[][].class;
				if (type == 'C')
					return char[][].class;
				if (type == 'I')
					return int[][].class;
				if (type == 'J')
					return long[][].class;
				if (type == 'F')
					return float[][].class;
				if (type == 'D')
					return double[][].class;
				if (type == 'Z')
					return boolean[][].class;
			} else if (arrayDimensions == 3) {
				if (type == 'B')
					return byte[][][].class;
				if (type == 'S')
					return short[][][].class;
				if (type == 'C')
					return char[][][].class;
				if (type == 'I')
					return int[][][].class;
				if (type == 'J')
					return long[][][].class;
				if (type == 'F')
					return float[][][].class;
				if (type == 'D')
					return double[][][].class;
				if (type == 'Z')
					return boolean[][][].class;
			} else {
				throw new ClassNotFoundException(
						"MiscUtil cannot find primitive array classes with more that 3 dimensions");
			}

		} else {
			if (signature.contains("L"))
				return Class.forName(signature.substring(1, signature.length() - 1).replace("/", "."));
			char type = signature.charAt(0);
			if (type == 'B')
				return byte.class;
			if (type == 'S')
				return short.class;
			if (type == 'C')
				return char.class;
			if (type == 'I')
				return int.class;
			if (type == 'J')
				return long.class;
			if (type == 'F')
				return float.class;
			if (type == 'D')
				return double.class;
			if (type == 'Z')
				return boolean.class;
			if (type == 'V')
				return void.class;
		}
		return null;
	}

	private static Unsafe retriveUnsafe() {
		String disableUnsafe = System.getProperty(DISABLE_UNSAFE_ARG, "false");
		if (disableUnsafe.equals("true") || disableUnsafe.equals("t") || disableUnsafe.equals("1")) {
			InternalLog.log(UNSAFE_CLASS + " Is diaabled because of the vm arg " + DISABLE_UNSAFE_ARG + " was set to \""
					+ System.getProperty(DISABLE_UNSAFE_ARG) + "\"");
			return null;
		}
		try {
			Class<?> unsafeClass = null;
			try {
				unsafeClass = Class.forName(UNSAFE_CLASS);
			} catch (ClassNotFoundException e) {
				InternalLog.log("Unable to find Unsafe Class \"" + UNSAFE_CLASS + "\"");
				return null;
			}
			Field[] fields = unsafeClass.getDeclaredFields();
			for (Field field : fields) {
				try {
					field.setAccessible(true);
					Unsafe cast = (Unsafe) field.get(null);
					InternalLog
							.log("Successfully retrived Unsafe instance. Avilable for use with MiscUtil.getUnsafe()");
					return cast;
				} catch (ClassCastException e) {
					// Ignore, there might be other static fields
				}
			}
		} catch (Exception e) {
		}
		InternalLog.log("Failed to retrive Unsafe instance");
		return null;
	}

	public static String getStackTrace(Throwable error) {
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		error.printStackTrace(pw);
		return sw.toString();
	}

	public static String epochToString(long time) {
		return new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new java.util.Date(time));
	}

	public static boolean isUnsafeSupported() {
		return unsafe != null;
	}

	public static Unsafe getUnsafe() {
		if (unsafe == null)
			throw new IllegalStateException("Unsafe is not supported");
		return unsafe;
	}

	private MiscUtil() {

	}

	public static String getExtension(String name) {
		int index = name.lastIndexOf('.');
		if (index == -1)
			return null;
		return name.substring(index + 1);
	}

	/**
	 * Attempts to parse a string into an int using {@link Integer#parseInt(String, int)}. If the string cannot be
	 * parsed, the error message along with the unparsable string will be printed to {@link System#err} and the default
	 * value will be returned. Otherwise string's parsed int value will be returned
	 * 
	 * @param str
	 *            The string to parse
	 * @param base
	 *            the base to parse the string into
	 * @param errorMessage
	 *            The error message to be printed if parsing fails
	 * @param defaultValue
	 *            The default value to be returned if parsing fails
	 * @return The parsed string, or the default value if parsing fails
	 */
	public static int getIntOrDefaultValue(String str, int base, String errorMessage, int defaultValue) {
		try {
			return Integer.parseInt(str);
		} catch (Exception e) {
			System.err.println(errorMessage + " \"" + str + "\"");
		}
		return defaultValue;
	}

	/**
	 * Attempts to parse a string into an int using {@link Integer#parseInt(String, int)}. If the string cannot be
	 * parsed, then the runnable will be run and the default value will be returned. Otherwise string's parsed integer
	 * value will be returned
	 * 
	 * @param str
	 *            The string to parse
	 * @param base
	 *            the base to parse the string into
	 * @param runnable
	 *            The runnable to run if parsing fails
	 * @param defaultValue
	 *            The default value to be returned if parsing fails
	 * @return The parsed string, or the default value if parsing fails
	 */
	public static int getIntOrRunnableAndDefValue(String str, int base, Runnable runnable, int defaultValue) {
		try {
			return Integer.parseInt(str);
		} catch (Exception e) {
			runnable.run();
		}
		return defaultValue;
	}

	/**
	 * Attempts to parse a string into an int using {@link Integer#parseInt(String)}. If the string cannot be parsed,
	 * the error message along with the unparsable string will be printed to {@link System#err} and the default value
	 * will be returned. Otherwise string's parsed int value will be returned.<br>
	 * This is equivalent to calling {@code MiscUtil.getIntOrDefaultValue(str, 10, errorMessage, defaultValue)}
	 * 
	 * @param str
	 *            The string to parse
	 * @param errorMessage
	 *            The error message to be printed if parsing fails
	 * @param defaultValue
	 *            The default value to be returned if parsing fails
	 * @return The parsed string, or the default value if parsing fails
	 */
	public static int getIntOrDefaultValue(String str, String errorMessage, int defaultValue) {
		return getIntOrDefaultValue(str, 10, errorMessage, defaultValue);
	}

	/**
	 * Attempts to parse a string into an int using {@link Integer#parseInt(String, int)}. If the string cannot be
	 * parsed, then the runnable will be run and the default value will be returned. Otherwise string's parsed integer
	 * value will be returned
	 * 
	 * @param str
	 *            The string to parse
	 * @param errorMessage
	 *            The error message to be printed if parsing fails
	 * @param defaultValue
	 *            The default value to be returned if parsing fails
	 * @return The parsed string, or the default value if parsing fails
	 */
	public static int getIntOrRunnableAndDefValue(String str, Runnable runnable, int defaultValue) {
		return getIntOrRunnableAndDefValue(str, 10, runnable, defaultValue);
	}

	public static final java.lang.reflect.Field getDeclaredField(Class<?> root, String fieldName)
			throws NoSuchFieldException {
		Class<?> type = root;
		do {
			try {
				java.lang.reflect.Field field = type.getDeclaredField(fieldName);
				field.setAccessible(true);
				return field;
			} catch (NoSuchFieldException e) {
				type = type.getSuperclass();
			} catch (SecurityException e) {
				type = type.getSuperclass();
			}
		} while (type != null);
		throw new NoSuchFieldException(
				fieldName + " does not exist in " + root.getName() + " or any of its superclasses.");
	}

	public static final long address(Buffer buffer) {
		if (!buffer.isDirect() || unsafe == null) {
			throw new UnsupportedOperationException("Unable to get Nio Buffer address! "
					+ (unsafe == null ? "Unsafe is not supported" : "Buffer is not direct!"));
		}
		return unsafe.getLong(buffer, NIO_BUFFER_ADDRESS_OFFSET);
	}

	private static long findBufferAddress() {
		try {
			return unsafe.objectFieldOffset(getDeclaredField(Buffer.class, "address"));
		} catch (Exception e) {
			throw new UnsupportedOperationException("Could not detect ByteBuffer.address offset", e);
		}
	}

	/**
	 * Creates a new instance of the specified constructor by invoking a constructor with garbage arguments
	 * 
	 * @param clazz
	 *            The class to instantiate
	 * @return A new instance of class
	 * @throws RuntimeException
	 *             If the class cannot be instantiated
	 */
	public static <T> T newInstanceUsingAConstructor(Class<T> clazz) throws RuntimeException {
		try {
			Constructor<T> bestOne = null;
			for (Constructor<?> c : clazz.getDeclaredConstructors()) {
				if (bestOne == null || c.getParameterCount() < bestOne.getParameterCount()) {
					bestOne = (Constructor<T>) c;
				}
			}
			List<Object> args = new ArrayList<Object>();
			for (Class<?> type : bestOne.getParameterTypes()) {
				if (type.isPrimitive()) {
					Object obj;
					if (type == byte.class) {
						obj = Byte.valueOf((byte) 0);
					} else if (type == short.class) {
						obj = Short.valueOf((short) 0);
					} else if (type == char.class) {
						obj = Character.valueOf((char) 0);
					} else if (type == int.class) {
						obj = Integer.valueOf(0);
					} else if (type == long.class) {
						obj = Long.valueOf(0L);
					} else if (type == float.class) {
						obj = Float.valueOf(0.0f);
					} else if (type == double.class) {
						obj = Double.valueOf(0.0);
					} else if (type == boolean.class) {
						obj = Boolean.FALSE;
					} else {
						throw new RuntimeException("Unknown primative type " + type + "!!!!!!!!!!!");
					}
					args.add(obj);
				} else {
					args.add(null);
				}
			}
			return bestOne.newInstance(args.toArray());
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

	}

	/**
	 * Calls a method with default values for reach type (0, false, null, etc.)
	 * 
	 * @param method
	 *            The method to call
	 * @param instance
	 *            The instance to invoke the method on
	 * @return The value returned from the method
	 * @throws RuntimeException
	 *             If an exception is thrown
	 */
	public static Object callMethod(Method method, Object instance) throws RuntimeException {
		try {
			List<Object> args = new ArrayList<Object>();
			for (Class<?> type : method.getParameterTypes()) {
				if (type.isPrimitive()) {
					Object obj;
					if (type == byte.class) {
						obj = Byte.valueOf((byte) 0);
					} else if (type == short.class) {
						obj = Short.valueOf((short) 0);
					} else if (type == char.class) {
						obj = Character.valueOf((char) 0);
					} else if (type == int.class) {
						obj = Integer.valueOf(0);
					} else if (type == long.class) {
						obj = Long.valueOf(0L);
					} else if (type == float.class) {
						obj = Float.valueOf(0.0f);
					} else if (type == double.class) {
						obj = Double.valueOf(0.0);
					} else if (type == boolean.class) {
						obj = Boolean.FALSE;
					} else {
						throw new RuntimeException("Unknown primative type " + type + "!!!!!!!!!!!");
					}
					args.add(obj);
				} else {
					args.add(null);
				}
			}
			return method.invoke(instance, args.toArray());
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

	}

	public static void pause(long nanos) throws RuntimeException {
		nanos += System.nanoTime();
		while (System.nanoTime() < nanos) {

		}
	}

	public static void pauseLarge(long nanos, long seconds) throws RuntimeException {
		try {
			Thread.sleep(Math.max((seconds * 1000L) - 1L, 0L));
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}
		pause(nanos);
	}

	public static boolean isWrapperClass(Class<?> clazz) {
		// format:off
		return clazz == Byte.class || clazz == Short.class || clazz == Character.class || clazz == Integer.class
				|| clazz == Long.class || clazz == Float.class || clazz == Double.class || clazz == Boolean.class;
	}

	public static char getPrimitiveClassSignature(Class<?> clazz) {
		if (clazz == Byte.class || clazz == byte.class) {
			return 'B';
		} else if (clazz == Short.class || clazz == short.class) {
			return 'S';
		} else if (clazz == Integer.class || clazz == int.class) {
			return 'I';
		} else if (clazz == Long.class || clazz == long.class) {
			return 'J';
		} else if (clazz == Float.class || clazz == float.class) {
			return 'F';
		} else if (clazz == Double.class || clazz == double.class) {
			return 'D';
		} else if (clazz == Character.class || clazz == char.class) {
			return 'C';
		} else if (clazz == Boolean.class || clazz == boolean.class) {
			return 'Z';
		} else if (clazz == Void.class || clazz == void.class) {
			return 'V';
		} else if (clazz == String.class) {
			return 'R';
		} else {
			throw new IllegalArgumentException(clazz + " is not primative");
		}
		// format:on
	}

	public static char[] getCharsFast(String str) {
		if (str.length() > 1000) {
			try {
				return (char[]) STRING_VALUE.get(str);
			} catch (IllegalArgumentException | IllegalAccessException e) {
				e.printStackTrace();
			}
		}
		return str.toCharArray();
	}

	public static String createString(char[] chars) {
		try {
			return STRING_CHAR_CONSTRUCTOR.newInstance(chars, true);
		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
			throw new RuntimeException(e);
		}
	}

	public static void init() {
		// Nothing. Forces static inatilizer to be called if it hasnt already
	}

	public static long clamp(long min, long max, long value) {
		return Math.max(Math.min(value, max), min);
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\NativeUtils.java

package com.troy.empireserialization.util;

import java.lang.reflect.*;
import java.nio.*;

import com.troy.empireserialization.nativelibrary.*;

/**
 * A class that contains utilities for using native code as well as all native methods
 * @author Troy Neubauer
 *
 */
public class NativeUtils {

	private static final int ERROR_CODE_OFFSET = 0;// The error code is one byte
	private static final int INVALID_CHARACTER_OFFSET = 1;// Invalid character is 2 bytes
	private static final int INVALID_CHARACTER_INDEX_OFFSET = 3;// Represents what index the invalid character was at 4
																// bytes

	public static final int DEFAULT_NATIVE_SIZE = 4096;

	public static final boolean IS_64_BIT = System.getProperty("sun.arch.data.model").equals("64");

	// Small structure used for returning string coding errors from native code
	/*
	 * Composed like so: struct info{ jbyte code; jchar badChar; jint index; };
	 */
	private static final ThreadLocal<ByteBuffer> NATIVE_RETURNS = new ThreadLocal<ByteBuffer>() {
		protected ByteBuffer initialValue() {
			return ByteBuffer.allocateDirect(8).order(ByteOrder.nativeOrder());
		};
	};

	static {
		MiscUtil.init();
		LibraryProvider.loadLibrary();
		NATIVE_RETURNS.get();
		InternalLog.log("Beginning to link native methods in Native Utils by calling them");
		long start = System.nanoTime();
		int count = 0;
		// Call all the static native methods in this class to link them to the native
		// code so calls will be faster later
		for (Method method : NativeUtils.class.getDeclaredMethods()) {
			int mods = method.getModifiers();
			if (Modifier.isStatic(mods) && Modifier.isNative(mods) && Modifier.isPublic(mods)) {
				MiscUtil.callMethod(method, null);
				count++;
			}
		}
		long end = System.nanoTime();
		InternalLog.log("Called " + count + " methods in " + (end - start) / 1000000.0 + " milliseconds");
	}

	public static boolean NATIVES_ENABLED = true;

	// Always use native
	public static final int MIN_NATIVE_THRESHOLD = 0;

	public static byte getErrorCode() {
		return NATIVE_RETURNS.get().get(ERROR_CODE_OFFSET);
	}

	public static char getInvalidChar() {
		return NATIVE_RETURNS.get().getChar(INVALID_CHARACTER_OFFSET);
	}

	public static int getInvalidCharIndex() {
		return NATIVE_RETURNS.get().getInt(INVALID_CHARACTER_INDEX_OFFSET);
	}

	public static long getAddress() {
		return MiscUtil.address(NATIVE_RETURNS.get());
	}

	public static void clearError() {
		NATIVE_RETURNS.get().put(ERROR_CODE_OFFSET, (byte) 0);
		NATIVE_RETURNS.get().putChar(INVALID_CHARACTER_OFFSET, (char) 0);
		NATIVE_RETURNS.get().putInt(INVALID_CHARACTER_INDEX_OFFSET, -1);
	}

	public static void init() {
	}

	// Copies data from a primitive array to a byte array. The byte array must be at
	// least bytes long
	public static native int shortsToBytes(byte[] dest, short[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int intsToBytes(byte[] dest, int[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int longsToBytes(byte[] dest, long[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int floatsToBytes(byte[] dest, float[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int doublesToBytes(byte[] dest, double[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int charsToBytes(byte[] dest, char[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int booleansToBytes(byte[] dest, boolean[] src, int srcOffset, int destOffset, int elements, boolean swapEndianess);

	public static native int booleansToBytesCompact(byte[] dest, boolean[] src, int srcOffset, int destOffset, int elements);

	// From array to native memory
	public static int bytesToNative(long dest, byte[] src, int offset, int elements) {
		return bytesToNative(dest, src, offset, elements, false);
	}

	private static native int bytesToNative(long dest, byte[] src, int offset, int elements, boolean swapEndianess);

	public static native int shortsToNative(long dest, short[] src, int offset, int elements, boolean swapEndianess);

	public static native int intsToNative(long dest, int[] src, int offset, int elements, boolean swapEndianess);

	public static native int longsToNative(long dest, long[] src, int offset, int elements, boolean swapEndianess);

	public static native int floatsToNative(long dest, float[] src, int offset, int elements, boolean swapEndianess);

	public static native int doublesToNative(long dest, double[] src, int offset, int elements, boolean swapEndianess);

	public static native int charsToNative(long dest, char[] src, int offset, int elements, boolean swapEndianess);

	public static int booleansToNative(long dest, boolean[] src, int offset, int elements) {
		return booleansToNative(dest, src, offset, elements, false);
	}

	private static native int booleansToNative(long dest, boolean[] src, int offset, int elements, boolean swapEndianess);

	// From native memory to array
	public static int nativeToBytes(byte[] dest, long src, int offset, int elements) {
		return nativeToBytes(dest, src, offset, elements, false);
	}

	private static native int nativeToBytes(byte[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToShorts(short[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToInts(int[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToLongs(long[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToFloats(float[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToDoubles(double[] dest, long src, int offset, int elements, boolean swapEndianess);

	public static native int nativeToChars(char[] dest, long src, int offset, int elements, boolean swapEndianess);

	// Writes primitive arrays to a C file

	public static native long fopen(String file, String access);

	public static native void fclose(long fd);
	
	public static native long remaining(long fd);

	public static native void fflush(long fd);

	public static native void fputc(byte c, long fd);

	public static native byte fgetc(long fd);

	// Single primitive
	public static void byteToFWrite(long fd, byte value) {
		byteToFWrite(fd, value, false);
	}

	private static native void byteToFWrite(long fd, byte value, boolean swapEndianess);

	public static native void shortToFWrite(long fd, short value, boolean swapEndianess);

	public static native void intToFWrite(long fd, int value, boolean swapEndianess);

	public static native void longToFWrite(long fd, long value, boolean swapEndianess);

	public static native void floatToFWrite(long fd, float value, boolean swapEndianess);

	public static native void doubleToFWrite(long fd, double value, boolean swapEndianess);

	public static native void charToFWrite(long fd, char value, boolean swapEndianess);

	public static void booleanToFWrite(long fd, boolean value) {
		booleanToFWrite(fd, value, false);
	}

	// 112901
	private static native void booleanToFWrite(long fd, boolean value, boolean swapEndianess);

	// Arrays

	public static int bytesToFWrite(long fd, byte[] srcJ, int srcOffset, int elements) {
		return bytesToFWrite(fd, srcJ, srcOffset, elements, false);
	}

	private static native int bytesToFWrite(long fd, byte[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int shortsToFWrite(long fd, short[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int intsToFWrite(long fd, int[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int longsToFWrite(long fd, long[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int floatsToFWrite(long fd, float[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int doublesToFWrite(long fd, double[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int charsToFWrite(long fd, char[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static int booleansToFWrite(long fd, boolean[] srcJ, int srcOffset, int elements) {
		return booleansToFWrite(fd, srcJ, srcOffset, elements, false);
	}

	private static native int booleansToFWrite(long fd, boolean[] srcJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int nativeToFWrite(long fd, long src, long bytes);

	// For native output

	public static void byteToNative(long address, byte value) {
		byteToNative(address, value, false);
	}

	private static native void byteToNative(long address, byte value, boolean swapEndianness);

	public static native void shortToNative(long address, short value, boolean swapEndianness);

	public static native void intToNative(long address, int value, boolean swapEndianness);

	public static native void longToNative(long address, long value, boolean swapEndianness);

	public static native void floatToNative(long address, float value, boolean swapEndianness);

	public static native void doubleToNative(long address, double value, boolean swapEndianness);

	public static native void charToNative(long address, char value, boolean swapEndianness);

	public static void booleanToNative(long address, boolean value) {
		booleanToNative(address, value, false);
	}

	private static native void booleanToNative(long address, boolean value, boolean swapEndianness);

	// For VLE. Returns the number of bytes written to address
	public static native int shortToVLENative(long address, short value);

	public static native int intToVLENative(long address, int value);

	public static native int longToVLENative(long address, long value);

	// Single primitive
	public static byte fReadToByte(long fd) {
		return fReadToByte(fd, false);
	}

	private static native byte fReadToByte(long fd, boolean swapEndianess);

	public static native short fReadToShort(long fd, boolean swapEndianess);

	public static native int fReadToInt(long fd, boolean swapEndianess);

	public static native long fReadToLong(long fd, boolean swapEndianess);

	public static native float fReadToFloat(long fd, boolean swapEndianess);

	public static native double fReadToDouble(long fd, boolean swapEndianess);

	public static native char fReadToChar(long fd, boolean swapEndianess);

	public static boolean fReadToBoolean(long fd) {
		return fReadToBoolean(fd, false);
	}

	private static native boolean fReadToBoolean(long fd, boolean swapEndianess);

	public static int fReadToBytes(long fd, byte[] destJ, int srcOffset, int elements) {
		return fReadToBytes(fd, destJ, srcOffset, elements, false);
	}

	private static native int fReadToBytes(long fd, byte[] destJ, int destOffset, int elements, boolean swapEndianess);

	public static native int fReadToShorts(long fd, short[] destJ, int destOffset, int elements, boolean swapEndianess);

	public static native int fReadToInts(long fd, int[] destJ, int destOffsett, int elements, boolean swapEndianess);

	public static native int fReadToLongs(long fd, long[] destJ, int srcOffset, int elements, boolean swapEndianess);

	public static native int fReadToFloats(long fd, float[] destJ, int destOffset, int elements, boolean swapEndianess);

	public static native int fReadToDoubles(long fd, double[] destJ, int destOffset, int elements, boolean swapEndianess);

	public static native int fReadToChars(long fd, char[] destJ, int destOffset, int elements, boolean swapEndianess);

	private static native int fReadToBooleans(long fd, boolean[] destJ, int destOffset, int elements, boolean swapEndianess);

	public static int fReadToBooleans(long fd, boolean[] destJ, int destOffset, int elements) {
		return fReadToBooleans(fd, destJ, destOffset, elements, false);
	}

	public static native int fReadToNative(long fd, long destJ, long bytes);


	/**
	 * Copies n bytes from the source address to the destination address<br>
	 * Both {@code dest} and {@code src} pointers are <b>NOT</b> checked for
	 * validity! If they are null or point to memory that cannot be read, the Java
	 * Virtual Machine will terminate with a memory access violation!!!
	 * 
	 * @param dest
	 *            A pointer to copy n bytes to
	 * @param src
	 *            A pointer to copy n bytes from
	 * @param bytes
	 *            The number of bytes to copy
	 */
	public static native void memcpy(long dest, long src, long bytes);

	public static native byte[] ngetBuffer(long address, int capacity);

	public static void throwByteIndexOutOfBounds() {
		throw new RuntimeException("Java byte array cannot hold all of the elements! Switch to a native alternative!");
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\Outputs.java

package com.troy.empireserialization.util;

import java.io.File;
import java.nio.file.Path;

import com.troy.empireserialization.io.out.*;

public class Outputs {

	public Outputs() {
	}
	
	public static Output newFileOutput(Path path) {
		return newFileOutput(path.toAbsolutePath().toString());
	}
	
	public static Output newFileOutput(File file) {
		return newFileOutput(file.getPath());
	}
	
	public static Output newFileOutput(String file) {
		return new NativeFileOutput(file);
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\ReflectionUtils.java

package com.troy.empireserialization.util;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class ReflectionUtils {
	private static final Method BIG_DOUBLE_INFLATED;
	private static final Field ARRAY_LIST_DATA, ARRAY_LIST_SIZE;

	static {
		Method inflated = null;
		Field data = null, size = null;
		try {
			inflated = BigDecimal.class.getDeclaredMethod("inflated");
		} catch (NoSuchMethodException | SecurityException e) {
			throw new Error();
		}
		for (Field field : ArrayList.class.getDeclaredFields()) {
			if (field.getType().isArray() && field.getName().equals("elementData")) {
				data = field;
			}
			if (field.getName().equals("size") && field.getType().isPrimitive()) {
				size = field;

			}
		}

		BIG_DOUBLE_INFLATED = inflated;
		ARRAY_LIST_DATA = data;
		ARRAY_LIST_SIZE = size;
		Method accessibleObjMethod;
		try {
			accessibleObjMethod = AccessibleObject.class.getDeclaredMethod("setAccessible", boolean.class);
		} catch (NoSuchMethodException | SecurityException e1) {
			throw new RuntimeException(e1);
		}

		// Reflection code that ensures all reflection related final static fields can
		// be accessed without worry
		// Works by calling the setAccessible method on each static field
		for (Field reflectionThing : ReflectionUtils.class.getDeclaredFields()) {
			try {
				int mods = reflectionThing.getModifiers();
				Object field = reflectionThing.get(null);
				if (Modifier.isStatic(mods) && Modifier.isFinal(mods) && field instanceof AccessibleObject) {
					// Lets us call the method
					accessibleObjMethod.setAccessible(true);
					// Sets the calls the method's of field's setAccessible method so that we can
					// access them
					accessibleObjMethod.invoke(field, true);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);

			}
		}

	}

	public static BigInteger getBigInteger(BigDecimal bigDecimal) {
		try {
			return (BigInteger) BIG_DOUBLE_INFLATED.invoke(bigDecimal);
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			throw new RuntimeException(e);
		}
	}

	public static void setData(ArrayList<?> list, Object[] data) {
		try {
			ARRAY_LIST_DATA.set(list, data);
			ARRAY_LIST_SIZE.setInt(list, data.length);
		} catch (IllegalArgumentException | IllegalAccessException e) {
			throw new RuntimeException(e);
		}
	}

	public static Object[] getData(ArrayList<?> list) {
		try {
			return (Object[]) ARRAY_LIST_DATA.get(list);
		} catch (IllegalArgumentException | IllegalAccessException e) {
			throw new RuntimeException(e);
		}
	}

	public static Object[] getListData(List<?> list) {
		if (list instanceof ArrayList) {
			return getData((ArrayList<?>) list);
		} else {
			return list.toArray();
		}
	}

	public static Object[] getSetData(Set<?> set) {
		return set.toArray();
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\SerializationUtils.java

package com.troy.empireserialization.util;

import com.troy.empireserialization.charset.*;
import com.troy.empireserialization.serializers.*;

public class SerializationUtils {

	public static final boolean DEBUG = true;
	public static final boolean CHECK_CHARSET_PROBLEMS = DEBUG;
	public static final int ERROR = -1;
	public static final int OUT_OF_MEMORY = -1, UNSUPPORTED_CHARACTER = -2, INVALID_ARGUMENT = -10;

	public static final boolean DYNAMIC_CLASS_LOADING_ENABLED = false;

	/**
	 * Constructs an array that maps the values of decodingCache to the indices of decodingCache. Used for creating an array that maps custom values
	 * that represent java chars mapped to custom character code values.
	 * 
	 * @param decodingCache The decodingCache to use to create an encoding cache
	 * @return The encoding cache
	 */
	public static int[] constructEncodingFromDecoding(char[] decodingCache) {
		int size = -1;
		for (char c : decodingCache) {
			if (c > size)
				size = c;
		}
		int[] result = new int[size + 1];
		for (int i = 0; i < result.length; i++) {
			result[i] = -1;
		}
		for (int index = 0; index < decodingCache.length; index++) {
			char decodingValue = decodingCache[index];
			result[decodingValue] = index;
		}
		return result;
	}

	public static void init() {
		NativeUtils.init();
		EmpireCharsets.init();
		Serializers.init();
		MiscUtil.init();
	}

}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\StringFormatter.java

package com.troy.empireserialization.util;

/**
 * A class with some useful static methods for formatting {@link String}s
 * 
 * @author Troy Neubauer
 *
 */
public class StringFormatter {

	public final static char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
			'N', 'O', 'p', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'z' };

	private final static String[] binarySizes = { "", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta" };

	public static String insert(String text, int index, String insertText) {
		return text.substring(0, index) + insertText + text.substring(index, text.length());
	}

	public static String replace(String text, int startIndex, int endIndex, String replaceText) {
		return text.substring(0, startIndex) + replaceText + text.substring(endIndex, text.length());
	}

	public static String addCommas(long number) {
		return addCommas(number, 10);
	}

	public static String addCommas(long number, int base) {
		String string = Long.toString(number, base);
		if (string.length() < 4)
			return string;

		char[] chars = new char[((string.length() - 1) / 3) + string.length()];
		int count = 0;
		int indexInString = string.length() - 1;
		for (int i = chars.length - 1; i >= 0; i--) {
			if (count == 3) {
				chars[i] = ',';
				count = 0;
			} else {
				count++;
				chars[i] = string.charAt(indexInString);
				indexInString--;
			}
		}

		return new String(chars);
	}

	public static String addCommas(int number) {
		return addCommas(number, 10);
	}

	public static String addCommas(int number, int base) {
		String string = Integer.toString(number, base);
		if (string.length() < 4)
			return string;

		char[] chars = new char[((string.length() - 1) / 3) + string.length()];
		int count = 0;
		int indexInString = string.length() - 1;
		for (int i = chars.length - 1; i >= 0; i--) {
			if (count == 3) {
				chars[i] = ',';
				count = 0;
			} else {
				count++;
				chars[i] = string.charAt(indexInString);
				indexInString--;
			}
		}

		return new String(chars);
	}

	public static String toHexString(byte b) {
		return "" + DIGITS[b >> 4 & 0x0F] + DIGITS[b >> 0 & 0x0F];
	}

	public static String toHexString(short b) {
		return "" + DIGITS[b >> 12 & 0x0F] + DIGITS[b >> 8 & 0x0F] + DIGITS[b >> 4 & 0x0F] + DIGITS[b >> 0 & 0x0F];
	}

	public static String toHexString(int b) {
		StringBuilder sb = new StringBuilder(8);
		sb.append(DIGITS[b >>> 28 & 0x0F]);
		sb.append(DIGITS[b >>> 24 & 0x0F]);
		sb.append(DIGITS[b >>> 20 & 0x0F]);
		sb.append(DIGITS[b >>> 16 & 0x0F]);
		sb.append(DIGITS[b >>> 12 & 0x0F]);
		sb.append(DIGITS[b >>> 8 & 0x0F]);
		sb.append(DIGITS[b >>> 4 & 0x0F]);
		sb.append(DIGITS[b >>> 0 & 0x0F]);

		return sb.toString();

	}

	public static String toHexString(long b) {
		return "" + DIGITS[(int) (b >>> 60 & 0x0F)] + DIGITS[(int) (b >>> 56 & 0x0F)] + DIGITS[(int) (b >>> 52 & 0x0F)]
				+ DIGITS[(int) (b >>> 48 & 0x0F)] + DIGITS[(int) (b >>> 44 & 0x0F)] + DIGITS[(int) (b >>> 40 & 0x0F)]
				+ DIGITS[(int) (b >>> 36 & 0x0F)] + DIGITS[(int) (b >>> 32 & 0x0F)] + DIGITS[(int) (b >>> 28 & 0x0F)]
				+ DIGITS[(int) (b >>> 24 & 0x0F)] + DIGITS[(int) (b >>> 20 & 0x0F)] + DIGITS[(int) (b >>> 16 & 0x0F)]
				+ DIGITS[(int) (b >>> 12 & 0x0F)] + DIGITS[(int) (b >>> 8 & 0x0F)] + DIGITS[(int) (b >>> 4 & 0x0F)] + DIGITS[(int) (b >>> 0 & 0x0F)];
	}

	public static String toHexString(long l, int digits) {
		StringBuilder sb = new StringBuilder();
		for (int i = digits - 1; i > -1; i--) {
			sb.append(DIGITS[(int) ((l >>> (i * 4)) & 0x0F)]);
		}

		return sb.toString();
	}

	public static String toHexString(float b) {
		return toHexString(Float.floatToIntBits(b));
	}

	public static String toHexString(double b) {
		return toHexString(Double.doubleToLongBits(b));
	}

	/**
	 * Returns a String the represents a byte in binary form<br>
	 * The String will always be 8 characters long<br>
	 * IE: <code>
	 * byte: 16 -> 00010000, byte: 100 -> 01100100,<br> byte: 0 -> 00000000
	 * </code>
	 * 
	 * @param b
	 *            The byte to be molded after
	 * @return The formatted String
	 */
	public static String toBinaryString(byte b) {
		String result = "";
		for (int i = Byte.SIZE - 1; i >= 0; i--) {
			result += ((b >> i) & 0b00000001);
		}
		return result;
	}

	/**
	 * Returns a String the represents a long in binary form<br>
	 * The String will always be 64 characters long<br>
	 * IE: <code>
	 * long: 16 -> 0000...preceding 0's 010000, long: 100 -> 0000...preceding 0's 01100100,<br> long: 0 -> all 0's
	 * </code>
	 * 
	 * @param l
	 *            The long to be molded after
	 * @return The formatted String
	 */
	public static String toBinaryString(long l) {
		String result = "";
		for (int i = Long.SIZE - 1; i >= 0; i--) {
			result += ((l >> i) & 0b1);
		}
		return result;
	}

	public static String toBinaryString(int i) {
		String result = "";
		for (int loopCtr = Integer.SIZE - 1; loopCtr >= 0; loopCtr--) {
			result += ((i >> loopCtr) & 0b1);
		}
		return result;
	}

	public static String toBinaryString(short s) {
		String result = "";
		for (int loopCtr = Integer.SIZE - 1; loopCtr >= 0; loopCtr--) {
			result += ((s >> loopCtr) & 0b1);
		}
		return result;
	}

	public static String toBinaryString(char c) {
		String result = "";
		for (int loopCtr = Integer.SIZE - 1; loopCtr >= 0; loopCtr--) {
			result += ((c >> loopCtr) & 0b1);
		}
		return result;
	}

	public static String toBinaryString(byte[] bytes) {
		return ArrayUtil.toBinaryString(bytes);
	}

	/**
	 * Ensures that a particular String is always a certain length by adding
	 * whitespace at the end or trimming to a shorter length<br>
	 * Because of Javadoc formatting issues, assume that '-' means space<br>
	 * IE: <code> cutToSize("Hi,-i'm-here", 20) ->  "Hi,-i'm-here--------"<br>
	 * cutToSize("This-is-very-interesting,-I-am-a-particularly-long-String,-what-a-waste-of-memory...", 10) -> "This-is-ve"<br> 
	 * </code>
	 * 
	 * @param string
	 *            The string to clip or extend
	 * @param characters
	 *            The amount of characters to clip of extend to
	 * @return The formatted String
	 */
	public static String cutToSize(String string, int characters) {
		char[] chars = new char[characters];
		int length = Math.min(string.length(), characters);
		for (int i = 0; i < length; i++) {
			chars[i] = string.charAt(i);
		}
		for (int i = length; i < characters; i++) {
			chars[i] = ' ';
		}
		return new String(chars);
	}

	/**
	 * Returns a String representing the double where all decimals after
	 * decimalPlaces are clipped.</br>
	 * Example: <code></br>
	 * System.out.println(clip(123.456789091234, 3));
	 * </code></br>
	 * Yields the output "123.456"
	 * 
	 * @param value
	 *            The double value to be clipped
	 * @param decimalPlaces
	 *            The amount of decimal places to keep
	 * @return The formatted String
	 */
	public static String clip(double value, int decimalPlaces) {
		String x = Double.toString(value);
		return x.substring(0, Math.min(x.lastIndexOf(".") + decimalPlaces + 1, x.length() - x.lastIndexOf(".")));
	}

	/**
	 * Returns a String representing the float where all decimals after
	 * decimalPlaces are clipped.</br>
	 * Example: <code></br>
	 * System.out.println(clip(123.456789091234f, 3));
	 * </code></br>
	 * Yields the output "123.456"
	 * 
	 * @param value
	 *            The float value to be clipped
	 * @param decimalPlaces
	 *            The amount of decimal places to keep
	 * @return The formatted String
	 */
	public static String clip(float value, int decimalPlaces) {
		String x = "" + value;
		return x.substring(0, Math.min(x.lastIndexOf(".") + decimalPlaces + 1, x.length() - x.lastIndexOf(".")));
	}

	/**
	 * Returns a string representing the amount of bytes in "Standard data form"
	 * base 1024</br>
	 * Examples:<code> 33 -> "33B", 15360 -> "15K", 583008256 -> "556MB", 3221225472 -> "3TB" etc.</code></br>
	 * This method assumes 1024 bytes to one kilobyte, 1024^2 to one megabyte etc.
	 * 
	 * @param bytes
	 *            The value in bytes to be formatted
	 * @return The formatted string
	 */
	public static String formatBytesShort(long bytes) {
		int unit = 1024;
		if (bytes < unit)
			return bytes + " B";
		int exp = (int) (Math.log(bytes) / Math.log(unit));
		String pre = ("KMGTPEZY").charAt(exp - 1) + "";
		return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);

	}

	/**
	 * Returns a string representing the amount of bytes in "Standard data form"
	 * base 1024</br>
	 * Examples:<code> 33 -> "33B", 15360 -> "15K", 583008256 -> "556MB", 3221225472 -> "3TB" etc.</code></br>
	 * This method assumes 1024 bytes to one kilobyte, 1024^2 to one megabyte etc.
	 * 
	 * @param bytes
	 *            The value in bytes to be formatted
	 * @return The formatted string
	 */
	public static String formatBytesLong(long bytes) {
		int unit = 1024;
		if (bytes < unit)
			return bytes + " bytes";
		int exp = (int) (Math.log(bytes) / Math.log(unit));
		String pre = binarySizes[exp];
		return String.format("%.1f %sbytes", bytes / Math.pow(unit, exp), pre);

	}

	/**
	 * Ensures that the string is all lower case except for the first letter
	 * 
	 * @param string
	 *            The string to capitalize
	 * @return The formatted string
	 */
	public static String capitalizeFirstLetter(String string) {
		int length = string.length();
		if (length == 0)
			return string;

		char[] chars = new char[length];
		chars[0] = Character.toUpperCase(string.charAt(0));
		for (int i = 1; i < length; i++) {
			chars[i] = Character.toLowerCase(string.charAt(i));
		}

		return new String(chars);
	}

	/**
	 * Faster then {@link String#replaceAll(String, String)} and can ignore case
	 * 
	 * @param findtxt
	 *            The text to look for
	 * @param replacetxt
	 *            The text to replace findtxt with
	 * @param str
	 *            The string to search in
	 * @param isCaseInsensitive
	 *            Weather or not expressions in a different case then findtxt should
	 *            be replaced
	 * @return The resulting string
	 */
	public String replaceAll(String findtxt, String replacetxt, String str, boolean isCaseInsensitive) {
		if (str == null)
			return null;

		if (findtxt == null || findtxt.length() == 0)
			return str;

		if (findtxt.length() > str.length())
			return str;

		int counter = 0;
		String thesubstr = "";
		while ((counter < str.length()) && (str.substring(counter).length() >= findtxt.length())) {
			thesubstr = str.substring(counter, counter + findtxt.length());
			if (isCaseInsensitive) {
				if (thesubstr.equalsIgnoreCase(findtxt)) {
					str = str.substring(0, counter) + replacetxt + str.substring(counter + findtxt.length());
					counter += replacetxt.length();
				} else {
					counter++; // No match so move on to the next character from
								// which to check for a findtxt string match.
				}
			} else {
				if (thesubstr.equals(findtxt)) {
					str = str.substring(0, counter) + replacetxt + str.substring(counter + findtxt.length());
					counter += replacetxt.length();
				} else {
					counter++;
				}
			}
		}
		return str;
	}

	public static String toHexString(byte[] a) {
		return ArrayUtil.toHexString(a);
	}

	public static String toHexString(short[] a) {
		return ArrayUtil.toHexString(a);
	}

	public static String toHexString(char[] a) {
		return ArrayUtil.toHexString(a);
	}

	public static String toHexString(int[] a) {
		return ArrayUtil.toHexString(a);
	}

	public static String toHexString(long[] a) {
		return ArrayUtil.toHexString(a);
	}

	// No instances of this class allowed
	private StringFormatter() {
	}

	/**
	 * Appends an s to the end of {@code string} if the value is not one, otherwise
	 * the origional string is returned
	 * 
	 * @param string
	 *            The string to add an s to
	 * @param value
	 *            the value to check
	 * @return {@code string + "s"} if value != 1 else {@code string}
	 */
	public static String plural(String string, long value) {
		return value == 1 ? string : string.concat("s");
	}
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\util\StringInfo.java

package com.troy.empireserialization.util;

import com.troy.empireserialization.charset.*;

public class StringInfo {
	public static final int ALL_ASCII = 0;
	public static final int OTHER = 1;
	
	public EmpireCharset charset;
	public int info;
	
	public StringInfo(int info) {
		this.info = info;
	}
	
	public StringInfo(EmpireCharset charset, int info) {
		this.charset = charset;
		this.info = info;
	}	
}

#File: C:\Empire Serialization\Java\src\main\java\com\troy\empireserialization\Version.java

package com.troy.empireserialization;

import java.util.HashMap;

public class Version {
	public static final int VERSION_1 = 0b0000;
	
	public static final int CURRENT_VERSION = VERSION_1;

	private static final HashMap<Integer, String> VERSION_MAP = new HashMap<Integer, String>();

	static {
		VERSION_MAP.put(VERSION_1, "1");
		//Other versions will go here eventually
	}

	/**
	 * Returns a human readable version string from a version code
	 * 
	 * @param version
	 *            The version code
	 * @return A human readable string representing the version code Ie "1.2"
	 */
	public static String getVersionString(int version) {
		return VERSION_MAP.get(version);
	}
}

#File: C:\Empire Serialization\Java Natives\Serialization.c

#include <jni.h>
#include <stdio.h>
#include <stdlib.h>

#pragma once
#define OUT_OF_MEMORY -1
#define UNSUPPORTED_CHARACTER -2
#define ERROR -1
#define INVALID_ARGUMENT -10

const jbyte FOUR_BIT_ENCODING_CACHE[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 11, 9, 0, 15, -1, 7, 4, -1, -1, 10, 13, 5, 3, -1, -1, 8, 6, 1, 12, -1, 14 };
const jbyte SIX_BIT_ENCODING_CACHE[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 6, -1, -1, -1, -1, 5, -1, -1, -1, -1, 4, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 7, -1, -1, -1, 3, -1, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, 11, -1, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37 };

#define VLE8_INFO_MASK 0b10000000
#define VLE8_DATA_MASK 0b01111111
#define VLE8_HAS_NEXT_BYTE 0b10000000
#define VLE8_DOESNT_HAVE_NEXT_BYTE 0b00000000

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_fflush
(JNIEnv * env, jclass class, jlong fd) {
	if (fd == 0) return INVALID_ARGUMENT;
	fflush((FILE*)fd);
}

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_fputc
(JNIEnv * env, jclass class, jbyte c, jlong fd) {
	if (fd == 0) return INVALID_ARGUMENT;
	fputc(c, (FILE*)fd);
}

JNIEXPORT jbyte JNICALL Java_com_troy_empireserialization_util_NativeUtils_fgetc
(JNIEnv * env, jclass class, jlong fd) {
	if (fd == 0) return INVALID_ARGUMENT;
	return fgetc((FILE*)fd);
}

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_remaining
(JNIEnv * env, jclass class, jlong fd) {
	if (fd == 0) return INVALID_ARGUMENT;
	FILE* file = (FILE*) fd;
	jlong start = ftell(file);
	fseek(file, 0L, SEEK_END);
	jlong remaining = ftell(file);
	fseek(file, start, SEEK_SET);
	return remaining - start;
}

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_fclose
(JNIEnv * env, jclass class, jlong fd) {
	if (fd == 0) return INVALID_ARGUMENT;
	fclose((FILE*)fd);
}

JNIEXPORT jlong JNICALL Java_com_troy_empireserialization_util_NativeUtils_fopen
(JNIEnv * env, jclass class, jstring name, jstring accessJ) {
	if (name == 0 || accessJ == 0) return 0;
	const char* file = (*env)->GetStringUTFChars(env, name, NULL);
	const char* access = (*env)->GetStringUTFChars(env, accessJ, NULL);
	if (file == NULL) return OUT_OF_MEMORY;
	if (access == NULL) return OUT_OF_MEMORY;
	FILE* result = fopen(file, access);
	if (result == NULL) return 0;
	(*env)->ReleaseStringUTFChars(env, name, file);
	(*env)->ReleaseStringUTFChars(env, accessJ, access);
	return (jlong)result;
}



inline jshort swapJshort(jshort value) {
#if 1
	return _byteswap_ushort(value);
#else
	return  ((value & 0x00FF) << 8) |
			((value & 0xFF00) >> 8);
#endif
}

inline jchar swapJchar(jchar value) {
#if 1
	return _byteswap_ushort(value);
#else
	return  ((value & 0x00FF) << 8) |
			((value & 0xFF00) >> 8);
#endif
}

inline jint swapJint(jint value) {
#if 1
	return _byteswap_ulong(value);
#else
	return  ((value & 0x000000FF) << 24) |
			((value & 0x0000FF00) << 8) |
			((value & 0x00FF0000) >> 8) |
			((value & 0xFF000000) >> 24);
#endif
}

inline jfloat swapJfloat(jfloat value) {
#if 1
	return _byteswap_ulong(value);
#else
	return  ((value & 0x000000FF) << 24) |
			((value & 0x0000FF00) << 8) |
			((value & 0x00FF0000) >> 8) |
			((value & 0xFF000000) >> 24);
#endif
}

inline jlong swapJlong(jlong value) {
#if 1
	return _byteswap_uint64(value);
#else
	return  ((value & 0x00000000000000FF) << 56) |
			((value & 0x000000000000FF00) << 40) |
			((value & 0x0000000000FF0000) << 24) |
			((value & 0x00000000FF000000) <<  8) |
			((value & 0x000000FF00000000) >>  8) |
			((value & 0x0000FF0000000000) >> 24) |
			((value & 0x00FF000000000000) >> 40) |
			((value & 0xFF00000000000000) >> 56);
#endif
}

inline jdouble swapJdouble(jdouble value) {
#if 1
	return _byteswap_uint64(value);
#else
	return  ((value & 0x00000000000000FF) << 56) |
			((value & 0x000000000000FF00) << 40) |
			((value & 0x0000000000FF0000) << 24) |
			((value & 0x00000000FF000000) <<  8) |
			((value & 0x000000FF00000000) >>  8) |
			((value & 0x0000FF0000000000) >> 24) |
			((value & 0x00FF000000000000) >> 40) |
			((value & 0xFF00000000000000) >> 56);
#endif
}

JNIEXPORT jint JNICALL Java_com_troy_empireserialization_util_NativeUtils_nativeToFWrite(JNIEnv * env, jclass class, jlong fd, jlong srcJ, jlong bytes) {
	if (srcJ == 0 || fd == 0)
		return INVALID_ARGUMENT;
	fwrite((jbyte*)srcJ, 1, (size_t)bytes, (FILE*)fd);
	return 0;
}

JNIEXPORT jint JNICALL Java_com_troy_empireserialization_util_NativeUtils_fReadToNative(JNIEnv * env, jclass class, jlong fd, jlong destJ, jlong bytes) {
	if (destJ == 0 || fd == 0)
		return INVALID_ARGUMENT;
	fread((void*)destJ, 1, bytes, (FILE*)fd);
	return 0;
}

#define xsToFWrite(type, swapFunc) \
JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_##type##sToFWrite(JNIEnv * env, jclass class, jlong fd, j##type##Array srcJ, jint srcOffset, jint elements, jboolean swapEndianess) {\
	if (fd == 0 || srcJ == NULL) {											\
		return;																\
	}																		\
	j##type* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);		\
	if (src == NULL) return OUT_OF_MEMORY;									\
	if (swapEndianess && (sizeof(j##type) != 1)) {							\
		j##type dest;														\
		for (int i = 0; i < elements; i++) {								\
			int srcIndex = i + srcOffset;									\
			dest = swapFunc(src[srcIndex]);									\
			fwrite(&dest, sizeof(j##type), 1, (FILE*) fd);					\
		}																	\
	}																		\
	else {																	\
		fwrite(src, (size_t)(elements * sizeof(j##type)), 1, (FILE*)fd);   	\
	}																		\
	(*env)->ReleasePrimitiveArrayCritical(env, srcJ, src, JNI_ABORT);		\
}
xsToFWrite(byte, )
xsToFWrite(boolean, )
xsToFWrite(short, swapJshort)
xsToFWrite(int, swapJint)
xsToFWrite(long, swapJlong)
xsToFWrite(float, swapJfloat)
xsToFWrite(double, swapJdouble)
xsToFWrite(char, swapJchar)

#define xToFWrite(type, swapFunc) \
JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_##type##ToFWrite(JNIEnv * env, jclass class, jlong fd, j##type value, jboolean swapEndianess) {\
	if (fd == 0) {													\
		return;														\
	}																\
	if(sizeof(j##type) > 1 && swapEndianess) {						\
		value = swapFunc(value);									\
	}																\
	fwrite(&value, (size_t)(sizeof(j##type)), 1, (FILE*)fd);		\
}

xToFWrite(byte, )
xToFWrite(short, swapJshort)
xToFWrite(int, swapJint)
xToFWrite(long, swapJlong)
xToFWrite(float, swapJfloat)
xToFWrite(double, swapJdouble)
xToFWrite(char, swapJchar)
xToFWrite(boolean, )


#define fReadToX(type, capitalType, swapFunc) \
JNIEXPORT j##type JNICALL Java_com_troy_empireserialization_util_NativeUtils_fReadTo##capitalType(JNIEnv * env, jclass class, jlong fd, jboolean swapEndianess) {\
	if (fd == 0) {													\
		return -1;													\
	}																\
	j##type value = 0;												\
	fread(&value, sizeof(j##type), 1, (FILE*) fd);					\
	if(sizeof(j##type) > 1 && swapEndianess) {						\
		value = swapFunc(value);									\
	}																\
	return value;													\
}

fReadToX(byte, Byte, )
fReadToX(short, Short, swapJshort)
fReadToX(int, Int, swapJint)
fReadToX(long, Long, swapJlong)
fReadToX(float, Float, swapJfloat)
fReadToX(double, Double, swapJdouble)
fReadToX(char, Char, swapJchar)
fReadToX(boolean, Boolean, )

#define fReadToXs(type, capitalType, swapFunc) \
JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_fReadTo##capitalType##s(JNIEnv * env, jclass class, jlong fd, j##type##Array destJ, jint srcOffset, jint elements, jboolean swapEndianess) {\
	if (fd == 0 || destJ == NULL) {											\
		return;																\
	}																		\
	j##type* dest = (*env)->GetPrimitiveArrayCritical(env, destJ, NULL);	\
	if (dest == NULL) return OUT_OF_MEMORY;									\
	fread(dest + srcOffset, sizeof(j##type), elements, (FILE*)fd);			\
	if (swapEndianess && (sizeof(j##type) != 1)) {							\
		for (int i = srcOffset; i < elements + srcOffset; i++) {			\
			dest[i] = swapFunc(dest[i]);									\
		}																	\
	}																		\
	(*env)->ReleasePrimitiveArrayCritical(env, destJ, dest, 0);				\
}
fReadToXs(byte, Byte, )
fReadToXs(boolean, Boolean, )
fReadToXs(short, Short, swapJshort)
fReadToXs(int, Int, swapJint)
fReadToXs(long, Long, swapJlong)
fReadToXs(float, Float, swapJfloat)
fReadToXs(double, Double, swapJdouble)
fReadToXs(char, Char, swapJchar)

#define xToNative(type, swapFunc)															\
JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_##type##ToNative	\
(JNIEnv * env, jclass class, jlong addressJ, j##type value, jboolean swapEndianness) {		\
	if (addressJ == NULL) return;															\
	j##type* address = (j##type*) addressJ;													\
	if (sizeof(j##type) > 1 && swapEndianness) {											\
		value = swapFunc(value);															\
	}																						\
	*address = value;																		\
}

xToNative(byte, )
xToNative(boolean, )
xToNative(short, swapJshort)
xToNative(int, swapJint)
xToNative(long, swapJlong)
xToNative(float, swapJfloat)
xToNative(double, swapJdouble)
xToNative(char, swapJchar)

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_shortToVLENative
(JNIEnv * env, jclass class, jlong addressJ, jshort value) {
	if (addressJ == NULL) return;

	return 0;
}


JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_intToVLENative
(JNIEnv * env, jclass class, jlong addressJ, jint value) {
	if (addressJ == NULL) return;

	return 0;
}

JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_longToVLENative
(JNIEnv * env, jclass class, jlong addressJ, jlong value) {
	if (addressJ == NULL) return;

	return 0;
}

JNIEXPORT jbyteArray JNICALL Java_com_troy_empireserialization_util_NativeUtils_ngetBuffer
(JNIEnv * env, jclass class, jlong addressJ, jint capacity)
{
	if (addressJ == 0) return NULL;
	const jbyte* address = (jbyte*)addressJ;
	jbyteArray result = (*env)->NewByteArray(env, capacity);
	if (result == NULL) return NULL;
	(*env)->SetByteArrayRegion(env, result, 0, capacity, address);
	return result;
}

JNIEXPORT jint JNICALL Java_com_troy_empireserialization_charset_FourBitCharset_nEncodeImpl
(JNIEnv * env, jobject charset, jcharArray srcJ, jlong destJ, jint srcOffset, jint chars, jint info)
{
	jchar* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);
	jbyte* dest = (jbyte*)destJ;
	if (src == NULL) return OUT_OF_MEMORY;
	if (dest == NULL) return INVALID_ARGUMENT;
	int bytesWritten = 0;
	int i = 0;
	const int end = (chars / 2) * 2;//round down to next mutiple of two
	while (i < end) {
		dest[bytesWritten++] = (FOUR_BIT_ENCODING_CACHE[src[srcOffset + i]] << 4) | FOUR_BIT_ENCODING_CACHE[src[srcOffset + i + 1]];
		i += 2;
	}
	if (chars % 2 != 0) {
		dest[bytesWritten++] = FOUR_BIT_ENCODING_CACHE[src[end]] << 4;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, srcJ, src, 0);
	return bytesWritten;
}

JNIEXPORT jint JNICALL Java_com_troy_empireserialization_charset_SixBitCharset_nEncodeImpl
(JNIEnv * env, jobject charset, jcharArray srcJ, jlong destJ, jint srcOffset, jint chars, jint info)
{
	jchar* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);
	jbyte* dest = (jbyte*)destJ;
	const jbyte* inital = dest;
	if (src == NULL) return OUT_OF_MEMORY;
	if (dest == NULL) return INVALID_ARGUMENT;
	int i = srcOffset;
	int result;
	const jint end = (chars / 4) * 4;// round down to next multiple of two
	while (i < end) {
		int c0 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c1 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c2 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c3 = SIX_BIT_ENCODING_CACHE[src[i++]];
		result = c3;
		result |= c2 << 6;
		result |= c1 << 12;
		result |= c0 << 18;

		*dest = (result >> 16) & 0xFF;
		dest++;
		*dest = (result >>  8) & 0xFF;
		dest++;
		*dest = (result >>  0) & 0xFF;
		dest++;
	}
	if (chars % 4 == 3) {// Write the remaining byte if there was an odd number
		int c0 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c1 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c2 = SIX_BIT_ENCODING_CACHE[src[i++]];
		result = 0;
		result |= c2 << 0;
		result |= c1 << 6;
		result |= c0 << 12;

		*dest = (result >> 16) & 0xFF;
		dest++;
		*dest  = (result >> 8) & 0xFF;
		dest++;
		*dest = (result >>  0) & 0xFF;
		dest++;
	}
	else if (chars % 4 == 2) {// Write the remaining byte if there was an odd number
		int c0 = SIX_BIT_ENCODING_CACHE[src[i++]];
		int c1 = SIX_BIT_ENCODING_CACHE[src[i++]];
		result = c1 << 0;
		result |= c0 << 6;

		*dest = (result >> 8) & 0xFF;
		dest++;
		*dest = (result >> 0) & 0xFF;
		dest++;

	}
	else if (chars % 4 == 1) {// Write the remaining byte if there was an odd number
		*dest = SIX_BIT_ENCODING_CACHE[src[end]];
		dest++;
	}
	return (jint) (dest - inital);
}

JNIEXPORT jint JNICALL Java_com_troy_empireserialization_charset_EmpireCharsets_nIdentifyCharset
(JNIEnv * env, jclass class, jcharArray array, jint offset, jint length) {
	jchar* src = (*env)->GetPrimitiveArrayCritical(env, array, NULL);
	unsigned int fourOK = 1;
	unsigned int sixOK = 1;
	unsigned int allASCII = 1;
	for (int i = offset; i < offset + length; i++) {
		jchar c = src[i];
		if (allASCII && (c >> 7) != 0)
			allASCII = 0;
		if (fourOK && (c > sizeof(FOUR_BIT_ENCODING_CACHE) || FOUR_BIT_ENCODING_CACHE[c] == -1)) {
			fourOK = 0;
		}
		if (sixOK && (c > sizeof(SIX_BIT_ENCODING_CACHE) || SIX_BIT_ENCODING_CACHE[c] == -1)) {
			sixOK = 0;
		}
		if (!fourOK && !sixOK && !allASCII) {
			break;
		}
	}
	(*env)->ReleasePrimitiveArrayCritical(env, array, src, JNI_ABORT);
	unsigned int result = (allASCII ? 0 : 1) << 2;
	if (fourOK)
		result |= 0b00;
	else if (sixOK)
		result |= 0b01;
	else
		result |= 0b10;
	return result;
}


JNIEXPORT jint JNICALL Java_com_troy_empireserialization_charset_VLE8Charset_nEncodeImpl
(JNIEnv * env, jobject charset, jcharArray srcJ, jlong destJ, jint srcOffset, jint chars, jint info)
{
	jchar* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);
	jbyte* dest = (jbyte*)destJ;
	if (src == NULL) return OUT_OF_MEMORY;
	if (dest == NULL) return INVALID_ARGUMENT;
	int bytesWritten = 0;
	int i = srcOffset;
	const int end = srcOffset + chars;//round down to next mutiple of two
	if (info == 0) {
		while (i < end) {
			dest[bytesWritten++] = (jbyte) src[i++];
		}
	}
	else {
		while (i < end) {
			jchar value = src[i++];
			printf("char %c %i\n", value, value);
			if (value >> 7 == 0) {
				dest[bytesWritten++] = value;
			}
			else if (value >> 14 == 0) {
				dest[bytesWritten++] = (value & VLE8_DATA_MASK) | VLE8_HAS_NEXT_BYTE;
				dest[bytesWritten++] = value >> 7;
			}
			else if (value >> 21 == 0) {
				dest[bytesWritten++] = (value & VLE8_DATA_MASK) | VLE8_HAS_NEXT_BYTE;
				dest[bytesWritten++] = ((value >> 7) & VLE8_DATA_MASK) | VLE8_HAS_NEXT_BYTE;
				dest[bytesWritten++] = value >> 14;
			}
		}
	}
	(*env)->ReleasePrimitiveArrayCritical(env, srcJ, src, 0);
	return bytesWritten;
}

#define xToBytes(type, swapFunc) \
JNIEXPORT j##type JNICALL Java_com_troy_empireserialization_util_NativeUtils_##type##sToBytes(JNIEnv * env, jclass class, jbyteArray destJ, j##type##Array srcJ, jint srcOffset, jint destOffset, jint elements, jboolean swapEndianess) {\
	if (destJ == NULL || destJ == NULL) {									\
		return INVALID_ARGUMENT;											\
	}																		\
	j##type* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);		\
	jbyte* dest = (*env)->GetPrimitiveArrayCritical(env, destJ, NULL);		\
	if (src == NULL || dest == NULL) return OUT_OF_MEMORY;					\
	if (swapEndianess && (sizeof(j##type) != 1)) {							\
		j##type* destS = (j##type*)dest;									\
		for (int i = 0; i < elements; i++) {								\
			int srcIndex = i + srcOffset;									\
			(*destS) = swapFunc(src[srcIndex]);								\
			destS++;														\
		}																	\
	}																		\
	else {																	\
		memcpy(dest, src, (size_t)(elements * sizeof(j##type)));			\
	}																		\
	(*env)->ReleasePrimitiveArrayCritical(env, srcJ, src, JNI_ABORT);		\
	(*env)->ReleasePrimitiveArrayCritical(env, destJ, dest, 0);				\
	return 0;																\
}
xToBytes(short, swapJshort)
xToBytes(int, swapJint)
xToBytes(long, swapJlong)
xToBytes(float, swapJint)
xToBytes(double, swapJlong)
xToBytes(char, swapJshort)
xToBytes(boolean, )


JNIEXPORT jint JNICALL Java_com_troy_empireserialization_util_NativeUtils_booleansToBytesCompact(JNIEnv * env, jclass class, jbyteArray destJ, jbooleanArray srcJ, jint srcOffset, jint destOffset, jint elements) {
	if (destJ == NULL || destJ == NULL) {
		return INVALID_ARGUMENT;
	}
	jboolean* src = (*env)->GetPrimitiveArrayCritical(env, srcJ, NULL);
	jbyte* dest = (*env)->GetPrimitiveArrayCritical(env, destJ, NULL);
	if (src == NULL || dest == NULL) return OUT_OF_MEMORY;
	jbyte current = 0;
	jint count = 0;
	for (int i = srcOffset; i < elements + srcOffset; i++) {
		int mod = i % 8;
		current |= (src[i] & 0b1) << (7 - mod);
		if (mod == 0 && i != 0) {
			(*dest) = current;
			dest++;
			current = 0;
			count++;
		}
	}
	if (current != 0) {
		(*dest) = current;
		count++;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, srcJ, src, JNI_ABORT);
	(*env)->ReleasePrimitiveArrayCritical(env, destJ, dest, 0);
	return count;
}


//Methods for manipulating java arrays
#define xToNative(type, capitalType, swapFunc) \
JNIEXPORT jint JNICALL Java_com_troy_empireserialization_util_NativeUtils_##type##sToNative(JNIEnv * env, jclass class, jlong dest, j##type##Array src, jint offset, jint elements, jboolean swapEndianess) {\
	if(src == 0 || dest == 0) return INVALID_ARGUMENT;\
	(*env)->Get##capitalType##ArrayRegion(env, src, offset, elements, (j##type *)dest); \
	if(swapEndianess && sizeof(j##type) > 1) {\
/*FIXME actually swap enginess if neccsary*/\
	}\
	return 0;\
}
//Theese methods copy bytes from an array to native memory

xToNative(byte, Byte, )
xToNative(short, Short, swapJshort)
xToNative(int, Int, swapJint)
xToNative(long, Long, swapJlong)
xToNative(float, Float, swapJint)
xToNative(double, Double, swapJlong)
xToNative(char, Char, swapJshort)
xToNative(boolean, Boolean, )

//Theese methods copy bytes native memory to an array
#define nativeToX(type, capitalType) \
JNIEXPORT jint JNICALL Java_com_troy_empireserialization_util_NativeUtils_nativeTo##capitalType##s(JNIEnv * env, jclass class, j##type##Array dest, jlong src, jint offset, jint elements) {\
	if(src == 0 || dest == 0) return INVALID_ARGUMENT;\
	(*env)->Set##capitalType##ArrayRegion(env, dest, offset, elements, (j##type*) src);\
	return 0;\
}

nativeToX(byte, Byte)
nativeToX(short, Short)
nativeToX(int, Int)
nativeToX(long, Long)
nativeToX(float, Float)
nativeToX(double, Double)
nativeToX(char, Char)



//wrapper for memcpy
JNIEXPORT void JNICALL Java_com_troy_empireserialization_util_NativeUtils_memcpy(JNIEnv * env, jclass class, jlong dest, jlong src, jlong bytes) {
	if (src == 0 || dest == 0) return;
	memcpy((jbyte*)dest, (jbyte*)src, (size_t)bytes);
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\CharEncodingTest.java

package com.troy.junit;

import static org.junit.Assert.*;

import java.util.*;

import org.junit.*;

import com.troy.empireserialization.charset.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.util.*;

public class CharEncodingTest {

	private static final char[] FOUR_BIT_TEST = TestConstants.FOUR_BIT_STRING.toCharArray();
	private static final byte[] FOUR_BIT_RESULT = new byte[] { 0b00010000, 0b01100001 };

	protected static final char[] SIX_BIT_TEST = TestConstants.SIX_BIT_STRING.toCharArray();
	private static final byte[] SIX_BIT_RESULT = new byte[] { -27, 53, 30, 1, 71, -128, -87, -122, -44, 117, 0, 56, 65, -43, 12, 93, 73, 76, 125, 70,
			-103, 2, 39, 84, 125, -12, 25, 0, -39, 0, -27, -42, -92, 3, 52, 32, 52, -56, 16, 7, 66 };

	private static final char[] VLE8_TEST = TestConstants.VLE8_STRING.toCharArray();

	@Test
	public void nativeFourBit() {
		NativeUtils.NATIVES_ENABLED = true;
		ByteArrayOutput out = new ByteArrayOutput();
		EmpireCharsets.FOUR_BIT_CHARSET.encode(FOUR_BIT_TEST, out, 0, FOUR_BIT_TEST.length, StringInfo.ALL_ASCII);
		assertArrayEquals(Arrays.copyOf(out.getBuffer(), out.getBufferPosition()), FOUR_BIT_RESULT);
	}

	@Test
	public void javaFourBit() {
		NativeUtils.NATIVES_ENABLED = false;
		ByteArrayOutput out = new ByteArrayOutput();
		EmpireCharsets.FOUR_BIT_CHARSET.encode(FOUR_BIT_TEST, out, 0, FOUR_BIT_TEST.length, StringInfo.ALL_ASCII);
		assertArrayEquals(Arrays.copyOf(out.getBuffer(), out.getBufferPosition()), new byte[] { 0b00010000, 0b01100001 });
	}

	@Test
	public void nativeSixBit() {
		NativeUtils.NATIVES_ENABLED = true;
		ByteArrayOutput out = new ByteArrayOutput();

		EmpireCharsets.SIX_BIT_CHARSET.encode(SIX_BIT_TEST, out, 0, SIX_BIT_TEST.length, StringInfo.ALL_ASCII);

		assertArrayEquals(Arrays.copyOf(out.getBuffer(), out.getBufferPosition()), SIX_BIT_RESULT);
	}

	@Test
	public void javaSixBit() {
		NativeUtils.NATIVES_ENABLED = false;
		ByteArrayOutput out = new ByteArrayOutput();

		EmpireCharsets.SIX_BIT_CHARSET.encode(SIX_BIT_TEST, out, 0, SIX_BIT_TEST.length, StringInfo.ALL_ASCII);

		assertArrayEquals(Arrays.copyOf(out.getBuffer(), out.getBufferPosition()), SIX_BIT_RESULT);
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\EndiannessTest.java

package com.troy.junit;

import static org.junit.Assert.*;

import java.nio.*;

import org.junit.*;

import com.troy.empireserialization.io.out.*;

public class EndiannessTest {

	@Test
	public void byteArrayOutBigEndian() {
		byte[] expected = new byte[] { 0x00, 0x00, 0x00, 0x05, 0x00, 0x61, 0x00, 0x1c, 0x00, 0x22, 0x44, 0x66,
				(byte) 0x88, (byte) 0xaa, (byte) 0xcc, (byte) 0xff, 0x01, 0x05, (byte) 0x81, 0x7f };

		ByteArrayOutput out = new ByteArrayOutput(20);
		out.setByteOrder(ByteOrder.BIG_ENDIAN);

		out.writeInt(5);// 0 - 4
		out.writeChar('a');// 4 - 2
		out.writeShort((short) 0x1C);// 6 - 2
		out.writeLong(0x0022446688AACCFFL);// 8 - 8
		out.writeVLEInt(1);// 16 - 1
		out.writeVLEInt(5);// 17 - 1
		out.writeVLEInt(0xFF);// 18 - 2

		byte[] result = out.getBuffer();
		assertArrayEquals(expected, result);
		out.close();
	}

	@Test
	public void byteArrayLittleBigEndian() {
		byte[] expected = new byte[] { 0x05, 0x00, 0x00, 0x00, 0x61, 0x00, 0x1c, 0x00, (byte) 0xff, (byte) 0xcc,
				(byte) 0xaa, (byte) 0x88, 0x66, 0x44, 0x22, 0x00, 0x01, 0x05, (byte) 0x81, 0x7f };

		ByteArrayOutput out = new ByteArrayOutput(20);
		out.setByteOrder(ByteOrder.LITTLE_ENDIAN);

		out.writeInt(5);// 0 - 4
		out.writeChar('a');// 4 - 2
		out.writeShort((short) 0x1C);// 6 - 2
		out.writeLong(0x0022446688AACCFFL);// 8 - 8
		out.writeVLEInt(1);// 16 - 1
		out.writeVLEInt(5);// 17 - 1
		out.writeVLEInt(0xFF);// 18 - 2

		byte[] result = out.getBuffer();
		assertArrayEquals(expected, result);
		out.close();
	}


}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\JUnitConstants.java

package com.troy.junit;

import java.io.*;

public class JUnitConstants {
	protected static final File TEST_FILE = new File("JUint test.dat");

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\NativeMapTest.java

package com.troy.junit;

import static org.junit.Assert.*;

import java.io.*;
import java.nio.file.*;

import org.junit.*;

import com.troy.empireserialization.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.memory.NativeMemoryBlock;
import com.troy.empireserialization.util.*;

import static com.troy.junit.JUnitConstants.*;

public class NativeMapTest {
	
	private static final byte[] MAP_TEST = new byte[] { 1, 5, 0, 9, 0, 45, 100, -24, 37, 5, 78, -12, 34, -56, -1, -5 };


	@Test
	public void byteArrayOutMap() {
		ByteArrayOutput out = new ByteArrayOutput(MAP_TEST.length);
		mapAndWrite(out, MAP_TEST);
		assertArrayEquals(out.getBuffer(), MAP_TEST);
		out.close();
	}

	@Test
	public void nativeFileOutMap() throws IOException {
		NativeFileOutput out = new NativeFileOutput(TEST_FILE);
		mapAndWrite(out, MAP_TEST);
		out.close();
		assertArrayEquals(Files.readAllBytes(Paths.get(TEST_FILE.getAbsolutePath())), MAP_TEST);
	}

	@Test
	public void nativeOutMap() throws IOException {
		NativeOutput out = new NativeOutput();
		mapAndWrite(out, MAP_TEST);

		byte[] temp = new byte[MAP_TEST.length];
		// Copy to temp
		NativeUtils.nativeToBytes(temp, out.address(), 0, MAP_TEST.length);
		assertArrayEquals(temp, MAP_TEST);
		out.close();
	}

	private void mapAndWrite(Output out, byte[] toWrite) {
		NativeMemoryBlock block = out.map(toWrite.length);

		NativeUtils.bytesToNative(block.address(), toWrite, 0, toWrite.length);
		block.setPosition(toWrite.length);

		out.unmap(block);
	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\NoBufferExceptionTest.java

package com.troy.junit;

import java.io.*;

import org.junit.*;

import com.troy.empireserialization.exception.*;
import com.troy.empireserialization.io.out.*;

public class NoBufferExceptionTest {

	@Test(expected = NoBufferException.class)
	public void nativeOutNoBuffer() {
		NativeOutput out = new NativeOutput();
		out.getBuffer();
		out.close();
	}

	@Test(expected = NoBufferException.class)
	public void nativeFileOutNoBuffer() {
		NativeFileOutput out = new NativeFileOutput(new File("test.dat"));
		out.getBuffer();
		out.close();
	}

	@Test(expected = NoBufferException.class)
	public void nativeOutputStreamNoBuffer() {
		OutputStreamOutput out = new OutputStreamOutput(new ByteArrayOutputStream());
		out.getBuffer();
		out.close();
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\StringEncodingTest.java

package com.troy.junit;

import static org.junit.Assert.assertEquals;

import java.io.File;

import org.junit.Test;

import com.troy.empireserialization.EmpireInput;
import com.troy.empireserialization.EmpireOutput;

public class StringEncodingTest {
	
	private static final File file = new File("test.dat");
	
	@Test
	public void fourBitTest() {
		test(TestConstants.FOUR_BIT_STRING);
	}
	
	private static void test(String parameter) {
		EmpireOutput empOut = new EmpireOutput(file);
		empOut.writeString(parameter);
		empOut.close();
		
		EmpireInput empIn = new EmpireInput(file);
		String result = empIn.readString();
		assertEquals(parameter, result);
	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\junit\TestConstants.java

package com.troy.junit;

public class TestConstants {
	public static final String FOUR_BIT_STRING = "test";
	public static final String SIX_BIT_STRING = "This is Empire Serialization written by Troy Neubauer!";
	public static final String VLE8_STRING = "This is a test VLE8 String. next char is scarry:" + '\u1969';
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\BigObject.java

package com.troy.test;

import java.util.*;

public class BigObject {

	private HashMap<Object, Object> o;

	public BigObject() {
		o = new HashMap<Object, Object>();

		for (int i = 0; i < 1000; i++) {
			if ((i % 10) == 0)
				o.put("32r4e", "23ew" + Math.random());
			ArrayList<Double> d = new ArrayList<Double>();
			for (int j = 0; j < 10_000; j++)
				d.add(new Double(j));

			o.put(Integer.valueOf(i), d);
		}

	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\ClassA.java

package com.troy.test;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class ClassA implements Serializable {
	private String name;
	private int integer;
	private ClassB b;
	private List<String> randomStrings;

	private static final String[] RANDOM_STRINGS = { "one", "two", "empire", "serialization",
			"NULL CHARACTER TEST: " + '\0', "wierd unicode test" + ((char) 0x19EA) };

	public ClassA(String name, int integer) {
		this.name = name;
		this.integer = integer;
		Random random = new Random(12345L);
		this.b = new ClassB((int) (random.nextDouble() * 10), (int) (random.nextDouble() * 10) - 10);
		this.randomStrings = new ArrayList<String>();
		for (int i = 0; i < random.nextDouble() * RANDOM_STRINGS.length; i++)
			randomStrings.add(RANDOM_STRINGS[(int) (random.nextDouble() * RANDOM_STRINGS.length)]);

		for (int i = 0; i < 10; i++)
			randomStrings.add(Double.toString(random.nextDouble()));
	}
	
	

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((b == null) ? 0 : b.hashCode());
		result = prime * result + integer;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + ((randomStrings == null) ? 0 : randomStrings.hashCode());
		return result;
	}



	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ClassA other = (ClassA) obj;
		if (b == null) {
			if (other.b != null)
				return false;
		} else if (!b.equals(other.b))
			return false;
		if (integer != other.integer)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (randomStrings == null) {
			if (other.randomStrings != null)
				return false;
		} else if (!randomStrings.equals(other.randomStrings))
			return false;
		return true;
	}



	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getInteger() {
		return integer;
	}

	public void setInteger(int integer) {
		this.integer = integer;
	}

	public ClassB getB() {
		return b;
	}

	public void setB(ClassB b) {
		this.b = b;
	}

	public List<String> getRandomStrings() {
		return randomStrings;
	}

	public void setRandomStrings(List<String> randomStrings) {
		this.randomStrings = randomStrings;
	}

	@Override
	public String toString() {
		return "ClassA [name=" + name + ", integer=" + integer + ", b=" + b + ", randomStrings=" + randomStrings + "]";
	}
	
	

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\ClassB.java

package com.troy.test;

import java.io.Serializable;

public class ClassB implements Serializable {
	private int a, b;

	public ClassB(int a, int b) {
		this.a = a;
		this.b = b;
	}

	@Override
	public String toString() {
		return "ClassB [a=" + a + ", b=" + b + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + a;
		result = prime * result + b;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ClassB other = (ClassB) obj;
		if (a != other.a)
			return false;
		if (b != other.b)
			return false;
		return true;
	}
	
	
	
	
	
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\Constants.java

package com.troy.test;

import com.troy.empireserialization.util.*;

public class Constants {

	public static final String HARRY_POTTER = "Mr. and Mrs. Dursley, of number four, Privet Drive, were proud to say\n"
			+ "that they were perfectly normal, thank you very much. They were the last\n"
			+ "people you'd expect to be involved in anything strange or mysterious,\n" + "because they just didn't hold with such nonsense.\n"
			+ "Mr. Dursley was the director of a firm called Grunnings, which made\n"
			+ "drills. He was a big, beefy man with hardly any neck, although he did\n"
			+ "have a very large mustache. Mrs. Dursley was thin and blonde and had\n"
			+ "nearly twice the usual amount of neck, which came in very useful as she\n"
			+ "spent so much of her time craning over garden fences, spying on the\n"
			+ "neighbors. The Dursleys had a small son called Dudley and in their\n" + "opinion there was no finer boy anywhere.\n"
			+ "The Dursleys had everything they wanted, but they also had a secret, and\n"
			+ "their greatest fear was that somebody would discover it. They didn't\n"
			+ "think they could bear it if anyone found out about the Potters. Mrs.\n"
			+ "Potter was Mrs. Dursley's sister, but they hadn't met for several years;\n"
			+ "in fact, Mrs. Dursley pretended she didn't have a sister, because her\n"
			+ "sister and her good-for-nothing husband were as unDursleyish as it was\n"
			+ "possible to be. The Dursleys shuddered to think what the neighbors would\n"
			+ "say if the Potters arrived in the street. The Dursleys knew that the\n"
			+ "Potters had a small son, too, but they had never even seen him. This boy\n"
			+ "was another good reason for keeping the Potters away; they didn't want\n" + "Dudley mixing with a child like that.\n"
			+ "When Mr. and Mrs. Dursley woke up on the dull, gray Tuesday our story\n"
			+ "starts, there was nothing about the cloudy sky outside to suggest that\n"
			+ "strange and mysterious things would soon be happening all over the\n"
			+ "country. Mr. Dursley hummed as he picked out his most boring tie for\n"
			+ "work, and Mrs. Dursley gossiped away happily as she wrestled a screaming\n" + "Dudley into his high chair.\n"
			+ "None of them noticed a large, tawny owl flutter past the window.\n"
			+ "At half past eight, Mr. Dursley picked up his briefcase, pecked Mrs.\n"
			+ "Dursley on the cheek, and tried to kiss Dudley good-bye but missed,\n" + "\n"
			+ "because Dudley was now having a tantrum and throwing his cereal at the\n"
			+ "walls. \"Little tyke,\" chortled Mr. Dursley as he left the house. He got\n" + "into his car and backed out of number four's drive.\n"
			+ "It was on the corner of the street that he noticed the first sign of\n"
			+ "something peculiar -- a cat reading a map. For a second, Mr. Dursley\n"
			+ "didn't realize what he had seen -- then he jerked his head around to\n"
			+ "look again. There was a tabby cat standing on the corner of Privet\n"
			+ "Drive, but there wasn't a map in sight. What could he have been thinking\n"
			+ "of? It must have been a trick of the light. Mr. Dursley blinked and\n"
			+ "stared at the cat. It stared back. As Mr. Dursley drove around the\n"
			+ "corner and up the road, he watched the cat in his mirror. It was now\n"
			+ "reading the sign that said Privet Drive -- no, looking at the sign; cats\n"
			+ "couldn't read maps or signs. Mr. Dursley gave himself a little shake and\n"
			+ "put the cat out of his mind. As he drove toward town he thought of\n"
			+ "nothing except a large order of drills he was hoping to get that day.\n"
			+ "But on the edge of town, drills were driven out of his mind by something\n"
			+ "else. As he sat in the usual morning traffic jam, he couldn't help\n"
			+ "noticing that there seemed to be a lot of strangely dressed people\n"
			+ "about. People in cloaks. Mr. Dursley couldn't bear people who dressed in\n"
			+ "funny clothes -- the getups you saw on young people! He supposed this\n"
			+ "was some stupid new fashion. He drummed his fingers on the steering\n"
			+ "wheel and his eyes fell on a huddle of these weirdos standing quite\n"
			+ "close by. They were whispering excitedly together. Mr. Dursley was\n"
			+ "enraged to see that a couple of them weren't young at all; why, that man\n"
			+ "had to be older than he was, and wearing an emerald-green cloak! The\n"
			+ "nerve of him! But then it struck Mr. Dursley that this was probably some\n"
			+ "silly stunt -- these people were obviously collecting for something...\n"
			+ "yes, that would be it. The traffic moved on and a few minutes later, Mr.\n"
			+ "Dursley arrived in the Grunnings parking lot, his mind back on drills.\n"
			+ "Mr. Dursley always sat with his back to the window in his office on the\n"
			+ "ninth floor. If he hadn't, he might have found it harder to concentrate\n"
			+ "on drills that morning. He didn't see the owls swoop ing past in broad\n"
			+ "daylight, though people down in the street did; they pointed and gazed\n"
			+ "open- mouthed as owl after owl sped overhead. Most of them had never\n"
			+ "seen an owl even at nighttime. Mr. Dursley, however, had a perfectly\n"
			+ "normal, owl-free morning. He yelled at five different people. He made\n"
			+ "several important telephone calls and shouted a bit more. He was in a\n"
			+ "very good mood until lunchtime, when he thought he'd stretch his legs\n"
			+ "and walk across the road to buy himself a bun from the bakery.\n" + "\n"
			+ "He'd forgotten all about the people in cloaks until he passed a group of\n"
			+ "them next to the baker's. He eyed them angrily as he passed. He didn't\n"
			+ "know why, but they made him uneasy. This bunch were whispering\n"
			+ "excitedly, too, and he couldn't see a single collecting tin. It was on\n"
			+ "his way back past them, clutching a large doughnut in a bag, that he\n" + "caught a few words of what they were saying.\n"
			+ "\"The Potters, that's right, that's what I heard yes, their son, Harry\"\n"
			+ "Mr. Dursley stopped dead. Fear flooded him. He looked back at the\n"
			+ "whisperers as if he wanted to say something to them, but thought better\n" + "of it.\n"
			+ "He dashed back across the road, hurried up to his office, snapped at his\n"
			+ "secretary not to disturb him, seized his telephone, and had almost\n"
			+ "finished dialing his home number when he changed his mind. He put the\n"
			+ "receiver back down and stroked his mustache, thinking... no, he was\n"
			+ "being stupid. Potter wasn't such an unusual name. He was sure there were\n"
			+ "lots of people called Potter who had a son called Harry. Come to think\n"
			+ "of it, he wasn't even sure his nephew was called Harry. He'd never even\n"
			+ "seen the boy. It might have been Harvey. Or Harold. There was no point\n"
			+ "in worrying Mrs. Dursley; she always got so upset at any mention of her\n"
			+ "sister. He didn't blame her -- if he'd had a sister like that... but all\n" + "the same, those people in cloaks...\n"
			+ "He found it a lot harder to concentrate on drills that afternoon and\n"
			+ "when he left the building at five o'clock, he was still so worried that\n" + "he walked straight into someone just outside the door.\n"
			+ "\"Sorry,\" he grunted, as the tiny old man stumbled and almost fell. It\n"
			+ "was a few seconds before Mr. Dursley realized that the man was wearing a\n"
			+ "violet cloak. He didn't seem at all upset at being almost knocked to the\n"
			+ "ground. On the contrary, his face split into a wide smile and he said in\n"
			+ "a squeaky voice that made passersby stare, \"Don't be sorry, my dear sir,\n"
			+ "for nothing could upset me today! Rejoice, for You-Know-Who has gone at\n"
			+ "last! Even Muggles like yourself should be celebrating, this happy,\n" + "happy day!\"\n"
			+ "And the old man hugged Mr. Dursley around the middle and walked off.\n"
			+ "Mr. Dursley stood rooted to the spot. He had been hugged by a complete\n"
			+ "stranger. He also thought he had been called a Muggle, whatever that\n"
			+ "was. He was rattled. He hurried to his car and set off for home, hoping\n" + "\n"
			+ "he was imagining things, which he had never hoped before, because he\n" + "didn't approve of imagination.\n"
			+ "As he pulled into the driveway of number four, the first thing he saw --\n"
			+ "and it didn't improve his mood -- was the tabby cat he'd spotted that\n"
			+ "morning. It was now sitting on his garden wall. He was sure it was the\n" + "same one; it had the same markings around its eyes.\n"
			+ "\"Shoo!\" said Mr. Dursley loudly. The cat didn't move. It just gave him a\n"
			+ "stern look. Was this normal cat behavior? Mr. Dursley wondered. Trying\n"
			+ "to pull himself together, he let himself into the house. He was still\n" + "determined not to mention anything to his wife.\n"
			+ "Mrs. Dursley had had a nice, normal day. She told him over dinner all\n"
			+ "about Mrs. Next Door's problems with her daughter and how Dudley had\n"
			+ "learned a new word \"Won't!\". Mr. Dursley tried to act normally. When\n"
			+ "Dudley had been put to bed, he went into the living room in time to\n" + "catch the last report on the evening news:\n"
			+ "\"And finally, bird-watchers everywhere have reported that the nation's\n"
			+ "owls have been behaving very unusually today. Although owls normally\n"
			+ "hunt at night and are hardly ever seen in daylight, there have been\n"
			+ "hundreds of sightings of these birds flying in every direction since\n"
			+ "sunrise. Experts are unable to explain why the owls have suddenly\n"
			+ "changed their sleeping pattern.\" The newscaster allowed himself a grin.\n"
			+ "\"Most mysterious. And now, over to Jim McGuffin with the weather. Going\n" + "to be any more showers of owls tonight, Jim?\"\n"
			+ "\"Well, Ted,\" said the weatherman, \"I don't know about that, but it's not\n"
			+ "only the owls that have been acting oddly today. Viewers as far apart as\n"
			+ "Kent, Yorkshire, and Dundee have been phoning in to tell me that instead\n"
			+ "of the rain I promised yesterday, they've had a downpour of shooting\n"
			+ "stars! Perhaps people have been celebrating Bonfire Night early -- it's\n"
			+ "not until next week, folks! But I can promise a wet night tonight.\"\n"
			+ "Mr. Dursley sat frozen in his armchair. Shooting stars all over Britain?\n"
			+ "Owls flying by daylight? Mysterious people in cloaks all over the place?\n" + "And a whisper, a whisper about the Potters...\n"
			+ "Mrs. Dursley came into the living room carrying two cups of tea. It was\n"
			+ "no good. He'd have to say something to her. He cleared his throat\n"
			+ "nervously. \"Er -- Petunia, dear -- you haven't heard from your sister\n" + "lately, have you?\"\n" + "\n"
			+ "As he had expected, Mrs. Dursley looked shocked and angry. After all,\n" + "they normally pretended she didn't have a sister.\n"
			+ "\"No,\" she said sharply. \"Why?\"\n" + "\"Funny stuff on the news,\" Mr. Dursley mumbled. \"Owls... shooting\n"
			+ "stars... and there were a lot of funny-looking people in town today...\"\n" + "\"So?\" snapped Mrs. Dursley.\n"
			+ "\"Well, I just thought... maybe... it was something to do with... you\n" + "know... her crowd.\"\n"
			+ "Mrs. Dursley sipped her tea through pursed lips. Mr. Dursley wondered\n"
			+ "whether he dared tell her he'd heard the name \"Potter.\" He decided he\n"
			+ "didn't dare. Instead he said, as casually as he could, \"Their son --\n" + "he'd be about Dudley's age now, wouldn't he?\"\n"
			+ "\"I suppose so,\" said Mrs. Dursley stiffly.\n" + "\"What's his name again? Howard, isn't it?\"\n"
			+ "\"Harry. Nasty, common name, if you ask me.\"\n" + "\"Oh, yes,\" said Mr. Dursley, his heart sinking horribly. \"Yes, I quite\n"
			+ "agree.\"\n" + "He didn't say another word on the subject as they went upstairs to bed.\n"
			+ "While Mrs. Dursley was in the bathroom, Mr. Dursley crept to the bedroom\n"
			+ "window and peered down into the front garden. The cat was still there.\n"
			+ "It was staring down Privet Drive as though it were waiting for\n" + "something.\n"
			+ "Was he imagining things? Could all this have anything to do with the\n"
			+ "Potters? If it did... if it got out that they were related to a pair of\n" + "-- well, he didn't think he could bear it.\n"
			+ "The Dursleys got into bed. Mrs. Dursley fell asleep quickly but Mr.\n"
			+ "Dursley lay awake, turning it all over in his mind. His last, comforting\n"
			+ "thought before he fell asleep was that even if the Potters were\n"
			+ "involved, there was no reason for them to come near him and Mrs.\n"
			+ "Dursley. The Potters knew very well what he and Petunia thought about\n" + "\n"
			+ "them and their kind.... He couldn't see how he and Petunia could get\n"
			+ "mixed up in anything that might be going on -- he yawned and turned over\n" + "-- it couldn't affect them....\n"
			+ "How very wrong he was.\n" + "Mr. Dursley might have been drifting into an uneasy sleep, but the cat\n"
			+ "on the wall outside was showing no sign of sleepiness. It was sitting as\n"
			+ "still as a statue, its eyes fixed unblinkingly on the far corner of\n"
			+ "Privet Drive. It didn't so much as quiver when a car door slammed on the\n"
			+ "next street, nor when two owls swooped overhead. In fact, it was nearly\n" + "midnight before the cat moved at all.\n"
			+ "A man appeared on the corner the cat had been watching, appeared so\n"
			+ "suddenly and silently you'd have thought he'd just popped out of the\n" + "ground. The cat's tail twitched and its eyes narrowed.\n"
			+ "Nothing like this man had ever been seen on Privet Drive. He was tall,\n"
			+ "thin, and very old, judging by the silver of his hair and beard, which\n"
			+ "were both long enough to tuck into his belt. He was wearing long robes,\n"
			+ "a purple cloak that swept the ground, and high-heeled, buckled boots.\n"
			+ "His blue eyes were light, bright, and sparkling behind half-moon\n"
			+ "spectacles and his nose was very long and crooked, as though it had been\n"
			+ "broken at least twice. This man's name was Albus Dumbledore.\n"
			+ "Albus Dumbledore didn't seem to realize that he had just arrived in a\n"
			+ "street where everything from his name to his boots was unwelcome. He was\n"
			+ "busy rummaging in his cloak, looking for something. But he did seem to\n"
			+ "realize he was being watched, because he looked up suddenly at the cat,\n"
			+ "which was still staring at him from the other end of the street. For\n"
			+ "some reason, the sight of the cat seemed to amuse him. He chuckled and\n" + "muttered, \"I should have known.\"\n"
			+ "He found what he was looking for in his inside pocket. It seemed to be a\n"
			+ "silver cigarette lighter. He flicked it open, held it up in the air, and\n"
			+ "clicked it. The nearest street lamp went out with a little pop. He\n"
			+ "clicked it again -- the next lamp flickered into darkness. Twelve times\n"
			+ "he clicked the Put-Outer, until the only lights left on the whole street\n"
			+ "were two tiny pinpricks in the distance, which were the eyes of the cat\n"
			+ "watching him. If anyone looked out of their window now, even beady-eyed\n"
			+ "Mrs. Dursley, they wouldn't be able to see anything that was happening\n"
			+ "down on the pavement. Dumbledore slipped the Put-Outer back inside his\n"
			+ "cloak and set off down the street toward number four, where he sat down\n" + "\n"
			+ "on the wall next to the cat. He didn't look at it, but after a moment he\n" + "spoke to it.\n"
			+ "\"Fancy seeing you here, Professor McGonagall.\"\n" + "He turned to smile at the tabby, but it had gone. Instead he was smiling\n"
			+ "at a rather severe-looking woman who was wearing square glasses exactly\n"
			+ "the shape of the markings the cat had had around its eyes. She, too, was\n"
			+ "wearing a cloak, an emerald one. Her black hair was drawn into a tight\n" + "bun. She looked distinctly ruffled.\n"
			+ "\"How did you know it was me?\" she asked.\n" + "\"My dear Professor, I 've never seen a cat sit so stiffly.\"\n"
			+ "\"You'd be stiff if you'd been sitting on a brick wall all day,\" said\n" + "Professor McGonagall.\n"
			+ "\"All day? When you could have been celebrating? I must have passed a\n" + "dozen feasts and parties on my way here.\"\n"
			+ "Professor McGonagall sniffed angrily.\n" + "\"Oh yes, everyone's celebrating, all right,\" she said impatiently.\n"
			+ "\"You'd think they'd be a bit more careful, but no -- even the Muggles\n"
			+ "have noticed something's going on. It was on their news.\" She jerked her\n"
			+ "head back at the Dursleys' dark living-room window. \"I heard it. Flocks\n"
			+ "of owls... shooting stars.... Well, they're not completely stupid. They\n"
			+ "were bound to notice something. Shooting stars down in Kent -- I'll bet\n" + "that was Dedalus Diggle. He never had much sense.\"\n"
			+ "\"You can't blame them,\" said Dumbledore gently. \"We've had precious\n" + "little to celebrate for eleven years.\"\n"
			+ "\"I know that,\" said Professor McGonagall irritably. \"But that's no\n"
			+ "reason to lose our heads. People are being downright careless, out on\n"
			+ "the streets in broad daylight, not even dressed in Muggle clothes,\n" + "swapping rumors.\"\n"
			+ "She threw a sharp, sideways glance at Dumbledore here, as though hoping\n"
			+ "he was going to tell her something, but he didn't, so she went on. \"A\n"
			+ "fine thing it would be if, on the very day YouKnow-Who seems to have\n"
			+ "disappeared at last, the Muggles found out about us all. I suppose he\n" + "\n" + "really has gone, Dumbledore?\"\n"
			+ "\"It certainly seems so,\" said Dumbledore. \"We have much to be thankful\n" + "for. Would you care for a lemon drop?\"\n"
			+ "\"A what?\"\n" + "\"A lemon drop. They're a kind of Muggle sweet I'm rather fond of\"\n"
			+ "\"No, thank you,\" said Professor McGonagall coldly, as though she didn't\n"
			+ "think this was the moment for lemon drops. \"As I say, even if\n" + "You-Know-Who has gone -\"\n"
			+ "\"My dear Professor, surely a sensible person like yourself can call him\n"
			+ "by his name? All this 'You- Know-Who' nonsense -- for eleven years I\n"
			+ "have been trying to persuade people to call him by his proper name:\n"
			+ "Voldemort.\" Professor McGonagall flinched, but Dumbledore, who was\n"
			+ "unsticking two lemon drops, seemed not to notice. \"It all gets so\n"
			+ "confusing if we keep saying 'You-Know-Who.' I have never seen any reason\n" + "to be frightened of saying Voldemort's name.\n"
			+ "\"I know you haven 't, said Professor McGonagall, sounding half\n"
			+ "exasperated, half admiring. \"But you're different. Everyone knows you're\n"
			+ "the only one You-Know- oh, all right, Voldemort, was frightened of.\"\n"
			+ "\"You flatter me,\" said Dumbledore calmly. \"Voldemort had powers I will\n" + "never have.\"\n"
			+ "\"Only because you're too -- well -- noble to use them.\"\n"
			+ "\"It's lucky it's dark. I haven't blushed so much since Madam Pomfrey\n" + "told me she liked my new earmuffs.\"\n"
			+ "Professor McGonagall shot a sharp look at Dumbledore and said, \"The owls\n"
			+ "are nothing next to the rumors that are flying around. You know what\n"
			+ "everyone's saying? About why he's disappeared? About what finally\n" + "stopped him?\"\n"
			+ "It seemed that Professor McGonagall had reached the point she was most\n"
			+ "anxious to discuss, the real reason she had been waiting on a cold, hard\n"
			+ "wall all day, for neither as a cat nor as a woman had she fixed\n"
			+ "Dumbledore with such a piercing stare as she did now. It was plain that\n"
			+ "whatever \"everyone\" was saying, she was not going to believe it until\n" + "\n"
			+ "Dumbledore told her it was true. Dumbledore, however, was choosing\n" + "another lemon drop and did not answer.\n"
			+ "\"What they're saying,\" she pressed on, \"is that last night Voldemort\n"
			+ "turned up in Godric's Hollow. He went to find the Potters. The rumor is\n"
			+ "that Lily and James Potter are -- are -- that they're -- dead. \"\n" + "Dumbledore bowed his head. Professor McGonagall gasped.\n"
			+ "\"Lily and James... I can't believe it... I didn't want to believe it...\n" + "Oh, Albus...\"\n"
			+ "Dumbledore reached out and patted her on the shoulder. \"I know... I\n" + "know...\" he said heavily.\n"
			+ "Professor McGonagall's voice trembled as she went on. \"That's not all.\n"
			+ "They're saying he tried to kill the Potter's son, Harry. But -- he\n"
			+ "couldn't. He couldn't kill that little boy. No one knows why, or how,\n"
			+ "but they're saying that when he couldn't kill Harry Potter, Voldemort's\n" + "power somehow broke -- and that's why he's gone.\n"
			+ "Dumbledore nodded glumly.\n" + "\"It's -- it's true?\" faltered Professor McGonagall. \"After all he's\n"
			+ "done... all the people he's killed... he couldn't kill a little boy?\n"
			+ "It's just astounding... of all the things to stop him... but how in the\n" + "name of heaven did Harry survive?\"\n"
			+ "\"We can only guess,\" said Dumbledore. \"We may never know.\"\n"
			+ "Professor McGonagall pulled out a lace handkerchief and dabbed at her\n"
			+ "eyes beneath her spectacles. Dumbledore gave a great sniff as he took a\n"
			+ "golden watch from his pocket and examined it. It was a very odd watch.\n"
			+ "It had twelve hands but no numbers; instead, little planets were moving\n"
			+ "around the edge. It must have made sense to Dumbledore, though, because\n"
			+ "he put it back in his pocket and said, \"Hagrid's late. I suppose it was\n" + "he who told you I'd be here, by the way?\"\n"
			+ "\"Yes,\" said Professor McGonagall. \"And I don't suppose you're going to\n" + "tell me why you're here, of all places?\"\n"
			+ "\"I've come to bring Harry to his aunt and uncle. They're the only family\n" + "he has left now.\"\n" + "\n"
			+ "\"You don't mean -- you can't mean the people who live here?\" cried\n"
			+ "Professor McGonagall, jumping to her feet and pointing at number four.\n"
			+ "\"Dumbledore -- you can't. I've been watching them all day. You couldn't\n"
			+ "find two people who are less like us. And they've got this son -- I saw\n"
			+ "him kicking his mother all the way up the street, screaming for sweets.\n" + "Harry Potter come and live here!\"\n"
			+ "\"It's the best place for him,\" said Dumbledore firmly. \"His aunt and\n"
			+ "uncle will be able to explain everything to him when he's older. I've\n" + "written them a letter.\"\n"
			+ "\"A letter?\" repeated Professor McGonagall faintly, sitting back down on\n"
			+ "the wall. \"Really, Dumbledore, you think you can explain all this in a\n"
			+ "letter? These people will never understand him! He'll be famous -- a\n"
			+ "legend -- I wouldn't be surprised if today was known as Harry Potter day\n"
			+ "in the future -- there will be books written about Harry -- every child\n" + "in our world will know his name!\"\n"
			+ "\"Exactly,\" said Dumbledore, looking very seriously over the top of his\n"
			+ "half-moon glasses. \"It would be enough to turn any boy's head. Famous\n"
			+ "before he can walk and talk! Famous for something he won't even\n"
			+ "remember! CarA you see how much better off he'll be, growing up away\n" + "from all that until he's ready to take it?\"\n"
			+ "Professor McGonagall opened her mouth, changed her mind, swallowed, and\n"
			+ "then said, \"Yes -- yes, you're right, of course. But how is the boy\n"
			+ "getting here, Dumbledore?\" She eyed his cloak suddenly as though she\n" + "thought he might be hiding Harry underneath it.\n"
			+ "\"Hagrid's bringing him.\"\n" + "\"You think it -- wise -- to trust Hagrid with something as important as\n" + "this?\"\n"
			+ "I would trust Hagrid with my life,\" said Dumbledore.\n" + "\"I'm not saying his heart isn't in the right place,\" said Professor\n"
			+ "McGonagall grudgingly, \"but you can't pretend he's not careless. He does\n" + "tend to -- what was that?\"\n"
			+ "A low rumbling sound had broken the silence around them. It grew\n"
			+ "steadily louder as they looked up and down the street for some sign of a\n" + "\n"
			+ "headlight; it swelled to a roar as they both looked up at the sky -- and\n"
			+ "a huge motorcycle fell out of the air and landed on the road in front of\n" + "them.\n"
			+ "If the motorcycle was huge, it was nothing to the man sitting astride\n"
			+ "it. He was almost twice as tall as a normal man and at least five times\n"
			+ "as wide. He looked simply too big to be allowed, and so wild - long\n"
			+ "tangles of bushy black hair and beard hid most of his face, he had hands\n"
			+ "the size of trash can lids, and his feet in their leather boots were\n"
			+ "like baby dolphins. In his vast, muscular arms he was holding a bundle\n" + "of blankets.\n"
			+ "\"Hagrid,\" said Dumbledore, sounding relieved. \"At last. And where did\n" + "you get that motorcycle?\"\n"
			+ "\"Borrowed it, Professor Dumbledore, sit,\" said the giant, climbing\n"
			+ "carefully off the motorcycle as he spoke. \"Young Sirius Black lent it to\n" + "me. I've got him, sir.\"\n"
			+ "\"No problems, were there?\"\n" + "\"No, sir -- house was almost destroyed, but I got him out all right\n"
			+ "before the Muggles started swarmin' around. He fell asleep as we was\n" + "flyin' over Bristol.\"\n"
			+ "Dumbledore and Professor McGonagall bent forward over the bundle of\n"
			+ "blankets. Inside, just visible, was a baby boy, fast asleep. Under a\n"
			+ "tuft of jet-black hair over his forehead they could see a curiously\n" + "shaped cut, like a bolt of lightning.\n"
			+ "\"Is that where -?\" whispered Professor McGonagall.\n" + "\"Yes,\" said Dumbledore. \"He'll have that scar forever.\"\n"
			+ "\"Couldn't you do something about it, Dumbledore?\"\n" + "\"Even if I could, I wouldn't. Scars can come in handy. I have one myself\n"
			+ "above my left knee that is a perfect map of the London Underground. Well\n"
			+ "-- give him here, Hagrid -- we'd better get this over with.\"\n"
			+ "Dumbledore took Harry in his arms and turned toward the Dursleys' house.\n"
			+ "\"Could I -- could I say good-bye to him, sir?\" asked Hagrid. He bent his\n" + "\n"
			+ "great, shaggy head over Harry and gave him what must have been a very\n"
			+ "scratchy, whiskery kiss. Then, suddenly, Hagrid let out a howl like a\n" + "wounded dog.\n"
			+ "\"Shhh!\" hissed Professor McGonagall, \"you'll wake the Muggles!\"\n"
			+ "\"S-s-sorry,\" sobbed Hagrid, taking out a large, spotted handkerchief and\n"
			+ "burying his face in it. \"But I c-c-can't stand it -- Lily an' James dead\n"
			+ "-- an' poor little Harry off ter live with Muggles -\"\n" + "\"Yes, yes, it's all very sad, but get a grip on yourself, Hagrid, or\n"
			+ "we'll be found,\" Professor McGonagall whispered, patting Hagrid gingerly\n"
			+ "on the arm as Dumbledore stepped over the low garden wall and walked to\n"
			+ "the front door. He laid Harry gently on the doorstep, took a letter out\n"
			+ "of his cloak, tucked it inside Harry's blankets, and then came back to\n"
			+ "the other two. For a full minute the three of them stood and looked at\n"
			+ "the little bundle; Hagrid's shoulders shook, Professor McGonagall\n"
			+ "blinked furiously, and the twinkling light that usually shone from\n" + "Dumbledore's eyes seemed to have gone out.\n"
			+ "\"Well,\" said Dumbledore finally, \"that's that. We've no business staying\n"
			+ "here. We may as well go and join the celebrations.\"\n"
			+ "\"Yeah,\" said Hagrid in a very muffled voice, \"I'll be takin' Sirius his\n"
			+ "bike back. G'night, Professor McGonagall -- Professor Dumbledore, sir.\"\n"
			+ "Wiping his streaming eyes on his jacket sleeve, Hagrid swung himself\n"
			+ "onto the motorcycle and kicked the engine into life; with a roar it rose\n" + "into the air and off into the night.\n"
			+ "\"I shall see you soon, I expect, Professor McGonagall,\" said Dumbledore,\n"
			+ "nodding to her. Professor McGonagall blew her nose in reply.\n"
			+ "Dumbledore turned and walked back down the street. On the corner he\n"
			+ "stopped and took out the silver Put-Outer. He clicked it once, and\n"
			+ "twelve balls of light sped back to their street lamps so that Privet\n"
			+ "Drive glowed suddenly orange and he could make out a tabby cat slinking\n"
			+ "around the corner at the other end of the street. He could just see the\n" + "bundle of blankets on the step of number four.\n"
			+ "\"Good luck, Harry,\" he murmured. He turned on his heel and with a swish\n" + "of his cloak, he was gone.\n" + "\n"
			+ "A breeze ruffled the neat hedges of Privet Drive, which lay silent and\n"
			+ "tidy under the inky sky, the very last place you would expect\n"
			+ "astonishing things to happen. Harry Potter rolled over inside his\n"
			+ "blankets without waking up. One small hand closed on the letter beside\n"
			+ "him and he slept on, not knowing he was special, not knowing he was\n"
			+ "famous, not knowing he would be woken in a few hours' time by Mrs.\n"
			+ "Dursley's scream as she opened the front door to put out the milk\n"
			+ "bottles, nor that he would spend the next few weeks being prodded and\n"
			+ "pinched by his cousin Dudley... He couldn't know that at this very\n"
			+ "moment, people meeting in secret all over the country were holding up\n"
			+ "their glasses and saying in hushed voices: \"To Harry Potter -- the boy\n" + "who lived!\"";
	
	public static final String BIG_HARRY_POTTER = getBig(HARRY_POTTER, 10_000_000);

	public static final String VLE8_TEST = "123456789 VLE8" + '\u1940';

	private static String getBig(String base, int size) {
		int count = 0;
		char[] chars = new char[size];
		char[] baseChars = MiscUtil.getCharsFast(base);
		while (count < size) {
			int toWrite = Math.min(baseChars.length, size - count);
			System.arraycopy(baseChars, 0, chars, count, toWrite);
			count += toWrite;
		}
		return MiscUtil.createString(chars);
	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\JSONFail.java

package com.troy.test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Output;
import com.google.gson.Gson;
import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.SerializationSettings;
import com.troy.empireserialization.io.out.NativeFileOutput;
import com.troy.empireserialization.util.StringFormatter;

public class JSONFail {

	private static final DecimalFormat FORMAT = new DecimalFormat("#.##");
	private static final DecimalFormat SECOND_FORMAT = new DecimalFormat("#.#########");

	private static class DataPoint {
		public String name;
		public double data;

		public DataPoint(String name, double data) {
			this.name = name;
			this.data = data;
		}

		@Override
		public String toString() {
			return "DataPoint [name=" + name + ", data=" + data + "]";
		}

	}

	private static class D {
		private int[] ints = { 1, 2, 3, 4, 5 };
		private String[] strings = { "one", "two", "three" };
		private Object[] objects = { Integer.valueOf(4), "polys", Boolean.valueOf(false) };

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + Arrays.hashCode(ints);
			result = prime * result + Arrays.hashCode(objects);
			result = prime * result + Arrays.hashCode(strings);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			D other = (D) obj;
			if (!Arrays.equals(ints, other.ints))
				return false;
			if (!Arrays.equals(objects, other.objects))
				return false;
			if (!Arrays.equals(strings, other.strings))
				return false;
			return true;
		}

	}

	public static void main(String[] args) throws IOException {
		Kryo kryo = new Kryo();
		Output kryoWarmup = new Output(new FileOutputStream(new File("kryoWarmup.dat")));
		EmpireOutput meWarmup = new EmpireOutput(new File("meWarmup.dat"));
		Gson gson = new Gson();
		FileWriter gsonWarmup = new FileWriter(new File("gsonWarmup.dat"));
		for (int i = 0; i < 10_000; i++) {
			ClassA a = new ClassA("name", (int) (Math.random() * 100));
			//D a = new D();
			meWarmup.writeObject(a);
			kryo.writeObject(kryoWarmup, a);
			gson.toJson(a, gsonWarmup);
		}
		meWarmup.close();
		kryoWarmup.close();

		Output kryoOut = new Output(new FileOutputStream(new File("kryo.dat")));
		kryo.register(ClassA.class, 5);

		NativeFileOutput nOut = new NativeFileOutput(new File("./empire.dat"));
		EmpireOutput meOut = new EmpireOutput(nOut, new SerializationSettings().useStringCache(false));

		FileWriter gsonOut = new FileWriter(new File("gson.dat"));

		int tests = 1_000_000;
		long myTime = 0, kryoTime = 0, gsonTime = 0;
		long start, end;

		for (int i = 0; i < tests; i++) {
			ClassA a = new ClassA("name", (int) (Math.random() * 10_000));
			//D a = new D();

			// ClassB b = new ClassB((int) (Math.random() * 50), (int) (Math.random() *
			// 50));
			start = System.nanoTime();
			meOut.writeObject(a);
			end = System.nanoTime();
			myTime += end - start;

			start = System.nanoTime();
			kryo.writeObject(kryoOut, a);
			end = System.nanoTime();
			kryoTime += end - start;

			start = System.nanoTime();
			gson.toJson(a, gsonOut);
			end = System.nanoTime();
			gsonTime += end - start;
		}
		List<DataPoint> points = new ArrayList<DataPoint>();
		points.add(new DataPoint("Empire", (double) myTime / tests));
		points.add(new DataPoint("Kryo", (double) kryoTime / tests));
		points.add(new DataPoint("Gson", (double) gsonTime / tests));

		showData(points);

		// out.writeObject(ca);

		meOut.close();
		kryoOut.close();
		System.exit(0);

		B b = new B();
		A a = new A(b);
		b.a = a;
		ByteArrayOutputStream bb = new ByteArrayOutputStream();
		ObjectOutputStream str = new ObjectOutputStream(bb);
		str.writeObject(a);
		System.out.println(StringFormatter.toHexString(bb.toByteArray()));
		System.out.println(bb.toByteArray().length);
	}

	private static void showData(List<DataPoint> points) {
		if (points.isEmpty())
			return;
		Collections.sort(points, new Comparator<DataPoint>() {

			@Override
			public int compare(DataPoint o1, DataPoint o2) {
				return Double.compare(o1.data, o2.data);
			}
		});
		System.out.println("Fastest one: " + points.get(0).name);
		System.out.println("Slowest one: " + points.get(points.size() - 1).name);
		double fastest = points.get(0).data;
		System.out.println(points.get(0).name + " = " + FORMAT.format(fastest) + " nanosecnds " + SECOND_FORMAT.format(fastest / 1_000_000_000.0) + " seconds");
		for (int i = 1; i < points.size(); i++) {
			double current = points.get(i).data;
			System.out.println(points.get(i).name + " = " + FORMAT.format(current) + " nanosecnds " + SECOND_FORMAT.format(current / 1_000_000_000.0) + " seconds" + FORMAT.format(current / fastest) + "X slower");
		}

	}

	private static void kryoTest(ClassA ca) throws FileNotFoundException {
		Output out = new Output(new FileOutputStream(new File("kryo.dat")));
		new Kryo().writeClassAndObject(out, ca);
		out.close();
	}

	private static void javaSertest(ClassA ca) throws IOException {
		FileOutputStream bb = new FileOutputStream("java.dat");
		ObjectOutputStream str = new ObjectOutputStream(bb);
		str.writeObject(ca);
		str.close();
	}

	static class A implements Serializable {

		private int x;
		private B b;

		public A(B b) {
			this.b = b;
		}
	}

	static class B implements Serializable {
		private int y;
		private A a;
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\LineCounter.java

package com.troy.test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class LineCounter {

	// Prints out the number of lines
	public static void main(String[] args) throws IOException {
		File file = new File("C:\\Empire Serialization");
		System.out.println(countLines(file));

		FileWriter writer = new FileWriter(new File("putFilesTogther.txt"));
		putFilesTogther(file, writer);
		writer.close();
	}

	public static long countLines(File file) {
		long total = 0;
		if (file.isDirectory()) {
			for (File child : file.listFiles()) {
				if (child.isDirectory() || (child.getName().endsWith(".java") || child.getName().endsWith(".c"))) {
					if (child.isFile())
						System.out.println("reading " + child);
					total += countLines(child);
				}
			}
		} else {
			try {
				BufferedReader reader = new BufferedReader(new FileReader(file));
				while (reader.readLine() != null)
					total++;
				reader.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		return total;
	}

	public static void putFilesTogther(File file, FileWriter writer) {
		if (file.isDirectory()) {
			for (File child : file.listFiles()) {
				if (child.isDirectory() || (child.getName().endsWith(".java") || child.getName().endsWith(".c"))) {
					putFilesTogther(child, writer);
				}
			}
		} else {//It's a file
			try {
				BufferedReader reader = new BufferedReader(new FileReader(file));
				writer.write("\n#File: " + file + "\n\n");
				String line;
				while ((line = reader.readLine()) != null) {
					writer.write(line);
					writer.write('\n');
				}
				reader.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\Main.java

package com.troy.test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import com.esotericsoftware.kryo.Kryo;
import com.troy.empireserialization.EmpireOutput;
import com.troy.empireserialization.charset.EmpireCharsets;
import com.troy.empireserialization.io.in.NativeFileInput;
import com.troy.empireserialization.io.out.ByteArrayOutput;
import com.troy.empireserialization.io.out.NativeFileOutput;
import com.troy.empireserialization.util.ReflectionUtils;
import com.troy.empireserialization.util.StringFormatter;

public class Main {
	public static void main(String[] args) {
		arrayTest();
		System.exit(0);

	}

	// C:\Empire Serialization\Java Natives\bin\x64\Release
	public static void test() {
		System.out.println("e");
		NativeFileInput i = new NativeFileInput(new File("./out.emp"));
		i.readByte();
		char[] chars = new char[12];
		System.out.println(EmpireCharsets.SIX_BIT_CHARSET.decode(i, chars, 0, chars.length));

		System.out.println(StringFormatter.toHexString(i.readShort()));
		short[] shorts = new short[2];
		i.readShorts(shorts);
		System.out.println(StringFormatter.toHexString(shorts));
		i.close();

		System.exit(0);

		NativeFileOutput out = new NativeFileOutput(new File("./out.emp"));
		EmpireOutput emp = new EmpireOutput(out);
		emp.writeString("Test String!");
		emp.close();

		System.exit(0);
		init();

		Kryo k = new Kryo();
		TestSuper sup = new TestSuper(10, "test String");
		ClassA instance = new ClassA("Class A test!", 5);

		// k.writeClassAndObject(new Output(1000), instance);
		/*
		 * ByteArrayOutput out = new ByteArrayOutput(); EmpireOutput eo = new
		 * EmpireOutput(out); eo.writeTypeComplete(String.class); //
		 * eo.writeObject(instance); eo.writeArray(new String[] { "one", "one", "one",
		 * "one", "one" });
		 * System.out.println(StringFormatter.toBinaryString(out.getBuffer()));
		 * eo.close();
		 */
	}

	private static void arrayTest() {
		Object[] objects = new Object[3];
		objects[0] = new TestSuper(15, "test0");
		objects[1] = new TestSub(-1, "sub", 0xFF00FF);
		ByteArrayOutput oout = new ByteArrayOutput();
		EmpireOutput ooout = new EmpireOutput(oout);
		ooout.writeObject(objects);
		ooout.close();
	}

	private static void arrayListTest() {
		ArrayList<Object> list = new ArrayList<Object>();

		Object[] objects = new Object[] { 5, "test", "test2", "test3" };
		ReflectionUtils.setData(list, objects);
		System.out.println(list);
		ByteArrayOutput bOut = new ByteArrayOutput();
		EmpireOutput out = new EmpireOutput(bOut);

		out.writeObject(list);

		ArrayList<String> list2 = new ArrayList<>();
		list2.add("test1");
		list2.add("test2");
		list2.add("test3");
		list2.add("test4");
		out.writeObject(list2);

		out.writeObject(list);

		System.out.println(StringFormatter.toHexString(bOut.getBuffer()));
		out.close();
	}

	private static void init() {
		ArrayList<Object> list = new ArrayList<Object>();

		Object[] objects = new Object[] { 5, "test", "test2", "test3" };
		ReflectionUtils.setData(list, objects);

		ByteArrayOutput bOut = new ByteArrayOutput();
		EmpireOutput out = new EmpireOutput(bOut);
	}

	public static void wordTest(File... files) throws Exception {
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int counter = 0;
		for (File file : files) {
			long start = System.nanoTime();
			BufferedReader reader = new BufferedReader(new FileReader(file));
			String line;
			while ((line = reader.readLine()) != null) {
				for (char c : line.toCharArray()) {
					Character cc = Character.valueOf(c);
					Integer result = map.get(cc);
					if (result == null) {
						result = Integer.valueOf(1);
					} else {
						result = Integer.valueOf(result.intValue() + 1);
					}
					map.put(cc, result);
					counter++;
				}
			}
			double seconds = (System.nanoTime() - start) / 1000000000.0;
			reader.close();
			System.out.println("Scanned " + counter + " characters. ");
			System.out.println(map.size() + " different characters");
			System.out.println("Results for file " + file + ":");
			Map<Character, Integer> r = new TreeMap<Character, Integer>(new Comparator<Character>() {

				@Override
				public int compare(Character o1, Character o2) {
					return Integer.compare(map.get(o2).intValue(), map.get(o1).intValue());
				}
			});
			r.putAll(map);
			for (Entry<Character, Integer> entry : r.entrySet()) {
				char key = entry.getKey().charValue();
				int value = entry.getValue().intValue();
				System.out.println(key + " (" + ((int) key) + ") count " + value + " = " + ((double) value / counter * 100.0) + "%");
			}
			map.clear();
		}

	}
}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\ReflectionSub.java

package com.troy.test;

public class ReflectionSub<E> extends ReflectionSuper<Integer, E> {
	
	private String name;

	public ReflectionSub(Integer t, E e, String name) {
		super(t, e);
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\ReflectionSuper.java

package com.troy.test;

public class ReflectionSuper<T, E> {
	private T t;
	private E e;

	public ReflectionSuper(T t, E e) {
		super();
		this.t = t;
		this.e = e;
	}

	public T getT() {
		return t;
	}

	public E getE() {
		return e;
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\TestMid.java

package com.troy.test;


public class TestMid extends TestSuper {
	
	private long x;

	public TestMid(int superInt, String s, long x) {
		super(superInt, s);
		this.x = x;
	}
	
	public long getX() {
		return x;
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\TestSub.java

package com.troy.test;


public class TestSub extends TestMid {

	public TestSub(int superInt, String s, long x) {
		super(superInt, s, x);
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\test\TestSuper.java

package com.troy.test;


public class TestSuper {
	private int superInt;
	String s;
	
	public TestSuper(int superInt, String s) {
		this.superInt = superInt;
		this.s = s;
	}
	
	public int getSuperInt() {
		return superInt;
	}
	
	public String getS() {
		return s;
	}

}

#File: C:\Empire Serialization\Java Test\src\main\java\com\troy\testframework\Library.java

package com.troy.testframework;

import java.io.*;
import java.util.*;

import com.esotericsoftware.kryo.*;
import com.esotericsoftware.kryo.io.Output;
import com.google.gson.*;
import com.troy.empireserialization.*;
import com.troy.empireserialization.io.out.*;
import com.troy.empireserialization.util.*;

public abstract class Library {
	public static List<Library> libs = new ArrayList<Library>();

	static {
		for (Class<?> clazz : Library.class.getDeclaredClasses()) {
			try {
				Library lib = (Library) clazz.newInstance();
				lib.name = clazz.getSimpleName();
				libs.add(lib);
			} catch (InstantiationException | IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}
	}

	public static void doTest(Object obj) {
		for (Library lib : libs) {
			lib.test(new File("./" + lib.name + ".dat"), obj);
		}
	}

	private String name;

	public void test(File file, Object obj) {
		System.out.println("Starting test for " + name);
		int samples = 20;
		long[] times = new long[samples];
		long start, end, size = 0;
		for (int i = 0; i < samples; i++) {
			file.delete();
			System.gc();
			start = System.nanoTime();
			writeObjectToFile(file, obj);
			end = System.nanoTime();
			size = file.length();
			times[i] = end - start;
		}

		long average = Math.round(Arrays.stream(times).average().getAsDouble());
		long min = Arrays.stream(times).min().getAsLong();
		System.out.println("\tTook: " + StringFormatter.addCommas(average) + "ns on average.  Min:" + StringFormatter.addCommas(min) + " size: "
				+ StringFormatter.addCommas(size) + " bytes");
		System.out.println("\t" + StringFormatter.formatBytesLong((long) (size / (average / 1_000_000_000.0))) + " per second");
	}

	public abstract void writeObjectToFile(File file, Object obj);

	public abstract byte[] writeObjectToBytes(Object obj);

	public static class MyLibraryNative extends Library {
		public MyLibraryNative() {
			SerializationUtils.init();
		}

		@Override
		public void writeObjectToFile(File file, Object obj) {
			NativeUtils.NATIVES_ENABLED = true;
			EmpireOutput out = new EmpireOutput(new NativeFileOutput(file));
			out.writeObject(obj);
			out.close();
		}

		@Override
		public byte[] writeObjectToBytes(Object obj) {
			NativeUtils.NATIVES_ENABLED = true;
			NativeOutput out = new NativeOutput(4096);
			EmpireOutput stream = new EmpireOutput(out);
			stream.writeObject(obj);
			byte[] bytes = Arrays.copyOf(out.getBuffer(), out.getBufferPosition());

			stream.close();

			return bytes;
		}

	}

	public static class MyLibraryJava extends Library {
		public MyLibraryJava() {
			SerializationUtils.init();
		}

		@Override
		public void writeObjectToFile(File file, Object obj) {
			NativeUtils.NATIVES_ENABLED = false;
			EmpireOutput out = new EmpireOutput(new NativeFileOutput(file));
			out.writeObject(obj);
			out.close();
		}

		@Override
		public byte[] writeObjectToBytes(Object obj) {
			NativeUtils.NATIVES_ENABLED = false;
			NativeOutput out = new NativeOutput(4096);
			EmpireOutput stream = new EmpireOutput(out);
			stream.writeObject(obj);
			byte[] bytes = Arrays.copyOf(out.getBuffer(), out.getBufferPosition());

			stream.close();

			return bytes;
		}

	}

	public static class JavaSerialization extends Library {
		public JavaSerialization() {
		}

		@Override
		public void writeObjectToFile(File file, Object obj) {
			FileOutputStream stream = null;
			ObjectOutputStream out = null;
			try {
				stream = new FileOutputStream(file);
				out = new ObjectOutputStream(stream);
				out.writeObject(obj);

			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				try {
					out.close();
					stream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

		}

		@Override
		public byte[] writeObjectToBytes(Object obj) {
			ByteArrayOutputStream str = new ByteArrayOutputStream(4096);
			try {
				ObjectOutputStream out = new ObjectOutputStream(str);
				out.writeObject(obj);
				out.close();

			} catch (IOException e) {
				e.printStackTrace();
			}

			return str.toByteArray();
		}

	}

	public static class KryoLibrary extends Library {
		private Kryo k = new Kryo();

		public KryoLibrary() {

		}

		@Override
		public void writeObjectToFile(File file, Object obj) {
			try {
				Output out = new Output(new FileOutputStream(file));
				k.writeClassAndObject(out, obj);
				out.flush();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		@Override
		public byte[] writeObjectToBytes(Object obj) {
			Output out = new Output(4096, Integer.MAX_VALUE);
			k.writeClassAndObject(out, obj);
			return out.toBytes();
		}

	}

	public static class GSON extends Library {
		private Gson gson = new Gson();

		@Override
		public void writeObjectToFile(File file, Object obj) {
			FileWriter writer = null;
			try {
				writer = new FileWriter(file);
				writer.write(gson.toJson(obj));
			} catch (IOException e) {
				e.printStackTrace();
			}
			try {
				writer.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		@Override
		public byte[] writeObjectToBytes(Object obj) {
			return gson.toJson(obj).getBytes();
		}

	}

}
